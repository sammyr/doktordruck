"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable$1),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %c👷‍ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(...args){\n        super(...args);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = (line, value, otherValue = 0)=>{\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(target);\n};\nvar getSubject = ({ page, withPlaceholder, axis, frame })=>{\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant() : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nconst toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((droppables)=>Object.values(droppables));\nconst toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = ({ isMovingForward, draggable, destination, insideDestination, previousImpact })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({ target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn })=>{\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({ afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last }) {\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({ insideDestination, inHomeList, displacedBy, destination }) {\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact({ draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate }) {\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = ({ isMovingForward, destination, draggables, combine, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = ({ isMovingForward, isInHomeList, insideDestination, location })=>{\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = ({ isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical })=>{\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = ({ displaced, afterCritical, combineWith, displacedBy })=>{\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = ({ afterCritical, impact, draggables })=>{\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant() : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({ axis, moveInto, isMoving })=>patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\nvar whenReordering = ({ impact, draggable, draggables, droppable, afterCritical })=>{\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = ({ impact, draggable, droppable, draggables, afterCritical })=>{\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = ({ impact, viewport, destination, draggables, maxScrollChange })=>{\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = ({ pageBorderBoxCenter, draggable, viewport })=>{\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = ({ draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false })=>{\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = ({ isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical })=>{\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = ({ isMovingForward, pageBorderBoxCenter, source, droppables, viewport })=>{\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = ({ pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical })=>{\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = ({ previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical })=>{\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = ({ isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical })=>{\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = ({ state, type })=>{\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({ pageBorderBox, draggable, candidates }) {\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({ pageBorderBox, draggable, droppables }) {\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced({ displaced, id }) {\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex({ draggable, closest, inHomeList }) {\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = ({ pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical })=>{\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({ draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = ({ pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical })=>{\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = ({ previousImpact, impact, droppables })=>{\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({ draggable, draggables, droppables, previousImpact, impact })=>{\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = ({ state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest })=>{\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = ({ impact, viewport, draggables, destination, forceShouldAnimate })=>{\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = ({ impact, draggable, droppable, draggables, viewport, afterCritical })=>{\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = ({ state, dimensions: forcedDimensions, viewport: forcedViewport })=>{\n    !(state.movementMode === \"SNAP\") ?  true ? invariant() : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = ({ draggable, home, draggables, viewport })=>{\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = ({ draggable, offset: offset$1, initialWindowScroll })=>{\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = ({ additions, updatedDroppables, viewport })=>{\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nconst timingsKey = \"Processing dynamic changes\";\nvar publishWhileDraggingInVirtual = ({ state, published })=>{\n    start();\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish(timingsKey);\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = (state = idle$2, action)=>{\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nfunction guard(action, predicate) {\n    return action instanceof Object && \"type\" in action && action.type === predicate;\n}\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[🔥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>({ getState, dispatch })=>(next)=>(action)=>{\n                if (!guard(action, \"LIFT\")) {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    marshal.dragging();\n                }\n                if (guard(action, \"DROP_ANIMATE\")) {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\")) {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({ current, destination, reason })=>{\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = ({ impact, draggable, dimensions, viewport, afterCritical })=>{\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = ({ draggables, reason, lastImpact, home, viewport, onLiftImpact })=>{\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = ({ getState, dispatch })=>(next)=>(action)=>{\n            if (!guard(action, \"DROP\")) {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener({ onWindowScroll }) {\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldStop$1 = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && guard(action, \"INITIAL_PUBLISH\")) {\n                listener.start();\n            }\n            if (listener.isActive() && shouldStop$1(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (guard(action, \"BEFORE_INITIAL_CAPTURE\")) {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (guard(action, \"FLUSH\")) {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (!guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                clear();\n            }\n            next(action);\n            if (!guard(action, \"DROP_ANIMATE\")) {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"DROP_COMPLETE\") || guard(action, \"FLUSH\") || guard(action, \"DROP_ANIMATE\")) {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (guard(action, \"FLUSH\")) {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (!guard(action, \"PUBLISH_WHILE_DRAGGING\")) {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop({\n                reason: postActionState.reason\n            }));\n        };\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_6__.compose;\nvar createStore = ({ dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller })=>(0,redux__WEBPACK_IMPORTED_MODULE_6__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_6__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher({ registry, callbacks }) {\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = ({ scrollHeight, scrollWidth, height, width })=>{\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = ({ critical, scrollOptions, registry })=>{\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = ({ center, destination, droppables })=>{\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = ({ startOfRange, endOfRange, current })=>{\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = ({ distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = ({ container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = ({ container, subject, proposedScroll })=>{\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = ({ dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return ({ current, max, change })=>{\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = ({ max: rawMax, current, change })=>{\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = ({ viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = ({ droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = ({ state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions })=>{\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = ({ scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions })=>{\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = ({ move, scrollDroppable, scrollWindow })=>{\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = ({ scrollDroppable, scrollWindow, move, getAutoScrollerOptions })=>{\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>{\n    if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n        return el.ownerDocument.defaultView;\n    }\n    return window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            registry.clean();\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nconst defaults = {\n    separator: \"::\"\n};\nfunction useUniqueId(prefix, options = defaults) {\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nfunction getElementId({ contextId, uniqueId }) {\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({ contextId, text }) {\n    const uniqueId = useUniqueId(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings({ cancel, completed, getPhase, setPhase }) {\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({ cancel, getPhase }) {\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings({ cancel, completed, getPhase }) {\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant() : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useIsomorphicLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive({ expected, phase, isLockActive, shouldWarn }) {\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart({ lockAPI, store, registry, draggableId }) {\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart({ lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent }) {\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options = {\n            shouldBlockNextClick: false\n        }) {\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal({ contextId, store, registry, customSensors, enableDefaultSensors }) {\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useIsomorphicLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>(0,redux__WEBPACK_IMPORTED_MODULE_6__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_6__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_8__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useIsomorphicLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((el = null)=>{\n        ref.current = el;\n    }, []);\n    const getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((mode, isClone, draggingOver = null, combineWith = null, dropping = null)=>({\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        }));\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null)=>({\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        }));\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(getSecondarySnapshot);\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((offset, combineTargetFor = null, shouldAnimateDisplacement)=>({\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        }));\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_8__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable);\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant() : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = ({ descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest })=>{\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = ({ ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject })=>{\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>(0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required({ props }) {\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean({ props }) {\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref({ getDroppableRef }) {\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder({ props, getPlaceholderRef }) {\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone({ props }) {\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder({ getPlaceholderRef }) {\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>droppableRef.current, []);\n    const setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((value = null)=>{\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>placeholderRef.current, []);\n    const setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)((value = null)=>{\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useCallback)(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, ({ onClose, data, animate })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            })), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_7__.useMemo)(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_8__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable);\nvar ConnectedDroppable$1 = ConnectedDroppable;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdGO0FBQ3hDO0FBQ21EO0FBQ25EO0FBQ0k7QUFDaUQ7QUFDaEU7QUFDTjtBQUMyQjtBQUUxRCxNQUFNMkIsaUJBQWlCQyxrQkFBeUI7QUFDaEQsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxVQUFVQyxDQUFBQSxRQUFTQSxNQUFNQyxPQUFPLENBQUNKLGVBQWUsS0FBS0ksT0FBTyxDQUFDSCxxQkFBcUIsSUFBSUksSUFBSTtBQUNoRyxNQUFNQyxnQkFBZ0JDLENBQUFBLFVBQVdMLFFBQVEsQ0FBQzs7O0lBR3RDLEVBQUVBLFFBQVFLLFNBQVM7OztBQUd2QixDQUFDO0FBQ0QsTUFBTUMsc0JBQXNCRCxDQUFBQSxVQUFXO1FBQUNELGNBQWNDO1FBQVU7UUFBd0Q7UUFBb0I7S0FBa0I7QUFDOUosTUFBTUUsaUJBQWlCO0FBQ3ZCLFNBQVNDLElBQUlDLElBQUksRUFBRUosT0FBTztJQUN4QixJQUFJVCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBLElBQUksS0FBdUQsRUFBRSxFQUU1RDtJQUNEZSxPQUFPLENBQUNGLEtBQUssSUFBSUgsb0JBQW9CRDtBQUN2QztBQUNBLE1BQU1PLFVBQVVKLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBQy9CLE1BQU1DLFFBQVFOLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBRTdCLFNBQVNFLFVBQVU7QUFFbkIsU0FBU0MsV0FBV0MsTUFBTSxFQUFFQyxXQUFXO0lBQ3JDLE9BQU87UUFDTCxHQUFHRCxNQUFNO1FBQ1QsR0FBR0MsV0FBVztJQUNoQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0MsRUFBRSxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7SUFDN0MsTUFBTUMsYUFBYUYsU0FBU0csR0FBRyxDQUFDQyxDQUFBQTtRQUM5QixNQUFNQyxVQUFVVixXQUFXTSxlQUFlRyxRQUFRQyxPQUFPO1FBQ3pETixHQUFHTyxnQkFBZ0IsQ0FBQ0YsUUFBUUcsU0FBUyxFQUFFSCxRQUFRSSxFQUFFLEVBQUVIO1FBQ25ELE9BQU8sU0FBU0k7WUFDZFYsR0FBR1csbUJBQW1CLENBQUNOLFFBQVFHLFNBQVMsRUFBRUgsUUFBUUksRUFBRSxFQUFFSDtRQUN4RDtJQUNGO0lBQ0EsT0FBTyxTQUFTTTtRQUNkVCxXQUFXVSxPQUFPLENBQUNILENBQUFBO1lBQ2pCQTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1JLGVBQWVyQyxrQkFBeUI7QUFDOUMsTUFBTXNDLFdBQVc7QUFDakIsTUFBTUMscUJBQXFCQztBQUFPO0FBQ2xDRCxhQUFhRSxTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPLElBQUksQ0FBQ2xDLE9BQU87QUFDckI7QUFDQSxTQUFTbUMsVUFBVUMsU0FBUyxFQUFFcEMsT0FBTztJQUNuQyxJQUFJNkIsY0FBYztRQUNoQixNQUFNLElBQUlFLGFBQWFEO0lBQ3pCLE9BQU87UUFDTCxNQUFNLElBQUlDLGFBQWEsQ0FBQyxFQUFFRCxTQUFTLEVBQUUsRUFBRTlCLFdBQVcsR0FBRyxDQUFDO0lBQ3hEO0FBQ0Y7QUFFQSxNQUFNcUMsc0JBQXNCekUsd0RBQWU7SUFDekMyRSxZQUFZLEdBQUdDLElBQUksQ0FBRTtRQUNuQixLQUFLLElBQUlBO1FBQ1QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDaEIsTUFBTSxHQUFHZjtRQUNkLElBQUksQ0FBQ2dDLGFBQWEsR0FBR0MsQ0FBQUE7WUFDbkIsTUFBTUYsWUFBWSxJQUFJLENBQUNHLFlBQVk7WUFDbkMsSUFBSUgsVUFBVUksVUFBVSxJQUFJO2dCQUMxQkosVUFBVUssUUFBUTtnQkFoRjFCLEtBaUY2QyxHQUFHdkMsUUFBUSxDQUFDOzs7TUFHbkQsQ0FBQyxJQUFJLENBQU07WUFDWDtZQUNBLE1BQU13QyxNQUFNSixNQUFNbEMsS0FBSztZQUN2QixJQUFJc0MsZUFBZWhCLGNBQWM7Z0JBQy9CWSxNQUFNSyxjQUFjO2dCQUNwQixJQUFJeEQsSUFBeUIsRUFBYztvQkFDekNpQixNQUFNc0MsSUFBSS9DLE9BQU87Z0JBQ25CO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQzRDLFlBQVksR0FBRztZQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDSCxTQUFTLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSVQsTUFBTTtZQUNsQjtZQUNBLE9BQU8sSUFBSSxDQUFDUyxTQUFTO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDUSxZQUFZLEdBQUdSLENBQUFBO1lBQ2xCLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNuQjtJQUNGO0lBQ0FTLG9CQUFvQjtRQUNsQixJQUFJLENBQUN6QixNQUFNLEdBQUdYLFdBQVdULFFBQVE7WUFBQztnQkFDaENrQixXQUFXO2dCQUNYQyxJQUFJLElBQUksQ0FBQ2tCLGFBQWE7WUFDeEI7U0FBRTtJQUNKO0lBQ0FTLGtCQUFrQkosR0FBRyxFQUFFO1FBQ3JCLElBQUlBLGVBQWVoQixjQUFjO1lBQy9CLElBQUl2QyxJQUF5QixFQUFjO2dCQUN6Q2lCLE1BQU1zQyxJQUFJL0MsT0FBTztZQUNuQjtZQUNBLElBQUksQ0FBQ29ELFFBQVEsQ0FBQyxDQUFDO1lBQ2Y7UUFDRjtRQUNBLE1BQU1MO0lBQ1I7SUFDQU0sdUJBQXVCO1FBQ3JCLElBQUksQ0FBQzVCLE1BQU07SUFDYjtJQUNBNkIsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNDLFFBQVEsQ0FBQyxJQUFJLENBQUNQLFlBQVk7SUFDOUM7QUFDRjtBQUVBLE1BQU1RLDhCQUE4QixDQUFDOzs7O0FBSXJDLENBQUM7QUFDRCxNQUFNQyxXQUFXQyxDQUFBQSxRQUFTQSxRQUFRO0FBQ2xDLE1BQU1DLGNBQWNDLENBQUFBLFFBQVMsQ0FBQztzQ0FDUSxFQUFFSCxTQUFTRyxNQUFNQyxNQUFNLENBQUNILEtBQUssRUFBRTtBQUNyRSxDQUFDO0FBQ0QsTUFBTUksZUFBZSxDQUFDRCxRQUFRRTtJQUM1QixNQUFNQyxlQUFlSCxPQUFPSSxXQUFXLEtBQUtGLFlBQVlFLFdBQVc7SUFDbkUsTUFBTUMsZ0JBQWdCVCxTQUFTSSxPQUFPSCxLQUFLO0lBQzNDLE1BQU1TLGNBQWNWLFNBQVNNLFlBQVlMLEtBQUs7SUFDOUMsSUFBSU0sY0FBYztRQUNoQixPQUFPLENBQUM7NENBQ2dDLEVBQUVFLGNBQWM7a0JBQzFDLEVBQUVDLFlBQVk7SUFDNUIsQ0FBQztJQUNIO0lBQ0EsT0FBTyxDQUFDOzBDQUNnQyxFQUFFRCxjQUFjO1lBQzlDLEVBQUVMLE9BQU9JLFdBQVcsQ0FBQztZQUNyQixFQUFFRixZQUFZRSxXQUFXLENBQUM7Z0JBQ3RCLEVBQUVFLFlBQVk7RUFDNUIsQ0FBQztBQUNIO0FBQ0EsTUFBTUMsY0FBYyxDQUFDQyxJQUFJUixRQUFRUztJQUMvQixNQUFNQyxhQUFhVixPQUFPSSxXQUFXLEtBQUtLLFFBQVFMLFdBQVc7SUFDN0QsSUFBSU0sWUFBWTtRQUNkLE9BQU8sQ0FBQztlQUNHLEVBQUVGLEdBQUc7NkJBQ1MsRUFBRUMsUUFBUUUsV0FBVyxDQUFDLENBQUM7SUFDbEQ7SUFDQSxPQUFPLENBQUM7ZUFDSyxFQUFFSCxHQUFHO2NBQ04sRUFBRVIsT0FBT0ksV0FBVyxDQUFDOzZCQUNOLEVBQUVLLFFBQVFFLFdBQVcsQ0FBQztjQUNyQyxFQUFFRixRQUFRTCxXQUFXLENBQUM7SUFDaEMsQ0FBQztBQUNMO0FBQ0EsTUFBTVEsZUFBZUMsQ0FBQUE7SUFDbkIsTUFBTUMsV0FBV0QsT0FBT1gsV0FBVztJQUNuQyxJQUFJWSxVQUFVO1FBQ1osT0FBT2IsYUFBYVksT0FBT2IsTUFBTSxFQUFFYztJQUNyQztJQUNBLE1BQU1MLFVBQVVJLE9BQU9KLE9BQU87SUFDOUIsSUFBSUEsU0FBUztRQUNYLE9BQU9GLFlBQVlNLE9BQU9GLFdBQVcsRUFBRUUsT0FBT2IsTUFBTSxFQUFFUztJQUN4RDtJQUNBLE9BQU87QUFDVDtBQUNBLE1BQU1NLGtCQUFrQmYsQ0FBQUEsU0FBVSxDQUFDOztLQUU5QixFQUFFSixTQUFTSSxPQUFPSCxLQUFLLEVBQUU7QUFDOUIsQ0FBQztBQUNELE1BQU1tQixZQUFZQyxDQUFBQTtJQUNoQixJQUFJQSxPQUFPQyxNQUFNLEtBQUssVUFBVTtRQUM5QixPQUFPLENBQUM7O01BRU4sRUFBRUgsZ0JBQWdCRSxPQUFPakIsTUFBTSxFQUFFO0lBQ25DLENBQUM7SUFDSDtJQUNBLE1BQU1jLFdBQVdHLE9BQU9mLFdBQVc7SUFDbkMsTUFBTU8sVUFBVVEsT0FBT1IsT0FBTztJQUM5QixJQUFJSyxVQUFVO1FBQ1osT0FBTyxDQUFDOztNQUVOLEVBQUViLGFBQWFnQixPQUFPakIsTUFBTSxFQUFFYyxVQUFVO0lBQzFDLENBQUM7SUFDSDtJQUNBLElBQUlMLFNBQVM7UUFDWCxPQUFPLENBQUM7O01BRU4sRUFBRUYsWUFBWVUsT0FBT04sV0FBVyxFQUFFTSxPQUFPakIsTUFBTSxFQUFFUyxTQUFTO0lBQzVELENBQUM7SUFDSDtJQUNBLE9BQU8sQ0FBQzs7SUFFTixFQUFFTSxnQkFBZ0JFLE9BQU9qQixNQUFNLEVBQUU7RUFDbkMsQ0FBQztBQUNIO0FBQ0EsTUFBTW1CLFNBQVM7SUFDYnhCO0lBQ0FHO0lBQ0FjO0lBQ0FJO0FBQ0Y7QUFFQSxNQUFNSSxTQUFTO0lBQ2JDLEdBQUc7SUFDSEMsR0FBRztBQUNMO0FBQ0EsTUFBTUMsTUFBTSxDQUFDQyxRQUFRQyxTQUFZO1FBQy9CSixHQUFHRyxPQUFPSCxDQUFDLEdBQUdJLE9BQU9KLENBQUM7UUFDdEJDLEdBQUdFLE9BQU9GLENBQUMsR0FBR0csT0FBT0gsQ0FBQztJQUN4QjtBQUNBLE1BQU1JLFdBQVcsQ0FBQ0YsUUFBUUMsU0FBWTtRQUNwQ0osR0FBR0csT0FBT0gsQ0FBQyxHQUFHSSxPQUFPSixDQUFDO1FBQ3RCQyxHQUFHRSxPQUFPRixDQUFDLEdBQUdHLE9BQU9ILENBQUM7SUFDeEI7QUFDQSxNQUFNSyxZQUFZLENBQUNILFFBQVFDLFNBQVdELE9BQU9ILENBQUMsS0FBS0ksT0FBT0osQ0FBQyxJQUFJRyxPQUFPRixDQUFDLEtBQUtHLE9BQU9ILENBQUM7QUFDcEYsTUFBTU0sU0FBU0MsQ0FBQUEsUUFBVTtRQUN2QlIsR0FBR1EsTUFBTVIsQ0FBQyxLQUFLLElBQUksQ0FBQ1EsTUFBTVIsQ0FBQyxHQUFHO1FBQzlCQyxHQUFHTyxNQUFNUCxDQUFDLEtBQUssSUFBSSxDQUFDTyxNQUFNUCxDQUFDLEdBQUc7SUFDaEM7QUFDQSxNQUFNUSxRQUFRLENBQUNDLE1BQU1qRyxPQUFPa0csYUFBYSxDQUFDO0lBQ3hDLElBQUlELFNBQVMsS0FBSztRQUNoQixPQUFPO1lBQ0xWLEdBQUd2RjtZQUNId0YsR0FBR1U7UUFDTDtJQUNGO0lBQ0EsT0FBTztRQUNMWCxHQUFHVztRQUNIVixHQUFHeEY7SUFDTDtBQUNGO0FBQ0EsTUFBTW1HLFdBQVcsQ0FBQ1QsUUFBUUMsU0FBV1MsS0FBS0MsSUFBSSxDQUFDLENBQUNWLE9BQU9KLENBQUMsR0FBR0csT0FBT0gsQ0FBQyxLQUFLLElBQUksQ0FBQ0ksT0FBT0gsQ0FBQyxHQUFHRSxPQUFPRixDQUFDLEtBQUs7QUFDckcsTUFBTWMsWUFBWSxDQUFDQyxRQUFRQyxTQUFXSixLQUFLSyxHQUFHLElBQUlELE9BQU9qRixHQUFHLENBQUN3RSxDQUFBQSxRQUFTSSxTQUFTSSxRQUFRUjtBQUN2RixNQUFNVyxRQUFROUUsQ0FBQUEsS0FBTW1FLENBQUFBLFFBQVU7WUFDNUJSLEdBQUczRCxHQUFHbUUsTUFBTVIsQ0FBQztZQUNiQyxHQUFHNUQsR0FBR21FLE1BQU1QLENBQUM7UUFDZjtBQUVBLElBQUltQixjQUFjLENBQUNDLE9BQU9DO0lBQ3hCLE1BQU0xQixTQUFTbEcsc0RBQU9BLENBQUM7UUFDckI2SCxLQUFLVixLQUFLVyxHQUFHLENBQUNGLFFBQVFDLEdBQUcsRUFBRUYsTUFBTUUsR0FBRztRQUNwQ0UsT0FBT1osS0FBS0ssR0FBRyxDQUFDSSxRQUFRRyxLQUFLLEVBQUVKLE1BQU1JLEtBQUs7UUFDMUNDLFFBQVFiLEtBQUtLLEdBQUcsQ0FBQ0ksUUFBUUksTUFBTSxFQUFFTCxNQUFNSyxNQUFNO1FBQzdDQyxNQUFNZCxLQUFLVyxHQUFHLENBQUNGLFFBQVFLLElBQUksRUFBRU4sTUFBTU0sSUFBSTtJQUN6QztJQUNBLElBQUkvQixPQUFPZ0MsS0FBSyxJQUFJLEtBQUtoQyxPQUFPaUMsTUFBTSxJQUFJLEdBQUc7UUFDM0MsT0FBTztJQUNUO0lBQ0EsT0FBT2pDO0FBQ1Q7QUFFQSxNQUFNa0MsbUJBQW1CLENBQUNDLFNBQVN2QixRQUFXO1FBQzVDZSxLQUFLUSxRQUFRUixHQUFHLEdBQUdmLE1BQU1QLENBQUM7UUFDMUIwQixNQUFNSSxRQUFRSixJQUFJLEdBQUduQixNQUFNUixDQUFDO1FBQzVCMEIsUUFBUUssUUFBUUwsTUFBTSxHQUFHbEIsTUFBTVAsQ0FBQztRQUNoQ3dCLE9BQU9NLFFBQVFOLEtBQUssR0FBR2pCLE1BQU1SLENBQUM7SUFDaEM7QUFDQSxNQUFNZ0MsYUFBYUQsQ0FBQUEsVUFBVztRQUFDO1lBQzdCL0IsR0FBRytCLFFBQVFKLElBQUk7WUFDZjFCLEdBQUc4QixRQUFRUixHQUFHO1FBQ2hCO1FBQUc7WUFDRHZCLEdBQUcrQixRQUFRTixLQUFLO1lBQ2hCeEIsR0FBRzhCLFFBQVFSLEdBQUc7UUFDaEI7UUFBRztZQUNEdkIsR0FBRytCLFFBQVFKLElBQUk7WUFDZjFCLEdBQUc4QixRQUFRTCxNQUFNO1FBQ25CO1FBQUc7WUFDRDFCLEdBQUcrQixRQUFRTixLQUFLO1lBQ2hCeEIsR0FBRzhCLFFBQVFMLE1BQU07UUFDbkI7S0FBRTtBQUNGLE1BQU1PLFlBQVk7SUFDaEJWLEtBQUs7SUFDTEUsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLE1BQU07QUFDUjtBQUVBLE1BQU1PLFdBQVcsQ0FBQ2xCLFFBQVFLO0lBQ3hCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPYyxpQkFBaUJkLFFBQVFLLE1BQU1jLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZO0FBQ2hFO0FBQ0EsTUFBTUMsV0FBVyxDQUFDdEIsUUFBUXVCLE1BQU1DO0lBQzlCLElBQUlBLG1CQUFtQkEsZ0JBQWdCQyxXQUFXLEVBQUU7UUFDbEQsT0FBTztZQUNMLEdBQUd6QixNQUFNO1lBQ1QsQ0FBQ3VCLEtBQUtHLEdBQUcsQ0FBQyxFQUFFMUIsTUFBTSxDQUFDdUIsS0FBS0csR0FBRyxDQUFDLEdBQUdGLGdCQUFnQkMsV0FBVyxDQUFDRixLQUFLN0IsSUFBSSxDQUFDO1FBQ3ZFO0lBQ0Y7SUFDQSxPQUFPTTtBQUNUO0FBQ0EsTUFBTTJCLE9BQU8sQ0FBQzNCLFFBQVFLO0lBQ3BCLElBQUlBLFNBQVNBLE1BQU11QixpQkFBaUIsRUFBRTtRQUNwQyxPQUFPeEIsWUFBWUMsTUFBTXdCLGFBQWEsRUFBRTdCO0lBQzFDO0lBQ0EsT0FBT3RILHNEQUFPQSxDQUFDc0g7QUFDakI7QUFDQSxJQUFJOEIsYUFBYSxDQUFDLEVBQ2hCQyxJQUFJLEVBQ0pQLGVBQWUsRUFDZkQsSUFBSSxFQUNKbEIsS0FBSyxFQUNOO0lBQ0MsTUFBTTJCLFdBQVdkLFNBQVNhLEtBQUtFLFNBQVMsRUFBRTVCO0lBQzFDLE1BQU02QixZQUFZWixTQUFTVSxVQUFVVCxNQUFNQztJQUMzQyxNQUFNVyxVQUFVUixLQUFLTyxXQUFXN0I7SUFDaEMsT0FBTztRQUNMMEI7UUFDQVA7UUFDQVksUUFBUUQ7SUFDVjtBQUNGO0FBRUEsSUFBSUUsa0JBQWtCLENBQUNDLFdBQVdDO0lBQ2hDLENBQUNELFVBQVVqQyxLQUFLLEdBQUdoSCxLQUFxQyxHQUFHMkMsY0FBY0EsQ0FBV0EsR0FBRyxLQUFLO0lBQzVGLE1BQU13RyxhQUFhRixVQUFVakMsS0FBSztJQUNsQyxNQUFNb0MsYUFBYXBELFNBQVNrRCxXQUFXQyxXQUFXckIsTUFBTSxDQUFDdUIsT0FBTztJQUNoRSxNQUFNQyxxQkFBcUJwRCxPQUFPa0Q7SUFDbEMsTUFBTXBDLFFBQVE7UUFDWixHQUFHbUMsVUFBVTtRQUNickIsUUFBUTtZQUNOdUIsU0FBU0YsV0FBV3JCLE1BQU0sQ0FBQ3VCLE9BQU87WUFDbENFLFNBQVNMO1lBQ1RuQixNQUFNO2dCQUNKM0gsT0FBT2dKO2dCQUNQcEIsY0FBY3NCO1lBQ2hCO1lBQ0FuQyxLQUFLZ0MsV0FBV3JCLE1BQU0sQ0FBQ1gsR0FBRztRQUM1QjtJQUNGO0lBQ0EsTUFBTUYsVUFBVXdCLFdBQVc7UUFDekJDLE1BQU1PLFVBQVVoQyxPQUFPLENBQUN5QixJQUFJO1FBQzVCUCxpQkFBaUJjLFVBQVVoQyxPQUFPLENBQUNrQixlQUFlO1FBQ2xERCxNQUFNZSxVQUFVZixJQUFJO1FBQ3BCbEI7SUFDRjtJQUNBLE1BQU16QixTQUFTO1FBQ2IsR0FBRzBELFNBQVM7UUFDWmpDO1FBQ0FDO0lBQ0Y7SUFDQSxPQUFPMUI7QUFDVDtBQUVBLE1BQU1pRSxpQkFBaUI1Six1REFBVUEsQ0FBQzZKLENBQUFBLGFBQWNBLFdBQVdDLE1BQU0sQ0FBQyxDQUFDQyxVQUFVSjtRQUMzRUksUUFBUSxDQUFDSixRQUFRSyxVQUFVLENBQUM5RSxFQUFFLENBQUMsR0FBR3lFO1FBQ2xDLE9BQU9JO0lBQ1QsR0FBRyxDQUFDO0FBQ0osTUFBTUUsaUJBQWlCakssdURBQVVBLENBQUNrSyxDQUFBQSxhQUFjQSxXQUFXSixNQUFNLENBQUMsQ0FBQ0MsVUFBVUo7UUFDM0VJLFFBQVEsQ0FBQ0osUUFBUUssVUFBVSxDQUFDOUUsRUFBRSxDQUFDLEdBQUd5RTtRQUNsQyxPQUFPSTtJQUNULEdBQUcsQ0FBQztBQUNKLE1BQU1JLGtCQUFrQm5LLHVEQUFVQSxDQUFDNkosQ0FBQUEsYUFBY08sT0FBT0MsTUFBTSxDQUFDUjtBQUMvRCxNQUFNUyxrQkFBa0J0Syx1REFBVUEsQ0FBQ2tLLENBQUFBLGFBQWNFLE9BQU9DLE1BQU0sQ0FBQ0g7QUFFL0QsSUFBSUssK0JBQStCdkssdURBQVVBLENBQUMsQ0FBQzhFLGFBQWFvRjtJQUMxRCxNQUFNdkUsU0FBUzJFLGdCQUFnQkosWUFBWU0sTUFBTSxDQUFDQyxDQUFBQSxZQUFhM0YsZ0JBQWdCMkYsVUFBVVQsVUFBVSxDQUFDbEYsV0FBVyxFQUFFNEYsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVYLFVBQVUsQ0FBQ3pGLEtBQUssR0FBR3FHLEVBQUVaLFVBQVUsQ0FBQ3pGLEtBQUs7SUFDdkssT0FBT29CO0FBQ1Q7QUFFQSxTQUFTa0Ysa0JBQWtCQyxNQUFNO0lBQy9CLElBQUlBLE9BQU9DLEVBQUUsSUFBSUQsT0FBT0MsRUFBRSxDQUFDL0osSUFBSSxLQUFLLFdBQVc7UUFDN0MsT0FBTzhKLE9BQU9DLEVBQUUsQ0FBQ25HLFdBQVc7SUFDOUI7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTb0csY0FBY0YsTUFBTTtJQUMzQixJQUFJQSxPQUFPQyxFQUFFLElBQUlELE9BQU9DLEVBQUUsQ0FBQy9KLElBQUksS0FBSyxXQUFXO1FBQzdDLE9BQU84SixPQUFPQyxFQUFFLENBQUM1RixPQUFPO0lBQzFCO0lBQ0EsT0FBTztBQUNUO0FBRUEsSUFBSThGLDBCQUEwQmpMLHVEQUFVQSxDQUFDLENBQUNrTCxRQUFRQyxPQUFTQSxLQUFLWCxNQUFNLENBQUNZLENBQUFBLE9BQVFBLEtBQUtwQixVQUFVLENBQUM5RSxFQUFFLEtBQUtnRyxPQUFPbEIsVUFBVSxDQUFDOUUsRUFBRTtBQUUxSCxJQUFJbUcsb0JBQW9CLENBQUMsRUFDdkJDLGVBQWUsRUFDZmIsU0FBUyxFQUNUN0YsV0FBVyxFQUNYMkcsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2Y7SUFDQyxJQUFJLENBQUM1RyxZQUFZNkcsZ0JBQWdCLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsTUFBTWpHLFdBQVdxRixrQkFBa0JXO0lBQ25DLElBQUksQ0FBQ2hHLFVBQVU7UUFDYixPQUFPO0lBQ1Q7SUFDQSxTQUFTa0csVUFBVTNFLE1BQU07UUFDdkIsTUFBTWdFLEtBQUs7WUFDVC9KLE1BQU07WUFDTm1FLFNBQVM7Z0JBQ1BFLGFBQWEwQjtnQkFDYmpDLGFBQWFGLFlBQVlvRixVQUFVLENBQUM5RSxFQUFFO1lBQ3hDO1FBQ0Y7UUFDQSxPQUFPO1lBQ0wsR0FBR3NHLGNBQWM7WUFDakJUO1FBQ0Y7SUFDRjtJQUNBLE1BQU1ZLE1BQU1ILGVBQWVJLFNBQVMsQ0FBQ0QsR0FBRztJQUN4QyxNQUFNRSxZQUFZRixJQUFJRyxNQUFNLEdBQUdILEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDeEMsSUFBSUwsaUJBQWlCO1FBQ25CLE9BQU9PLFlBQVlILFVBQVVHLGFBQWE7SUFDNUM7SUFDQSxNQUFNRSxtQkFBbUJkLHdCQUF3QlIsV0FBV2M7SUFDNUQsSUFBSSxDQUFDTSxXQUFXO1FBQ2QsSUFBSSxDQUFDRSxpQkFBaUJELE1BQU0sRUFBRTtZQUM1QixPQUFPO1FBQ1Q7UUFDQSxNQUFNRSxPQUFPRCxnQkFBZ0IsQ0FBQ0EsaUJBQWlCRCxNQUFNLEdBQUcsRUFBRTtRQUMxRCxPQUFPSixVQUFVTSxLQUFLaEMsVUFBVSxDQUFDOUUsRUFBRTtJQUNyQztJQUNBLE1BQU0rRyxpQkFBaUJGLGlCQUFpQkcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbkMsVUFBVSxDQUFDOUUsRUFBRSxLQUFLMkc7SUFDM0UsQ0FBRUksQ0FBQUEsbUJBQW1CLENBQUMsS0FBSzdMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMENBQTBDQSxDQUFXQSxHQUFHLEtBQUs7SUFDakosTUFBTXFKLGdCQUFnQkgsaUJBQWlCO0lBQ3ZDLElBQUlHLGdCQUFnQixHQUFHO1FBQ3JCLE9BQU87SUFDVDtJQUNBLE1BQU1DLFNBQVNOLGdCQUFnQixDQUFDSyxjQUFjO0lBQzlDLE9BQU9WLFVBQVVXLE9BQU9yQyxVQUFVLENBQUM5RSxFQUFFO0FBQ3ZDO0FBRUEsSUFBSW9ILFdBQVcsQ0FBQzdCLFdBQVc3RixjQUFnQjZGLFVBQVVULFVBQVUsQ0FBQ2xGLFdBQVcsS0FBS0YsWUFBWW9GLFVBQVUsQ0FBQzlFLEVBQUU7QUFFekcsTUFBTXFILGdCQUFnQjtJQUNwQmhHLE9BQU9UO0lBQ1B0RixPQUFPO0FBQ1Q7QUFDQSxNQUFNZ00sY0FBYztJQUNsQkMsV0FBVyxDQUFDO0lBQ1pDLFNBQVMsQ0FBQztJQUNWZixLQUFLLEVBQUU7QUFDVDtBQUNBLE1BQU1nQixXQUFXO0lBQ2ZmLFdBQVdZO0lBQ1hJLGFBQWFMO0lBQ2J4QixJQUFJO0FBQ047QUFFQSxJQUFJOEIsV0FBVyxDQUFDQyxZQUFZQyxhQUFldk0sQ0FBQUEsUUFBU3NNLGNBQWN0TSxTQUFTQSxTQUFTdU07QUFFcEYsSUFBSUMsaUNBQWlDNUYsQ0FBQUE7SUFDbkMsTUFBTTZGLG1CQUFtQkosU0FBU3pGLE1BQU1FLEdBQUcsRUFBRUYsTUFBTUssTUFBTTtJQUN6RCxNQUFNeUYscUJBQXFCTCxTQUFTekYsTUFBTU0sSUFBSSxFQUFFTixNQUFNSSxLQUFLO0lBQzNELE9BQU9ILENBQUFBO1FBQ0wsTUFBTThGLGNBQWNGLGlCQUFpQjVGLFFBQVFDLEdBQUcsS0FBSzJGLGlCQUFpQjVGLFFBQVFJLE1BQU0sS0FBS3lGLG1CQUFtQjdGLFFBQVFLLElBQUksS0FBS3dGLG1CQUFtQjdGLFFBQVFHLEtBQUs7UUFDN0osSUFBSTJGLGFBQWE7WUFDZixPQUFPO1FBQ1Q7UUFDQSxNQUFNQywrQkFBK0JILGlCQUFpQjVGLFFBQVFDLEdBQUcsS0FBSzJGLGlCQUFpQjVGLFFBQVFJLE1BQU07UUFDckcsTUFBTTRGLGlDQUFpQ0gsbUJBQW1CN0YsUUFBUUssSUFBSSxLQUFLd0YsbUJBQW1CN0YsUUFBUUcsS0FBSztRQUMzRyxNQUFNOEYsdUJBQXVCRixnQ0FBZ0NDO1FBQzdELElBQUlDLHNCQUFzQjtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxNQUFNQyxxQkFBcUJsRyxRQUFRQyxHQUFHLEdBQUdGLE1BQU1FLEdBQUcsSUFBSUQsUUFBUUksTUFBTSxHQUFHTCxNQUFNSyxNQUFNO1FBQ25GLE1BQU0rRix1QkFBdUJuRyxRQUFRSyxJQUFJLEdBQUdOLE1BQU1NLElBQUksSUFBSUwsUUFBUUcsS0FBSyxHQUFHSixNQUFNSSxLQUFLO1FBQ3JGLE1BQU1pRywwQkFBMEJGLHNCQUFzQkM7UUFDdEQsSUFBSUMseUJBQXlCO1lBQzNCLE9BQU87UUFDVDtRQUNBLE1BQU1DLDBCQUEwQkgsc0JBQXNCRixrQ0FBa0NHLHdCQUF3Qko7UUFDaEgsT0FBT007SUFDVDtBQUNGO0FBRUEsSUFBSUMsK0JBQStCdkcsQ0FBQUE7SUFDakMsTUFBTTZGLG1CQUFtQkosU0FBU3pGLE1BQU1FLEdBQUcsRUFBRUYsTUFBTUssTUFBTTtJQUN6RCxNQUFNeUYscUJBQXFCTCxTQUFTekYsTUFBTU0sSUFBSSxFQUFFTixNQUFNSSxLQUFLO0lBQzNELE9BQU9ILENBQUFBO1FBQ0wsTUFBTThGLGNBQWNGLGlCQUFpQjVGLFFBQVFDLEdBQUcsS0FBSzJGLGlCQUFpQjVGLFFBQVFJLE1BQU0sS0FBS3lGLG1CQUFtQjdGLFFBQVFLLElBQUksS0FBS3dGLG1CQUFtQjdGLFFBQVFHLEtBQUs7UUFDN0osT0FBTzJGO0lBQ1Q7QUFDRjtBQUVBLE1BQU1TLFdBQVc7SUFDZkMsV0FBVztJQUNYcEgsTUFBTTtJQUNOcUgsZUFBZTtJQUNmckosT0FBTztJQUNQZ0UsS0FBSztJQUNMc0YsTUFBTTtJQUNOQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsZUFBZTtBQUNqQjtBQUNBLE1BQU1DLGFBQWE7SUFDakJOLFdBQVc7SUFDWHBILE1BQU07SUFDTnFILGVBQWU7SUFDZnJKLE9BQU87SUFDUGdFLEtBQUs7SUFDTHNGLE1BQU07SUFDTkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLGVBQWU7QUFDakI7QUFFQSxJQUFJRSxxQ0FBcUM5RixDQUFBQSxPQUFRbEIsQ0FBQUE7UUFDL0MsTUFBTTZGLG1CQUFtQkosU0FBU3pGLE1BQU1FLEdBQUcsRUFBRUYsTUFBTUssTUFBTTtRQUN6RCxNQUFNeUYscUJBQXFCTCxTQUFTekYsTUFBTU0sSUFBSSxFQUFFTixNQUFNSSxLQUFLO1FBQzNELE9BQU9ILENBQUFBO1lBQ0wsSUFBSWlCLFNBQVNzRixVQUFVO2dCQUNyQixPQUFPWCxpQkFBaUI1RixRQUFRQyxHQUFHLEtBQUsyRixpQkFBaUI1RixRQUFRSSxNQUFNO1lBQ3pFO1lBQ0EsT0FBT3lGLG1CQUFtQjdGLFFBQVFLLElBQUksS0FBS3dGLG1CQUFtQjdGLFFBQVFHLEtBQUs7UUFDN0U7SUFDRjtBQUVBLE1BQU02Ryx3QkFBd0IsQ0FBQ3RILFFBQVFuQztJQUNyQyxNQUFNd0QsZUFBZXhELFlBQVl3QyxLQUFLLEdBQUd4QyxZQUFZd0MsS0FBSyxDQUFDYyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsWUFBWSxHQUFHdEM7SUFDdEYsT0FBTytCLGlCQUFpQmQsUUFBUXFCO0FBQ2xDO0FBQ0EsTUFBTWtHLHVCQUF1QixDQUFDdkgsUUFBUW5DLGFBQWEySjtJQUNqRCxJQUFJLENBQUMzSixZQUFZeUMsT0FBTyxDQUFDOEIsTUFBTSxFQUFFO1FBQy9CLE9BQU87SUFDVDtJQUNBLE9BQU9vRix3QkFBd0IzSixZQUFZeUMsT0FBTyxDQUFDOEIsTUFBTSxFQUFFcEM7QUFDN0Q7QUFDQSxNQUFNeUgsc0JBQXNCLENBQUN6SCxRQUFRMEgsVUFBVUYsMEJBQTRCQSx3QkFBd0JFLFVBQVUxSDtBQUM3RyxNQUFNMkgsY0FBYyxDQUFDLEVBQ25CM0gsUUFBUTRILGFBQWEsRUFDckIvSixXQUFXLEVBQ1g2SixRQUFRLEVBQ1JHLHlCQUF5QixFQUN6QkwsdUJBQXVCLEVBQ3hCO0lBQ0MsTUFBTU0sa0JBQWtCRCw0QkFBNEJQLHNCQUFzQk0sZUFBZS9KLGVBQWUrSjtJQUN4RyxPQUFPTCxxQkFBcUJPLGlCQUFpQmpLLGFBQWEySiw0QkFBNEJDLG9CQUFvQkssaUJBQWlCSixVQUFVRjtBQUN2STtBQUNBLE1BQU1PLHFCQUFxQjFMLENBQUFBLE9BQVFzTCxZQUFZO1FBQzdDLEdBQUd0TCxJQUFJO1FBQ1BtTCx5QkFBeUJ2QjtJQUMzQjtBQUNBLE1BQU0rQixtQkFBbUIzTCxDQUFBQSxPQUFRc0wsWUFBWTtRQUMzQyxHQUFHdEwsSUFBSTtRQUNQbUwseUJBQXlCWjtJQUMzQjtBQUNBLE1BQU1xQix5QkFBeUI1TCxDQUFBQSxPQUFRc0wsWUFBWTtRQUNqRCxHQUFHdEwsSUFBSTtRQUNQbUwseUJBQXlCSCxtQ0FBbUNoTCxLQUFLd0IsV0FBVyxDQUFDMEQsSUFBSTtJQUNuRjtBQUVBLE1BQU0yRyxtQkFBbUIsQ0FBQy9KLElBQUk4RyxNQUFNa0Q7SUFDbEMsSUFBSSxPQUFPQSx1QkFBdUIsV0FBVztRQUMzQyxPQUFPQTtJQUNUO0lBQ0EsSUFBSSxDQUFDbEQsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLE1BQU0sRUFDSlMsU0FBUyxFQUNUQyxPQUFPLEVBQ1IsR0FBR1Y7SUFDSixJQUFJUyxTQUFTLENBQUN2SCxHQUFHLEVBQUU7UUFDakIsT0FBTztJQUNUO0lBQ0EsTUFBTTZFLFdBQVcyQyxPQUFPLENBQUN4SCxHQUFHO0lBQzVCLE9BQU82RSxXQUFXQSxTQUFTb0YsYUFBYSxHQUFHO0FBQzdDO0FBQ0EsU0FBU0MsVUFBVTNFLFNBQVMsRUFBRW1DLFdBQVc7SUFDdkMsTUFBTTVELFlBQVl5QixVQUFVM0IsSUFBSSxDQUFDRSxTQUFTO0lBQzFDLE1BQU1xRyxXQUFXO1FBQ2YvSCxLQUFLc0YsWUFBWXJHLEtBQUssQ0FBQ1AsQ0FBQztRQUN4QndCLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNa0YsWUFBWXJHLEtBQUssQ0FBQ1IsQ0FBQztJQUMzQjtJQUNBLE9BQU90RyxzREFBT0EsQ0FBQ0MscURBQU1BLENBQUNzSixXQUFXcUc7QUFDbkM7QUFDQSxTQUFTQyxzQkFBc0IsRUFDN0JDLGFBQWEsRUFDYjNLLFdBQVcsRUFDWGdJLFdBQVcsRUFDWDZCLFFBQVEsRUFDUlMsa0JBQWtCLEVBQ2xCbEQsSUFBSSxFQUNMO0lBQ0MsT0FBT3VELGNBQWN6RixNQUFNLENBQUMsU0FBUzFKLFFBQVFvUCxNQUFNLEVBQUUvRSxTQUFTO1FBQzVELE1BQU0xRCxTQUFTcUksVUFBVTNFLFdBQVdtQztRQUNwQyxNQUFNMUgsS0FBS3VGLFVBQVVULFVBQVUsQ0FBQzlFLEVBQUU7UUFDbENzSyxPQUFPN0QsR0FBRyxDQUFDOEQsSUFBSSxDQUFDdks7UUFDaEIsTUFBTXdLLFlBQVlaLG1CQUFtQjtZQUNuQy9IO1lBQ0FuQztZQUNBNko7WUFDQUcsMkJBQTJCO1FBQzdCO1FBQ0EsSUFBSSxDQUFDYyxXQUFXO1lBQ2RGLE9BQU8vQyxTQUFTLENBQUNoQyxVQUFVVCxVQUFVLENBQUM5RSxFQUFFLENBQUMsR0FBRztZQUM1QyxPQUFPc0s7UUFDVDtRQUNBLE1BQU1MLGdCQUFnQkYsaUJBQWlCL0osSUFBSThHLE1BQU1rRDtRQUNqRCxNQUFNOUcsZUFBZTtZQUNuQi9DLGFBQWFIO1lBQ2JpSztRQUNGO1FBQ0FLLE9BQU85QyxPQUFPLENBQUN4SCxHQUFHLEdBQUdrRDtRQUNyQixPQUFPb0g7SUFDVCxHQUFHO1FBQ0Q3RCxLQUFLLEVBQUU7UUFDUGUsU0FBUyxDQUFDO1FBQ1ZELFdBQVcsQ0FBQztJQUNkO0FBQ0Y7QUFFQSxTQUFTa0QsbUJBQW1CekYsVUFBVSxFQUFFakksT0FBTztJQUM3QyxJQUFJLENBQUNpSSxXQUFXNEIsTUFBTSxFQUFFO1FBQ3RCLE9BQU87SUFDVDtJQUNBLE1BQU04RCxrQkFBa0IxRixVQUFVLENBQUNBLFdBQVc0QixNQUFNLEdBQUcsRUFBRSxDQUFDOUIsVUFBVSxDQUFDekYsS0FBSztJQUMxRSxPQUFPdEMsUUFBUW1ELFVBQVUsR0FBR3dLLGtCQUFrQkEsa0JBQWtCO0FBQ2xFO0FBQ0EsU0FBU0MsUUFBUSxFQUNmdEUsaUJBQWlCLEVBQ2pCbkcsVUFBVSxFQUNWd0gsV0FBVyxFQUNYaEksV0FBVyxFQUNaO0lBQ0MsTUFBTWtMLFdBQVdILG1CQUFtQnBFLG1CQUFtQjtRQUNyRG5HO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x3RyxXQUFXWTtRQUNYSTtRQUNBN0IsSUFBSTtZQUNGL0osTUFBTTtZQUNONEQsYUFBYTtnQkFDWEUsYUFBYUYsWUFBWW9GLFVBQVUsQ0FBQzlFLEVBQUU7Z0JBQ3RDWCxPQUFPdUw7WUFDVDtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLHVCQUF1QixFQUM5QnRGLFNBQVMsRUFDVGMsaUJBQWlCLEVBQ2pCM0csV0FBVyxFQUNYNkosUUFBUSxFQUNSN0IsV0FBVyxFQUNYWixJQUFJLEVBQ0p6SCxLQUFLLEVBQ0wySyxrQkFBa0IsRUFDbkI7SUFDQyxNQUFNOUosYUFBYWtILFNBQVM3QixXQUFXN0Y7SUFDdkMsSUFBSUwsU0FBUyxNQUFNO1FBQ2pCLE9BQU9zTCxRQUFRO1lBQ2J0RTtZQUNBbkc7WUFDQXdIO1lBQ0FoSTtRQUNGO0lBQ0Y7SUFDQSxNQUFNb0wsUUFBUXpFLGtCQUFrQjBFLElBQUksQ0FBQzdFLENBQUFBLE9BQVFBLEtBQUtwQixVQUFVLENBQUN6RixLQUFLLEtBQUtBO0lBQ3ZFLElBQUksQ0FBQ3lMLE9BQU87UUFDVixPQUFPSCxRQUFRO1lBQ2J0RTtZQUNBbkc7WUFDQXdIO1lBQ0FoSTtRQUNGO0lBQ0Y7SUFDQSxNQUFNc0wsa0JBQWtCakYsd0JBQXdCUixXQUFXYztJQUMzRCxNQUFNNEUsWUFBWTVFLGtCQUFrQjZFLE9BQU8sQ0FBQ0o7SUFDNUMsTUFBTUssV0FBV0gsZ0JBQWdCSSxLQUFLLENBQUNIO0lBQ3ZDLE1BQU12RSxZQUFZMEQsc0JBQXNCO1FBQ3RDQyxlQUFlYztRQUNmekw7UUFDQWdJO1FBQ0FaO1FBQ0F5QyxVQUFVQSxTQUFTckgsS0FBSztRQUN4QjhIO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x0RDtRQUNBZ0I7UUFDQTdCLElBQUk7WUFDRi9KLE1BQU07WUFDTjRELGFBQWE7Z0JBQ1hFLGFBQWFGLFlBQVlvRixVQUFVLENBQUM5RSxFQUFFO2dCQUN0Q1g7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNnTSxzQkFBc0JsTCxXQUFXLEVBQUVtTCxhQUFhO0lBQ3ZELE9BQU9DLFFBQVFELGNBQWNFLFFBQVEsQ0FBQ3JMLFlBQVk7QUFDcEQ7QUFFQSxJQUFJc0wsY0FBYyxDQUFDLEVBQ2pCckYsZUFBZSxFQUNmMUcsV0FBVyxFQUNYc0YsVUFBVSxFQUNWL0UsT0FBTyxFQUNQcUwsYUFBYSxFQUNkO0lBQ0MsSUFBSSxDQUFDNUwsWUFBWTZHLGdCQUFnQixFQUFFO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE1BQU1tRixZQUFZekwsUUFBUUUsV0FBVztJQUNyQyxNQUFNd0wsY0FBYzNHLFVBQVUsQ0FBQzBHLFVBQVU7SUFDekMsTUFBTUUsbUJBQW1CRCxZQUFZN0csVUFBVSxDQUFDekYsS0FBSztJQUNyRCxNQUFNd00sbUNBQW1DUixzQkFBc0JLLFdBQVdKO0lBQzFFLElBQUlPLGtDQUFrQztRQUNwQyxJQUFJekYsaUJBQWlCO1lBQ25CLE9BQU93RjtRQUNUO1FBQ0EsT0FBT0EsbUJBQW1CO0lBQzVCO0lBQ0EsSUFBSXhGLGlCQUFpQjtRQUNuQixPQUFPd0YsbUJBQW1CO0lBQzVCO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLElBQUlFLGNBQWMsQ0FBQyxFQUNqQjFGLGVBQWUsRUFDZnpHLFlBQVksRUFDWjBHLGlCQUFpQixFQUNqQi9GLFFBQVEsRUFDVDtJQUNDLElBQUksQ0FBQytGLGtCQUFrQk8sTUFBTSxFQUFFO1FBQzdCLE9BQU87SUFDVDtJQUNBLE1BQU1tRixlQUFlekwsU0FBU2pCLEtBQUs7SUFDbkMsTUFBTTZILGdCQUFnQmQsa0JBQWtCMkYsZUFBZSxJQUFJQSxlQUFlO0lBQzFFLE1BQU1DLGFBQWEzRixpQkFBaUIsQ0FBQyxFQUFFLENBQUN2QixVQUFVLENBQUN6RixLQUFLO0lBQ3hELE1BQU00TSxZQUFZNUYsaUJBQWlCLENBQUNBLGtCQUFrQk8sTUFBTSxHQUFHLEVBQUUsQ0FBQzlCLFVBQVUsQ0FBQ3pGLEtBQUs7SUFDbEYsTUFBTXdJLGFBQWFsSSxlQUFlc00sWUFBWUEsWUFBWTtJQUMxRCxJQUFJL0UsZ0JBQWdCOEUsWUFBWTtRQUM5QixPQUFPO0lBQ1Q7SUFDQSxJQUFJOUUsZ0JBQWdCVyxZQUFZO1FBQzlCLE9BQU87SUFDVDtJQUNBLE9BQU9YO0FBQ1Q7QUFFQSxJQUFJZ0Ysa0JBQWtCLENBQUMsRUFDckI5RixlQUFlLEVBQ2Z6RyxZQUFZLEVBQ1o0RixTQUFTLEVBQ1RQLFVBQVUsRUFDVnRGLFdBQVcsRUFDWDJHLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkaUQsUUFBUSxFQUNSK0IsYUFBYSxFQUNkO0lBQ0MsTUFBTWEsUUFBUTdGLGVBQWVULEVBQUU7SUFDL0IsQ0FBQ3NHLFFBQVFqUixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLCtEQUErREEsQ0FBV0EsR0FBRyxLQUFLO0lBQ3BKLElBQUlzTyxNQUFNclEsSUFBSSxLQUFLLFdBQVc7UUFDNUIsTUFBTThPLFdBQVdrQixZQUFZO1lBQzNCMUY7WUFDQXpHO1lBQ0FXLFVBQVU2TCxNQUFNek0sV0FBVztZQUMzQjJHO1FBQ0Y7UUFDQSxJQUFJdUUsWUFBWSxNQUFNO1lBQ3BCLE9BQU87UUFDVDtRQUNBLE9BQU9DLHVCQUF1QjtZQUM1QnRGO1lBQ0FjO1lBQ0EzRztZQUNBNko7WUFDQXpDLE1BQU1SLGVBQWVJLFNBQVM7WUFDOUJnQixhQUFhcEIsZUFBZW9CLFdBQVc7WUFDdkNySSxPQUFPdUw7UUFDVDtJQUNGO0lBQ0EsTUFBTUEsV0FBV2EsWUFBWTtRQUMzQnJGO1FBQ0ExRztRQUNBZ0gsV0FBV0osZUFBZUksU0FBUztRQUNuQzFCO1FBQ0EvRSxTQUFTa00sTUFBTWxNLE9BQU87UUFDdEJxTDtJQUNGO0lBQ0EsSUFBSVYsWUFBWSxNQUFNO1FBQ3BCLE9BQU87SUFDVDtJQUNBLE9BQU9DLHVCQUF1QjtRQUM1QnRGO1FBQ0FjO1FBQ0EzRztRQUNBNko7UUFDQXpDLE1BQU1SLGVBQWVJLFNBQVM7UUFDOUJnQixhQUFhcEIsZUFBZW9CLFdBQVc7UUFDdkNySSxPQUFPdUw7SUFDVDtBQUNGO0FBRUEsSUFBSXdCLDhCQUE4QixDQUFDLEVBQ2pDMUYsU0FBUyxFQUNUNEUsYUFBYSxFQUNiSyxXQUFXLEVBQ1hqRSxXQUFXLEVBQ1o7SUFDQyxNQUFNMkUsY0FBY2QsUUFBUTdFLFVBQVVjLE9BQU8sQ0FBQ21FLFlBQVksSUFBSWpGLFVBQVVhLFNBQVMsQ0FBQ29FLFlBQVk7SUFDOUYsSUFBSU4sc0JBQXNCTSxhQUFhTCxnQkFBZ0I7UUFDckQsT0FBT2UsY0FBY3pMLFNBQVNRLE9BQU9zRyxZQUFZckcsS0FBSztJQUN4RDtJQUNBLE9BQU9nTCxjQUFjM0UsWUFBWXJHLEtBQUssR0FBR1Q7QUFDM0M7QUFFQSxJQUFJMEwsZ0JBQWdCLENBQUMsRUFDbkJoQixhQUFhLEVBQ2IxRixNQUFNLEVBQ05aLFVBQVUsRUFDWDtJQUNDLE1BQU0vRSxVQUFVNkYsY0FBY0Y7SUFDOUIsQ0FBQzNGLFVBQVUvRSxLQUFxQyxHQUFHMkMsY0FBY0EsQ0FBV0EsR0FBRyxLQUFLO0lBQ3BGLE1BQU04TixjQUFjMUwsUUFBUUUsV0FBVztJQUN2QyxNQUFNb00sU0FBU3ZILFVBQVUsQ0FBQzJHLFlBQVksQ0FBQy9ILElBQUksQ0FBQzRJLFNBQVMsQ0FBQ0QsTUFBTTtJQUM1RCxNQUFNRSxhQUFhTCw0QkFBNEI7UUFDN0MxRixXQUFXZCxPQUFPYyxTQUFTO1FBQzNCNEU7UUFDQUs7UUFDQWpFLGFBQWE5QixPQUFPOEIsV0FBVztJQUNqQztJQUNBLE9BQU8zRyxJQUFJd0wsUUFBUUU7QUFDckI7QUFFQSxNQUFNQyxxQ0FBcUMsQ0FBQ3RKLE1BQU11SixNQUFRQSxJQUFJQyxNQUFNLENBQUN4SixLQUFLN0QsS0FBSyxDQUFDLEdBQUdvTixJQUFJSCxTQUFTLENBQUNwSixLQUFLeUYsSUFBSSxDQUFDLEdBQUc7QUFDOUcsTUFBTWdFLG1DQUFtQyxDQUFDekosTUFBTXVKLE1BQVFBLElBQUlDLE1BQU0sQ0FBQ3hKLEtBQUtHLEdBQUcsQ0FBQyxHQUFHb0osSUFBSUgsU0FBUyxDQUFDcEosS0FBS3lGLElBQUksQ0FBQyxHQUFHO0FBQzFHLE1BQU1pRSw4QkFBOEIsQ0FBQzFKLE1BQU12QixRQUFRa0wsV0FBYWxMLE1BQU0sQ0FBQ3VCLEtBQUswRixjQUFjLENBQUMsR0FBR2lFLFNBQVNILE1BQU0sQ0FBQ3hKLEtBQUswRixjQUFjLENBQUMsR0FBR2lFLFNBQVNQLFNBQVMsQ0FBQ3BKLEtBQUs0RixhQUFhLENBQUMsR0FBRztBQUM5SyxNQUFNZ0UsVUFBVSxDQUFDLEVBQ2Y1SixJQUFJLEVBQ0o2SixjQUFjLEVBQ2RGLFFBQVEsRUFDVCxHQUFLekwsTUFBTThCLEtBQUs3QixJQUFJLEVBQUUwTCxlQUFlbkosU0FBUyxDQUFDVixLQUFLRyxHQUFHLENBQUMsR0FBR21KLG1DQUFtQ3RKLE1BQU0ySixXQUFXRCw0QkFBNEIxSixNQUFNNkosZUFBZW5KLFNBQVMsRUFBRWlKO0FBQzVLLE1BQU1HLFdBQVcsQ0FBQyxFQUNoQjlKLElBQUksRUFDSjZKLGNBQWMsRUFDZEYsUUFBUSxFQUNULEdBQUt6TCxNQUFNOEIsS0FBSzdCLElBQUksRUFBRTBMLGVBQWVuSixTQUFTLENBQUNWLEtBQUs3RCxLQUFLLENBQUMsR0FBR3NOLGlDQUFpQ3pKLE1BQU0ySixXQUFXRCw0QkFBNEIxSixNQUFNNkosZUFBZW5KLFNBQVMsRUFBRWlKO0FBQzVLLE1BQU1JLGNBQWMsQ0FBQyxFQUNuQi9KLElBQUksRUFDSmdLLFFBQVEsRUFDUkwsUUFBUSxFQUNULEdBQUt6TCxNQUFNOEIsS0FBSzdCLElBQUksRUFBRTZMLFNBQVNDLFVBQVUsQ0FBQ2pLLEtBQUs3RCxLQUFLLENBQUMsR0FBR21OLG1DQUFtQ3RKLE1BQU0ySixXQUFXRCw0QkFBNEIxSixNQUFNZ0ssU0FBU0MsVUFBVSxFQUFFTjtBQUVwSyxJQUFJTyxpQkFBaUIsQ0FBQyxFQUNwQjFILE1BQU0sRUFDTkwsU0FBUyxFQUNUUCxVQUFVLEVBQ1ZiLFNBQVMsRUFDVG1ILGFBQWEsRUFDZDtJQUNDLE1BQU1qRixvQkFBb0JoQiw2QkFBNkJsQixVQUFVVyxVQUFVLENBQUM5RSxFQUFFLEVBQUVnRjtJQUNoRixNQUFNdUksZ0JBQWdCaEksVUFBVTNCLElBQUk7SUFDcEMsTUFBTVIsT0FBT2UsVUFBVWYsSUFBSTtJQUMzQixJQUFJLENBQUNpRCxrQkFBa0JPLE1BQU0sRUFBRTtRQUM3QixPQUFPdUcsWUFBWTtZQUNqQi9KO1lBQ0FnSyxVQUFVakosVUFBVVAsSUFBSTtZQUN4Qm1KLFVBQVVRO1FBQ1o7SUFDRjtJQUNBLE1BQU0sRUFDSjdHLFNBQVMsRUFDVGdCLFdBQVcsRUFDWixHQUFHOUI7SUFDSixNQUFNNEgsZUFBZTlHLFVBQVVELEdBQUcsQ0FBQyxFQUFFO0lBQ3JDLElBQUkrRyxjQUFjO1FBQ2hCLE1BQU1DLFVBQVV6SSxVQUFVLENBQUN3SSxhQUFhO1FBQ3hDLElBQUluQyxzQkFBc0JtQyxjQUFjbEMsZ0JBQWdCO1lBQ3RELE9BQU80QixTQUFTO2dCQUNkOUo7Z0JBQ0E2SixnQkFBZ0JRLFFBQVE3SixJQUFJO2dCQUM1Qm1KLFVBQVVRO1lBQ1o7UUFDRjtRQUNBLE1BQU1HLG1CQUFtQmpULHFEQUFNQSxDQUFDZ1QsUUFBUTdKLElBQUksRUFBRThELFlBQVlyRyxLQUFLO1FBQy9ELE9BQU82TCxTQUFTO1lBQ2Q5SjtZQUNBNkosZ0JBQWdCUztZQUNoQlgsVUFBVVE7UUFDWjtJQUNGO0lBQ0EsTUFBTXpHLE9BQU9ULGlCQUFpQixDQUFDQSxrQkFBa0JPLE1BQU0sR0FBRyxFQUFFO0lBQzVELElBQUlFLEtBQUtoQyxVQUFVLENBQUM5RSxFQUFFLEtBQUt1RixVQUFVVCxVQUFVLENBQUM5RSxFQUFFLEVBQUU7UUFDbEQsT0FBT3VOLGNBQWNmLFNBQVMsQ0FBQ0QsTUFBTTtJQUN2QztJQUNBLElBQUlsQixzQkFBc0J2RSxLQUFLaEMsVUFBVSxDQUFDOUUsRUFBRSxFQUFFc0wsZ0JBQWdCO1FBQzVELE1BQU0xSCxPQUFPbkoscURBQU1BLENBQUNxTSxLQUFLbEQsSUFBSSxFQUFFeEMsT0FBT2tLLGNBQWM1RCxXQUFXLENBQUNyRyxLQUFLO1FBQ3JFLE9BQU8yTCxRQUFRO1lBQ2I1SjtZQUNBNkosZ0JBQWdCcko7WUFDaEJtSixVQUFVUTtRQUNaO0lBQ0Y7SUFDQSxPQUFPUCxRQUFRO1FBQ2I1SjtRQUNBNkosZ0JBQWdCbkcsS0FBS2xELElBQUk7UUFDekJtSixVQUFVUTtJQUNaO0FBQ0Y7QUFFQSxJQUFJN0QsNEJBQTRCLENBQUN2RixXQUFXOUM7SUFDMUMsTUFBTWEsUUFBUWlDLFVBQVVqQyxLQUFLO0lBQzdCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU9iO0lBQ1Q7SUFDQSxPQUFPTixJQUFJTSxPQUFPYSxNQUFNYyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsWUFBWTtBQUNsRDtBQUVBLE1BQU15Syx3Q0FBd0MsQ0FBQyxFQUM3Qy9ILE1BQU0sRUFDTkwsU0FBUyxFQUNUcEIsU0FBUyxFQUNUYSxVQUFVLEVBQ1ZzRyxhQUFhLEVBQ2Q7SUFDQyxNQUFNc0MsV0FBV3JJLFVBQVUzQixJQUFJLENBQUM0SSxTQUFTLENBQUNELE1BQU07SUFDaEQsTUFBTTFHLEtBQUtELE9BQU9DLEVBQUU7SUFDcEIsSUFBSSxDQUFDMUIsV0FBVztRQUNkLE9BQU95SjtJQUNUO0lBQ0EsSUFBSSxDQUFDL0gsSUFBSTtRQUNQLE9BQU8rSDtJQUNUO0lBQ0EsSUFBSS9ILEdBQUcvSixJQUFJLEtBQUssV0FBVztRQUN6QixPQUFPd1IsZUFBZTtZQUNwQjFIO1lBQ0FMO1lBQ0FQO1lBQ0FiO1lBQ0FtSDtRQUNGO0lBQ0Y7SUFDQSxPQUFPZ0IsY0FBYztRQUNuQjFHO1FBQ0FaO1FBQ0FzRztJQUNGO0FBQ0Y7QUFDQSxJQUFJdUMsbUNBQW1DM1AsQ0FBQUE7SUFDckMsTUFBTTRQLHNCQUFzQkgsc0NBQXNDelA7SUFDbEUsTUFBTWlHLFlBQVlqRyxLQUFLaUcsU0FBUztJQUNoQyxNQUFNdUosbUJBQW1CdkosWUFBWXVGLDBCQUEwQnZGLFdBQVcySix1QkFBdUJBO0lBQ2pHLE9BQU9KO0FBQ1Q7QUFFQSxJQUFJSyxpQkFBaUIsQ0FBQ3hFLFVBQVVuRjtJQUM5QixNQUFNbkIsT0FBTy9CLFNBQVNrRCxXQUFXbUYsU0FBU3ZHLE1BQU0sQ0FBQ3VCLE9BQU87SUFDeEQsTUFBTXJCLGVBQWU5QixPQUFPNkI7SUFDNUIsTUFBTWYsUUFBUTNILHNEQUFPQSxDQUFDO1FBQ3BCNkgsS0FBS2dDLFVBQVV0RCxDQUFDO1FBQ2hCeUIsUUFBUTZCLFVBQVV0RCxDQUFDLEdBQUd5SSxTQUFTckgsS0FBSyxDQUFDUSxNQUFNO1FBQzNDRixNQUFNNEIsVUFBVXZELENBQUM7UUFDakJ5QixPQUFPOEIsVUFBVXZELENBQUMsR0FBRzBJLFNBQVNySCxLQUFLLENBQUNPLEtBQUs7SUFDM0M7SUFDQSxNQUFNdUwsVUFBVTtRQUNkOUw7UUFDQWMsUUFBUTtZQUNOdUIsU0FBU2dGLFNBQVN2RyxNQUFNLENBQUN1QixPQUFPO1lBQ2hDbEMsS0FBS2tILFNBQVN2RyxNQUFNLENBQUNYLEdBQUc7WUFDeEJvQyxTQUFTTDtZQUNUbkIsTUFBTTtnQkFDSjNILE9BQU8ySDtnQkFDUEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPOEs7QUFDVDtBQUVBLFNBQVNDLGdCQUFnQkMsR0FBRyxFQUFFbEosVUFBVTtJQUN0QyxPQUFPa0osSUFBSXJSLEdBQUcsQ0FBQ21ELENBQUFBLEtBQU1nRixVQUFVLENBQUNoRixHQUFHO0FBQ3JDO0FBQ0EsU0FBU21PLGNBQWNuTyxFQUFFLEVBQUVzSyxNQUFNO0lBQy9CLElBQUssSUFBSThELElBQUksR0FBR0EsSUFBSTlELE9BQU8xRCxNQUFNLEVBQUV3SCxJQUFLO1FBQ3RDLE1BQU1sTCxlQUFlb0gsTUFBTSxDQUFDOEQsRUFBRSxDQUFDNUcsT0FBTyxDQUFDeEgsR0FBRztRQUMxQyxJQUFJa0QsY0FBYztZQUNoQixPQUFPQTtRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxJQUFJbUwsd0JBQXdCLENBQUMsRUFDM0J6SSxNQUFNLEVBQ04yRCxRQUFRLEVBQ1I3SixXQUFXLEVBQ1hzRixVQUFVLEVBQ1ZzSixlQUFlLEVBQ2hCO0lBQ0MsTUFBTUMsbUJBQW1CUixlQUFleEUsVUFBVXhJLElBQUl3SSxTQUFTdkcsTUFBTSxDQUFDeUIsT0FBTyxFQUFFNko7SUFDL0UsTUFBTUUsb0JBQW9COU8sWUFBWXdDLEtBQUssR0FBR2dDLGdCQUFnQnhFLGFBQWFxQixJQUFJckIsWUFBWXdDLEtBQUssQ0FBQ2MsTUFBTSxDQUFDeUIsT0FBTyxFQUFFNkosb0JBQW9CNU87SUFDckksTUFBTW9ILE9BQU9sQixPQUFPYyxTQUFTO0lBQzdCLE1BQU0rSCxxQkFBcUJyRSxzQkFBc0I7UUFDL0NDLGVBQWU0RCxnQkFBZ0JuSCxLQUFLTCxHQUFHLEVBQUV6QjtRQUN6Q3RGO1FBQ0FnSSxhQUFhOUIsT0FBTzhCLFdBQVc7UUFDL0I2QixVQUFVZ0YsaUJBQWlCck0sS0FBSztRQUNoQzRFO1FBQ0FrRCxvQkFBb0I7SUFDdEI7SUFDQSxNQUFNMEUsc0JBQXNCdEUsc0JBQXNCO1FBQ2hEQyxlQUFlNEQsZ0JBQWdCbkgsS0FBS0wsR0FBRyxFQUFFekI7UUFDekN0RixhQUFhOE87UUFDYjlHLGFBQWE5QixPQUFPOEIsV0FBVztRQUMvQjZCLFVBQVVBLFNBQVNySCxLQUFLO1FBQ3hCNEU7UUFDQWtELG9CQUFvQjtJQUN0QjtJQUNBLE1BQU16QyxZQUFZLENBQUM7SUFDbkIsTUFBTUMsVUFBVSxDQUFDO0lBQ2pCLE1BQU04QyxTQUFTO1FBQUN4RDtRQUFNMkg7UUFBb0JDO0tBQW9CO0lBQzlENUgsS0FBS0wsR0FBRyxDQUFDbkosT0FBTyxDQUFDMEMsQ0FBQUE7UUFDZixNQUFNa0QsZUFBZWlMLGNBQWNuTyxJQUFJc0s7UUFDdkMsSUFBSXBILGNBQWM7WUFDaEJzRSxPQUFPLENBQUN4SCxHQUFHLEdBQUdrRDtZQUNkO1FBQ0Y7UUFDQXFFLFNBQVMsQ0FBQ3ZILEdBQUcsR0FBRztJQUNsQjtJQUNBLE1BQU0yTyxZQUFZO1FBQ2hCLEdBQUcvSSxNQUFNO1FBQ1RjLFdBQVc7WUFDVEQsS0FBS0ssS0FBS0wsR0FBRztZQUNiYztZQUNBQztRQUNGO0lBQ0Y7SUFDQSxPQUFPbUg7QUFDVDtBQUVBLElBQUlDLDJCQUEyQixDQUFDckYsVUFBVWxJLFFBQVVOLElBQUl3SSxTQUFTdkcsTUFBTSxDQUFDQyxJQUFJLENBQUNDLFlBQVksRUFBRTdCO0FBRTNGLElBQUl3TixtQ0FBbUMsQ0FBQyxFQUN0Q0MsbUJBQW1CLEVBQ25CdkosU0FBUyxFQUNUZ0UsUUFBUSxFQUNUO0lBQ0MsTUFBTXdGLDBCQUEwQkgseUJBQXlCckYsVUFBVXVGO0lBQ25FLE1BQU1yVSxTQUFTeUcsU0FBUzZOLHlCQUF5QnhKLFVBQVUzQixJQUFJLENBQUM0SSxTQUFTLENBQUNELE1BQU07SUFDaEYsT0FBT3hMLElBQUl3RSxVQUFVeUosTUFBTSxDQUFDeEMsU0FBUyxDQUFDRCxNQUFNLEVBQUU5UjtBQUNoRDtBQUVBLElBQUl3VSxnQ0FBZ0MsQ0FBQyxFQUNuQzFKLFNBQVMsRUFDVDdGLFdBQVcsRUFDWHdQLHNCQUFzQixFQUN0QjNGLFFBQVEsRUFDUkcseUJBQXlCLEVBQ3pCeUYsaUJBQWlCLEtBQUssRUFDdkI7SUFDQyxNQUFNQyxlQUFlbE8sU0FBU2dPLHdCQUF3QjNKLFVBQVUzQixJQUFJLENBQUM0SSxTQUFTLENBQUNELE1BQU07SUFDckYsTUFBTThDLFVBQVUxTSxpQkFBaUI0QyxVQUFVM0IsSUFBSSxDQUFDNEksU0FBUyxFQUFFNEM7SUFDM0QsTUFBTWxSLE9BQU87UUFDWDJELFFBQVF3TjtRQUNSM1A7UUFDQWdLO1FBQ0FIO0lBQ0Y7SUFDQSxPQUFPNEYsaUJBQWlCckYsdUJBQXVCNUwsUUFBUTJMLGlCQUFpQjNMO0FBQzFFO0FBRUEsSUFBSW9SLGtCQUFrQixDQUFDLEVBQ3JCbEosZUFBZSxFQUNmYixTQUFTLEVBQ1Q3RixXQUFXLEVBQ1hzRixVQUFVLEVBQ1ZzQixjQUFjLEVBQ2RpRCxRQUFRLEVBQ1JnRywyQkFBMkIsRUFDM0JDLHVCQUF1QixFQUN2QmxFLGFBQWEsRUFDZDtJQUNDLElBQUksQ0FBQzVMLFlBQVkrUCxTQUFTLEVBQUU7UUFDMUIsT0FBTztJQUNUO0lBQ0EsTUFBTXBKLG9CQUFvQmhCLDZCQUE2QjNGLFlBQVlvRixVQUFVLENBQUM5RSxFQUFFLEVBQUVnRjtJQUNsRixNQUFNckYsZUFBZXlILFNBQVM3QixXQUFXN0Y7SUFDekMsTUFBTWtHLFNBQVNPLGtCQUFrQjtRQUMvQkM7UUFDQWI7UUFDQTdGO1FBQ0EyRztRQUNBQztJQUNGLE1BQU00RixnQkFBZ0I7UUFDcEI5RjtRQUNBekc7UUFDQTRGO1FBQ0FQO1FBQ0F0RjtRQUNBMkc7UUFDQUM7UUFDQWlEO1FBQ0ErQjtJQUNGO0lBQ0EsSUFBSSxDQUFDMUYsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE1BQU1rSixzQkFBc0JqQixpQ0FBaUM7UUFDM0RqSTtRQUNBTDtRQUNBcEIsV0FBV3pFO1FBQ1hzRjtRQUNBc0c7SUFDRjtJQUNBLE1BQU1vRSx5QkFBeUJULDhCQUE4QjtRQUMzRDFKO1FBQ0E3RjtRQUNBd1Asd0JBQXdCSjtRQUN4QnZGLFVBQVVBLFNBQVNySCxLQUFLO1FBQ3hCd0gsMkJBQTJCO1FBQzNCeUYsZ0JBQWdCO0lBQ2xCO0lBQ0EsSUFBSU8sd0JBQXdCO1FBQzFCLE1BQU1DLGtCQUFrQmQsaUNBQWlDO1lBQ3ZEQztZQUNBdko7WUFDQWdFO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xvRztZQUNBL0o7WUFDQWdLLG1CQUFtQjtRQUNyQjtJQUNGO0lBQ0EsTUFBTW5PLFdBQVdQLFNBQVM0TixxQkFBcUJTO0lBQy9DLE1BQU1NLFdBQVd4QixzQkFBc0I7UUFDckN6STtRQUNBMkQ7UUFDQTdKO1FBQ0FzRjtRQUNBc0osaUJBQWlCN007SUFDbkI7SUFDQSxPQUFPO1FBQ0xrTyxpQkFBaUJIO1FBQ2pCNUosUUFBUWlLO1FBQ1JELG1CQUFtQm5PO0lBQ3JCO0FBQ0Y7QUFFQSxNQUFNcU8saUJBQWlCM0wsQ0FBQUE7SUFDckIsTUFBTTRMLE9BQU81TCxVQUFVaEMsT0FBTyxDQUFDOEIsTUFBTTtJQUNyQyxDQUFDOEwsT0FBTzdVLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNENBQTRDQSxDQUFXQSxHQUFHLEtBQUs7SUFDaEksT0FBT2tTO0FBQ1Q7QUFDQSxJQUFJQyw0QkFBNEIsQ0FBQyxFQUMvQjVKLGVBQWUsRUFDZjBJLG1CQUFtQixFQUNuQnRQLE1BQU0sRUFDTm1GLFVBQVUsRUFDVjRFLFFBQVEsRUFDVDtJQUNDLE1BQU10RixTQUFTekUsT0FBTzJDLE9BQU8sQ0FBQzhCLE1BQU07SUFDcEMsSUFBSSxDQUFDQSxRQUFRO1FBQ1gsT0FBTztJQUNUO0lBQ0EsTUFBTWIsT0FBTzVELE9BQU80RCxJQUFJO0lBQ3hCLE1BQU02TSx5QkFBeUJ0SSxTQUFTMUQsTUFBTSxDQUFDYixLQUFLN0QsS0FBSyxDQUFDLEVBQUUwRSxNQUFNLENBQUNiLEtBQUtHLEdBQUcsQ0FBQztJQUM1RSxNQUFNMk0sYUFBYWpMLGdCQUFnQk4sWUFBWVcsTUFBTSxDQUFDbkIsQ0FBQUEsWUFBYUEsY0FBYzNFLFFBQVE4RixNQUFNLENBQUNuQixDQUFBQSxZQUFhQSxVQUFVc0wsU0FBUyxFQUFFbkssTUFBTSxDQUFDbkIsQ0FBQUEsWUFBYW9ILFFBQVFwSCxVQUFVaEMsT0FBTyxDQUFDOEIsTUFBTSxHQUFHcUIsTUFBTSxDQUFDbkIsQ0FBQUEsWUFBYTJELCtCQUErQnlCLFNBQVNySCxLQUFLLEVBQUU0TixlQUFlM0wsYUFBYW1CLE1BQU0sQ0FBQ25CLENBQUFBO1FBQzdSLE1BQU1nTSxpQkFBaUJMLGVBQWUzTDtRQUN0QyxJQUFJaUMsaUJBQWlCO1lBQ25CLE9BQU9uQyxNQUFNLENBQUNiLEtBQUsyRixZQUFZLENBQUMsR0FBR29ILGNBQWMsQ0FBQy9NLEtBQUsyRixZQUFZLENBQUM7UUFDdEU7UUFDQSxPQUFPb0gsY0FBYyxDQUFDL00sS0FBSzBGLGNBQWMsQ0FBQyxHQUFHN0UsTUFBTSxDQUFDYixLQUFLMEYsY0FBYyxDQUFDO0lBQzFFLEdBQUd4RCxNQUFNLENBQUNuQixDQUFBQTtRQUNSLE1BQU1nTSxpQkFBaUJMLGVBQWUzTDtRQUN0QyxNQUFNaU0sOEJBQThCekksU0FBU3dJLGNBQWMsQ0FBQy9NLEtBQUs3RCxLQUFLLENBQUMsRUFBRTRRLGNBQWMsQ0FBQy9NLEtBQUtHLEdBQUcsQ0FBQztRQUNqRyxPQUFPME0sdUJBQXVCRSxjQUFjLENBQUMvTSxLQUFLN0QsS0FBSyxDQUFDLEtBQUswUSx1QkFBdUJFLGNBQWMsQ0FBQy9NLEtBQUtHLEdBQUcsQ0FBQyxLQUFLNk0sNEJBQTRCbk0sTUFBTSxDQUFDYixLQUFLN0QsS0FBSyxDQUFDLEtBQUs2USw0QkFBNEJuTSxNQUFNLENBQUNiLEtBQUtHLEdBQUcsQ0FBQztJQUNsTixHQUFHaUMsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ1YsTUFBTTJLLFFBQVFQLGVBQWVySyxFQUFFLENBQUNyQyxLQUFLMEYsY0FBYyxDQUFDO1FBQ3BELE1BQU13SCxTQUFTUixlQUFlcEssRUFBRSxDQUFDdEMsS0FBSzBGLGNBQWMsQ0FBQztRQUNyRCxJQUFJMUMsaUJBQWlCO1lBQ25CLE9BQU9pSyxRQUFRQztRQUNqQjtRQUNBLE9BQU9BLFNBQVNEO0lBQ2xCLEdBQUcvSyxNQUFNLENBQUMsQ0FBQ25CLFdBQVc5RSxPQUFPa1IsUUFBVVQsZUFBZTNMLFVBQVUsQ0FBQ2YsS0FBSzBGLGNBQWMsQ0FBQyxLQUFLZ0gsZUFBZVMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDbk4sS0FBSzBGLGNBQWMsQ0FBQztJQUN2SSxJQUFJLENBQUNvSCxXQUFXdEosTUFBTSxFQUFFO1FBQ3RCLE9BQU87SUFDVDtJQUNBLElBQUlzSixXQUFXdEosTUFBTSxLQUFLLEdBQUc7UUFDM0IsT0FBT3NKLFVBQVUsQ0FBQyxFQUFFO0lBQ3RCO0lBQ0EsTUFBTU0sV0FBV04sV0FBVzVLLE1BQU0sQ0FBQ25CLENBQUFBO1FBQ2pDLE1BQU1zTSxvQkFBb0I5SSxTQUFTbUksZUFBZTNMLFVBQVUsQ0FBQ2YsS0FBSzdELEtBQUssQ0FBQyxFQUFFdVEsZUFBZTNMLFVBQVUsQ0FBQ2YsS0FBS0csR0FBRyxDQUFDO1FBQzdHLE9BQU9rTixrQkFBa0IzQixtQkFBbUIsQ0FBQzFMLEtBQUs3QixJQUFJLENBQUM7SUFDekQ7SUFDQSxJQUFJaVAsU0FBUzVKLE1BQU0sS0FBSyxHQUFHO1FBQ3pCLE9BQU80SixRQUFRLENBQUMsRUFBRTtJQUNwQjtJQUNBLElBQUlBLFNBQVM1SixNQUFNLEdBQUcsR0FBRztRQUN2QixPQUFPNEosU0FBU2hMLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNb0ssZUFBZXJLLEVBQUUsQ0FBQ3JDLEtBQUs3RCxLQUFLLENBQUMsR0FBR3VRLGVBQWVwSyxFQUFFLENBQUN0QyxLQUFLN0QsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ2xHO0lBQ0EsT0FBTzJRLFdBQVcxSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDekIsTUFBTTJLLFFBQVF6TyxVQUFVa04scUJBQXFCak0sV0FBV2lOLGVBQWVySztRQUN2RSxNQUFNNkssU0FBUzFPLFVBQVVrTixxQkFBcUJqTSxXQUFXaU4sZUFBZXBLO1FBQ3hFLElBQUkySyxVQUFVQyxRQUFRO1lBQ3BCLE9BQU9ELFFBQVFDO1FBQ2pCO1FBQ0EsT0FBT1IsZUFBZXJLLEVBQUUsQ0FBQ3JDLEtBQUs3RCxLQUFLLENBQUMsR0FBR3VRLGVBQWVwSyxFQUFFLENBQUN0QyxLQUFLN0QsS0FBSyxDQUFDO0lBQ3RFLEVBQUUsQ0FBQyxFQUFFO0FBQ1A7QUFFQSxNQUFNbVIsZ0NBQWdDLENBQUNuTCxXQUFXK0Y7SUFDaEQsTUFBTXNDLFdBQVdySSxVQUFVM0IsSUFBSSxDQUFDNEksU0FBUyxDQUFDRCxNQUFNO0lBQ2hELE9BQU9sQixzQkFBc0I5RixVQUFVVCxVQUFVLENBQUM5RSxFQUFFLEVBQUVzTCxpQkFBaUJwSyxTQUFTME0sVUFBVXRDLGNBQWM1RCxXQUFXLENBQUNyRyxLQUFLLElBQUl1TTtBQUMvSDtBQUNBLE1BQU0rQywwQkFBMEIsQ0FBQ3BMLFdBQVcrRjtJQUMxQyxNQUFNc0MsV0FBV3JJLFVBQVUzQixJQUFJLENBQUM0SSxTQUFTO0lBQ3pDLE9BQU9uQixzQkFBc0I5RixVQUFVVCxVQUFVLENBQUM5RSxFQUFFLEVBQUVzTCxpQkFBaUIzSSxpQkFBaUJpTCxVQUFVeE0sT0FBT2tLLGNBQWM1RCxXQUFXLENBQUNyRyxLQUFLLEtBQUt1TTtBQUMvSTtBQUVBLElBQUlnRCxzQkFBc0IsQ0FBQyxFQUN6QjlCLG1CQUFtQixFQUNuQnZGLFFBQVEsRUFDUjdKLFdBQVcsRUFDWDJHLGlCQUFpQixFQUNqQmlGLGFBQWEsRUFDZDtJQUNDLE1BQU11RixTQUFTeEssa0JBQWtCZixNQUFNLENBQUNDLENBQUFBLFlBQWFzRSxpQkFBaUI7WUFDcEVoSSxRQUFROE8sd0JBQXdCcEwsV0FBVytGO1lBQzNDNUw7WUFDQTZKLFVBQVVBLFNBQVNySCxLQUFLO1lBQ3hCd0gsMkJBQTJCO1FBQzdCLElBQUlsRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDWCxNQUFNb0wsY0FBY3JQLFNBQVNxTixxQkFBcUJwRiwwQkFBMEJoSyxhQUFhZ1IsOEJBQThCakwsR0FBRzZGO1FBQzFILE1BQU15RixjQUFjdFAsU0FBU3FOLHFCQUFxQnBGLDBCQUEwQmhLLGFBQWFnUiw4QkFBOEJoTCxHQUFHNEY7UUFDMUgsSUFBSXdGLGNBQWNDLGFBQWE7WUFDN0IsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxJQUFJQSxjQUFjRCxhQUFhO1lBQzdCLE9BQU87UUFDVDtRQUNBLE9BQU9yTCxFQUFFWCxVQUFVLENBQUN6RixLQUFLLEdBQUdxRyxFQUFFWixVQUFVLENBQUN6RixLQUFLO0lBQ2hEO0lBQ0EsT0FBT3dSLE1BQU0sQ0FBQyxFQUFFLElBQUk7QUFDdEI7QUFFQSxJQUFJRyxpQkFBaUJsVyx1REFBVUEsQ0FBQyxTQUFTa1csZUFBZTVOLElBQUksRUFBRXFKLFVBQVU7SUFDdEUsTUFBTXZKLGVBQWV1SixVQUFVLENBQUNySixLQUFLN0IsSUFBSSxDQUFDO0lBQzFDLE9BQU87UUFDTGpHLE9BQU80SDtRQUNQN0IsT0FBT0MsTUFBTThCLEtBQUs3QixJQUFJLEVBQUUyQjtJQUMxQjtBQUNGO0FBRUEsTUFBTStOLGtDQUFrQyxDQUFDOU0sV0FBVytNLGlCQUFpQmxNO0lBQ25FLE1BQU01QixPQUFPZSxVQUFVZixJQUFJO0lBQzNCLElBQUllLFVBQVVXLFVBQVUsQ0FBQ3FNLElBQUksS0FBSyxXQUFXO1FBQzNDLE9BQU83UCxNQUFNOEIsS0FBSzdCLElBQUksRUFBRTJQLGVBQWUsQ0FBQzlOLEtBQUs3QixJQUFJLENBQUM7SUFDcEQ7SUFDQSxNQUFNNlAsaUJBQWlCak4sVUFBVWhDLE9BQU8sQ0FBQ3lCLElBQUksQ0FBQ3lKLFVBQVUsQ0FBQ2pLLEtBQUt5RixJQUFJLENBQUM7SUFDbkUsTUFBTXdJLGtCQUFrQmhNLDZCQUE2QmxCLFVBQVVXLFVBQVUsQ0FBQzlFLEVBQUUsRUFBRWdGO0lBQzlFLE1BQU1zTSxZQUFZRCxnQkFBZ0J6TSxNQUFNLENBQUMsQ0FBQzJNLEtBQUtDLFlBQWNELE1BQU1DLFVBQVV4QyxNQUFNLENBQUNsTCxTQUFTLENBQUNWLEtBQUt5RixJQUFJLENBQUMsRUFBRTtJQUMxRyxNQUFNNEksZ0JBQWdCSCxZQUFZSixlQUFlLENBQUM5TixLQUFLN0IsSUFBSSxDQUFDO0lBQzVELE1BQU1tUSxnQkFBZ0JELGdCQUFnQkw7SUFDdEMsSUFBSU0saUJBQWlCLEdBQUc7UUFDdEIsT0FBTztJQUNUO0lBQ0EsT0FBT3BRLE1BQU04QixLQUFLN0IsSUFBSSxFQUFFbVE7QUFDMUI7QUFDQSxNQUFNQyxnQkFBZ0IsQ0FBQ3pQLE9BQU9HLE1BQVM7UUFDckMsR0FBR0gsS0FBSztRQUNSYyxRQUFRO1lBQ04sR0FBR2QsTUFBTWMsTUFBTTtZQUNmWDtRQUNGO0lBQ0Y7QUFDQSxNQUFNdVAsaUJBQWlCLENBQUN6TixXQUFXb0IsV0FBV1A7SUFDNUMsTUFBTTlDLFFBQVFpQyxVQUFVakMsS0FBSztJQUM3QixDQUFDLENBQUNrRixTQUFTN0IsV0FBV3BCLGFBQWFqSixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG1EQUFtREEsQ0FBV0EsR0FBRyxLQUFLO0lBQ2xLLENBQUMsQ0FBQ3NHLFVBQVVoQyxPQUFPLENBQUNrQixlQUFlLEdBQUduSSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNFQUFzRUEsQ0FBV0EsR0FBRyxLQUFLO0lBQ3hMLE1BQU1xVCxrQkFBa0JGLGVBQWU3TSxVQUFVZixJQUFJLEVBQUVtQyxVQUFVa0gsVUFBVSxFQUFFcEwsS0FBSztJQUNsRixNQUFNd1EsaUJBQWlCWixnQ0FBZ0M5TSxXQUFXK00saUJBQWlCbE07SUFDbkYsTUFBTThNLFFBQVE7UUFDWlo7UUFDQTVOLGFBQWF1TztRQUNiRSxtQkFBbUI1TixVQUFVakMsS0FBSyxHQUFHaUMsVUFBVWpDLEtBQUssQ0FBQ2MsTUFBTSxDQUFDWCxHQUFHLEdBQUc7SUFDcEU7SUFDQSxJQUFJLENBQUNILE9BQU87UUFDVixNQUFNQyxVQUFVd0IsV0FBVztZQUN6QkMsTUFBTU8sVUFBVWhDLE9BQU8sQ0FBQ3lCLElBQUk7WUFDNUJQLGlCQUFpQnlPO1lBQ2pCMU8sTUFBTWUsVUFBVWYsSUFBSTtZQUNwQmxCLE9BQU9pQyxVQUFVakMsS0FBSztRQUN4QjtRQUNBLE9BQU87WUFDTCxHQUFHaUMsU0FBUztZQUNaaEM7UUFDRjtJQUNGO0lBQ0EsTUFBTTZQLFlBQVlILGlCQUFpQjlRLElBQUltQixNQUFNYyxNQUFNLENBQUNYLEdBQUcsRUFBRXdQLGtCQUFrQjNQLE1BQU1jLE1BQU0sQ0FBQ1gsR0FBRztJQUMzRixNQUFNNFAsV0FBV04sY0FBY3pQLE9BQU84UDtJQUN0QyxNQUFNN1AsVUFBVXdCLFdBQVc7UUFDekJDLE1BQU1PLFVBQVVoQyxPQUFPLENBQUN5QixJQUFJO1FBQzVCUCxpQkFBaUJ5TztRQUNqQjFPLE1BQU1lLFVBQVVmLElBQUk7UUFDcEJsQixPQUFPK1A7SUFDVDtJQUNBLE9BQU87UUFDTCxHQUFHOU4sU0FBUztRQUNaaEM7UUFDQUQsT0FBTytQO0lBQ1Q7QUFDRjtBQUNBLE1BQU1DLG9CQUFvQi9OLENBQUFBO0lBQ3hCLE1BQU0yTixRQUFRM04sVUFBVWhDLE9BQU8sQ0FBQ2tCLGVBQWU7SUFDL0MsQ0FBQ3lPLFFBQVE1VyxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGdFQUFnRUEsQ0FBV0EsR0FBRyxLQUFLO0lBQ3JKLE1BQU1xRSxRQUFRaUMsVUFBVWpDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsTUFBTUMsVUFBVXdCLFdBQVc7WUFDekJDLE1BQU1PLFVBQVVoQyxPQUFPLENBQUN5QixJQUFJO1lBQzVCUixNQUFNZSxVQUFVZixJQUFJO1lBQ3BCbEIsT0FBTztZQUNQbUIsaUJBQWlCO1FBQ25CO1FBQ0EsT0FBTztZQUNMLEdBQUdjLFNBQVM7WUFDWmhDO1FBQ0Y7SUFDRjtJQUNBLE1BQU1nUSxlQUFlTCxNQUFNQyxpQkFBaUI7SUFDNUMsQ0FBQ0ksZUFBZWpYLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMEZBQTBGQSxDQUFXQSxHQUFHLEtBQUs7SUFDdEwsTUFBTW9VLFdBQVdOLGNBQWN6UCxPQUFPaVE7SUFDdEMsTUFBTWhRLFVBQVV3QixXQUFXO1FBQ3pCQyxNQUFNTyxVQUFVaEMsT0FBTyxDQUFDeUIsSUFBSTtRQUM1QlIsTUFBTWUsVUFBVWYsSUFBSTtRQUNwQmxCLE9BQU8rUDtRQUNQNU8saUJBQWlCO0lBQ25CO0lBQ0EsT0FBTztRQUNMLEdBQUdjLFNBQVM7UUFDWmhDO1FBQ0FELE9BQU8rUDtJQUNUO0FBQ0Y7QUFFQSxJQUFJRyxxQkFBcUIsQ0FBQyxFQUN4QjdDLDJCQUEyQixFQUMzQnRDLGNBQWMsRUFDZDVHLGlCQUFpQixFQUNqQmQsU0FBUyxFQUNUUCxVQUFVLEVBQ1Z0RixXQUFXLEVBQ1g2SixRQUFRLEVBQ1IrQixhQUFhLEVBQ2Q7SUFDQyxJQUFJLENBQUMyQixnQkFBZ0I7UUFDbkIsSUFBSTVHLGtCQUFrQk8sTUFBTSxFQUFFO1lBQzVCLE9BQU87UUFDVDtRQUNBLE1BQU15TCxXQUFXO1lBQ2YzTCxXQUFXWTtZQUNYSSxhQUFhTDtZQUNieEIsSUFBSTtnQkFDRi9KLE1BQU07Z0JBQ040RCxhQUFhO29CQUNYRSxhQUFhRixZQUFZb0YsVUFBVSxDQUFDOUUsRUFBRTtvQkFDdENYLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsTUFBTWlULDhCQUE4QnpFLGlDQUFpQztZQUNuRWpJLFFBQVF5TTtZQUNSOU07WUFDQXBCLFdBQVd6RTtZQUNYc0Y7WUFDQXNHO1FBQ0Y7UUFDQSxNQUFNakksa0JBQWtCK0QsU0FBUzdCLFdBQVc3RixlQUFlQSxjQUFja1MsZUFBZWxTLGFBQWE2RixXQUFXUDtRQUNoSCxNQUFNMEsseUJBQXlCVCw4QkFBOEI7WUFDM0QxSjtZQUNBN0YsYUFBYTJEO1lBQ2I2TCx3QkFBd0JvRDtZQUN4Qi9JLFVBQVVBLFNBQVNySCxLQUFLO1lBQ3hCd0gsMkJBQTJCO1lBQzNCeUYsZ0JBQWdCO1FBQ2xCO1FBQ0EsT0FBT08seUJBQXlCMkMsV0FBVztJQUM3QztJQUNBLE1BQU1FLHNCQUFzQmhILFFBQVFnRSwyQkFBMkIsQ0FBQzdQLFlBQVkwRCxJQUFJLENBQUM3QixJQUFJLENBQUMsSUFBSTBMLGVBQWVySixJQUFJLENBQUM0SSxTQUFTLENBQUNELE1BQU0sQ0FBQzdNLFlBQVkwRCxJQUFJLENBQUM3QixJQUFJLENBQUM7SUFDckosTUFBTTJGLGdCQUFnQixDQUFDO1FBQ3JCLE1BQU1zTCxhQUFhdkYsZUFBZW5JLFVBQVUsQ0FBQ3pGLEtBQUs7UUFDbEQsSUFBSTROLGVBQWVuSSxVQUFVLENBQUM5RSxFQUFFLEtBQUt1RixVQUFVVCxVQUFVLENBQUM5RSxFQUFFLEVBQUU7WUFDNUQsT0FBT3dTO1FBQ1Q7UUFDQSxJQUFJRCxxQkFBcUI7WUFDdkIsT0FBT0M7UUFDVDtRQUNBLE9BQU9BLGFBQWE7SUFDdEI7SUFDQSxNQUFNOUssY0FBY3NKLGVBQWV0UixZQUFZMEQsSUFBSSxFQUFFbUMsVUFBVWtILFVBQVU7SUFDekUsT0FBTzVCLHVCQUF1QjtRQUM1QnRGO1FBQ0FjO1FBQ0EzRztRQUNBNko7UUFDQTdCO1FBQ0FaLE1BQU1RO1FBQ05qSSxPQUFPNkg7SUFDVDtBQUNGO0FBRUEsSUFBSXVMLGdCQUFnQixDQUFDLEVBQ25Cck0sZUFBZSxFQUNmbUosMkJBQTJCLEVBQzNCaEssU0FBUyxFQUNUbU4sTUFBTSxFQUNOMU4sVUFBVSxFQUNWTCxVQUFVLEVBQ1Y0RSxRQUFRLEVBQ1IrQixhQUFhLEVBQ2Q7SUFDQyxNQUFNNUwsY0FBY3NRLDBCQUEwQjtRQUM1QzVKO1FBQ0EwSSxxQkFBcUJTO1FBQ3JCL1AsUUFBUWtUO1FBQ1IvTjtRQUNBNEU7SUFDRjtJQUNBLElBQUksQ0FBQzdKLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsTUFBTTJHLG9CQUFvQmhCLDZCQUE2QjNGLFlBQVlvRixVQUFVLENBQUM5RSxFQUFFLEVBQUVnRjtJQUNsRixNQUFNaUksaUJBQWlCMkQsb0JBQW9CO1FBQ3pDOUIscUJBQXFCUztRQUNyQmhHO1FBQ0E3SjtRQUNBMkc7UUFDQWlGO0lBQ0Y7SUFDQSxNQUFNMUYsU0FBU3dNLG1CQUFtQjtRQUNoQzdDO1FBQ0E3UDtRQUNBNkY7UUFDQVA7UUFDQWlJO1FBQ0E1RztRQUNBa0Q7UUFDQStCO0lBQ0Y7SUFDQSxJQUFJLENBQUMxRixRQUFRO1FBQ1gsT0FBTztJQUNUO0lBQ0EsTUFBTWtKLHNCQUFzQmpCLGlDQUFpQztRQUMzRGpJO1FBQ0FMO1FBQ0FwQixXQUFXekU7UUFDWHNGO1FBQ0FzRztJQUNGO0lBQ0EsTUFBTXFFLGtCQUFrQmQsaUNBQWlDO1FBQ3ZEQztRQUNBdko7UUFDQWdFO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xvRztRQUNBL0o7UUFDQWdLLG1CQUFtQjtJQUNyQjtBQUNGO0FBRUEsSUFBSStDLG9CQUFvQi9NLENBQUFBO0lBQ3RCLE1BQU1DLEtBQUtELE9BQU9DLEVBQUU7SUFDcEIsSUFBSSxDQUFDQSxJQUFJO1FBQ1AsT0FBTztJQUNUO0lBQ0EsSUFBSUEsR0FBRy9KLElBQUksS0FBSyxXQUFXO1FBQ3pCLE9BQU8rSixHQUFHbkcsV0FBVyxDQUFDRSxXQUFXO0lBQ25DO0lBQ0EsT0FBT2lHLEdBQUc1RixPQUFPLENBQUNMLFdBQVc7QUFDL0I7QUFFQSxNQUFNZ1QscUJBQXFCLENBQUNoTixRQUFRakI7SUFDbEMsTUFBTTNFLEtBQUsyUyxrQkFBa0IvTTtJQUM3QixPQUFPNUYsS0FBSzJFLFVBQVUsQ0FBQzNFLEdBQUcsR0FBRztBQUMvQjtBQUNBLElBQUk2UyxrQkFBa0IsQ0FBQyxFQUNyQkMsS0FBSyxFQUNMaFgsSUFBSSxFQUNMO0lBQ0MsTUFBTWlYLGlCQUFpQkgsbUJBQW1CRSxNQUFNbE4sTUFBTSxFQUFFa04sTUFBTUUsVUFBVSxDQUFDck8sVUFBVTtJQUNuRixNQUFNc08sNEJBQTRCMUgsUUFBUXdIO0lBQzFDLE1BQU1HLE9BQU9KLE1BQU1FLFVBQVUsQ0FBQ3JPLFVBQVUsQ0FBQ21PLE1BQU1LLFFBQVEsQ0FBQ2hQLFNBQVMsQ0FBQ25FLEVBQUUsQ0FBQztJQUNyRSxNQUFNMFMsU0FBU0ssa0JBQWtCRztJQUNqQyxNQUFNdkssWUFBWStKLE9BQU90UCxJQUFJLENBQUN1RixTQUFTO0lBQ3ZDLE1BQU15SyxxQkFBcUJ6SyxjQUFjLGNBQWU3TSxDQUFBQSxTQUFTLGFBQWFBLFNBQVMsV0FBVSxLQUFNNk0sY0FBYyxnQkFBaUI3TSxDQUFBQSxTQUFTLGVBQWVBLFNBQVMsWUFBVztJQUNsTCxJQUFJc1gsc0JBQXNCLENBQUNILDJCQUEyQjtRQUNwRCxPQUFPO0lBQ1Q7SUFDQSxNQUFNN00sa0JBQWtCdEssU0FBUyxlQUFlQSxTQUFTO0lBQ3pELE1BQU15SixZQUFZdU4sTUFBTUUsVUFBVSxDQUFDaE8sVUFBVSxDQUFDOE4sTUFBTUssUUFBUSxDQUFDNU4sU0FBUyxDQUFDdkYsRUFBRSxDQUFDO0lBQzFFLE1BQU11UCw4QkFBOEJ1RCxNQUFNck8sT0FBTyxDQUFDYixJQUFJLENBQUN5UCxlQUFlO0lBQ3RFLE1BQU0sRUFDSnJPLFVBQVUsRUFDVkwsVUFBVSxFQUNYLEdBQUdtTyxNQUFNRSxVQUFVO0lBQ3BCLE9BQU9JLHFCQUFxQjlELGdCQUFnQjtRQUMxQ2xKO1FBQ0FtSjtRQUNBaEs7UUFDQTdGLGFBQWFnVDtRQUNiMU47UUFDQXVFLFVBQVV1SixNQUFNdkosUUFBUTtRQUN4QmlHLHlCQUF5QnNELE1BQU1yTyxPQUFPLENBQUN1SyxNQUFNLENBQUNzRSxTQUFTO1FBQ3ZEaE4sZ0JBQWdCd00sTUFBTWxOLE1BQU07UUFDNUIwRixlQUFld0gsTUFBTXhILGFBQWE7SUFDcEMsS0FBS21ILGNBQWM7UUFDakJyTTtRQUNBbUo7UUFDQWhLO1FBQ0FtTjtRQUNBMU47UUFDQUw7UUFDQTRFLFVBQVV1SixNQUFNdkosUUFBUTtRQUN4QitCLGVBQWV3SCxNQUFNeEgsYUFBYTtJQUNwQztBQUNGO0FBRUEsU0FBU2lJLGtCQUFrQlQsS0FBSztJQUM5QixPQUFPQSxNQUFNVSxLQUFLLEtBQUssY0FBY1YsTUFBTVUsS0FBSyxLQUFLO0FBQ3ZEO0FBRUEsU0FBU0Msa0JBQWtCdlIsS0FBSztJQUM5QixNQUFNNkYsbUJBQW1CSixTQUFTekYsTUFBTUUsR0FBRyxFQUFFRixNQUFNSyxNQUFNO0lBQ3pELE1BQU15RixxQkFBcUJMLFNBQVN6RixNQUFNTSxJQUFJLEVBQUVOLE1BQU1JLEtBQUs7SUFDM0QsT0FBTyxTQUFTb1IsSUFBSXJTLEtBQUs7UUFDdkIsT0FBTzBHLGlCQUFpQjFHLE1BQU1QLENBQUMsS0FBS2tILG1CQUFtQjNHLE1BQU1SLENBQUM7SUFDaEU7QUFDRjtBQUVBLFNBQVM4UyxjQUFjdEQsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLE9BQU9ELE1BQU03TixJQUFJLEdBQUc4TixPQUFPaE8sS0FBSyxJQUFJK04sTUFBTS9OLEtBQUssR0FBR2dPLE9BQU85TixJQUFJLElBQUk2TixNQUFNak8sR0FBRyxHQUFHa08sT0FBTy9OLE1BQU0sSUFBSThOLE1BQU05TixNQUFNLEdBQUcrTixPQUFPbE8sR0FBRztBQUN6SDtBQUNBLFNBQVN3UixnQkFBZ0IsRUFDdkJDLGFBQWEsRUFDYnRPLFNBQVMsRUFDVDJLLFVBQVUsRUFDWDtJQUNDLE1BQU00RCxjQUFjdk8sVUFBVTNCLElBQUksQ0FBQzRJLFNBQVMsQ0FBQ0QsTUFBTTtJQUNuRCxNQUFNc0UsU0FBU1gsV0FBV3JULEdBQUcsQ0FBQ2tYLENBQUFBO1FBQzVCLE1BQU0zUSxPQUFPMlEsVUFBVTNRLElBQUk7UUFDM0IsTUFBTXZCLFNBQVNQLE1BQU15UyxVQUFVM1EsSUFBSSxDQUFDN0IsSUFBSSxFQUFFc1MsY0FBY3RILE1BQU0sQ0FBQ25KLEtBQUs3QixJQUFJLENBQUMsRUFBRXdTLFVBQVVuUSxJQUFJLENBQUM0SSxTQUFTLENBQUNELE1BQU0sQ0FBQ25KLEtBQUt3RixhQUFhLENBQUM7UUFDOUgsT0FBTztZQUNMNUksSUFBSStULFVBQVVqUCxVQUFVLENBQUM5RSxFQUFFO1lBQzNCeUIsVUFBVUEsU0FBU3FTLGFBQWFqUztRQUNsQztJQUNGLEdBQUcyRCxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWpFLFFBQVEsR0FBR2dFLEVBQUVoRSxRQUFRO0lBQ3pDLE9BQU9vUCxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxDQUFDN1EsRUFBRSxHQUFHO0FBQ3BDO0FBQ0EsU0FBU2dVLGlCQUFpQixFQUN4QkgsYUFBYSxFQUNidE8sU0FBUyxFQUNUWixVQUFVLEVBQ1g7SUFDQyxNQUFNdUwsYUFBYWpMLGdCQUFnQk4sWUFBWVcsTUFBTSxDQUFDWSxDQUFBQTtRQUNwRCxJQUFJLENBQUNBLEtBQUt1SixTQUFTLEVBQUU7WUFDbkIsT0FBTztRQUNUO1FBQ0EsTUFBTXhMLFNBQVNpQyxLQUFLL0QsT0FBTyxDQUFDOEIsTUFBTTtRQUNsQyxJQUFJLENBQUNBLFFBQVE7WUFDWCxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMwUCxjQUFjRSxlQUFlNVAsU0FBUztZQUN6QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJd1Asa0JBQWtCeFAsUUFBUTRQLGNBQWN0SCxNQUFNLEdBQUc7WUFDbkQsT0FBTztRQUNUO1FBQ0EsTUFBTW5KLE9BQU84QyxLQUFLOUMsSUFBSTtRQUN0QixNQUFNNlEsY0FBY2hRLE9BQU9zSSxNQUFNLENBQUNuSixLQUFLd0YsYUFBYSxDQUFDO1FBQ3JELE1BQU1FLGlCQUFpQitLLGFBQWEsQ0FBQ3pRLEtBQUswRixjQUFjLENBQUM7UUFDekQsTUFBTUMsZUFBZThLLGFBQWEsQ0FBQ3pRLEtBQUsyRixZQUFZLENBQUM7UUFDckQsTUFBTWQsY0FBY04sU0FBUzFELE1BQU0sQ0FBQ2IsS0FBSzBGLGNBQWMsQ0FBQyxFQUFFN0UsTUFBTSxDQUFDYixLQUFLMkYsWUFBWSxDQUFDO1FBQ25GLE1BQU1tTCxtQkFBbUJqTSxZQUFZYTtRQUNyQyxNQUFNcUwsaUJBQWlCbE0sWUFBWWM7UUFDbkMsSUFBSSxDQUFDbUwsb0JBQW9CLENBQUNDLGdCQUFnQjtZQUN4QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJRCxrQkFBa0I7WUFDcEIsT0FBT3BMLGlCQUFpQm1MO1FBQzFCO1FBQ0EsT0FBT2xMLGVBQWVrTDtJQUN4QjtJQUNBLElBQUksQ0FBQy9ELFdBQVd0SixNQUFNLEVBQUU7UUFDdEIsT0FBTztJQUNUO0lBQ0EsSUFBSXNKLFdBQVd0SixNQUFNLEtBQUssR0FBRztRQUMzQixPQUFPc0osVUFBVSxDQUFDLEVBQUUsQ0FBQ3BMLFVBQVUsQ0FBQzlFLEVBQUU7SUFDcEM7SUFDQSxPQUFPNFQsZ0JBQWdCO1FBQ3JCQztRQUNBdE87UUFDQTJLO0lBQ0Y7QUFDRjtBQUVBLE1BQU1rRSx1QkFBdUIsQ0FBQ3JFLE1BQU0xTyxRQUFVOUcsc0RBQU9BLENBQUNvSSxpQkFBaUJvTixNQUFNMU87QUFFN0UsSUFBSXFOLHNCQUFzQixDQUFDdkssV0FBV2tRO0lBQ3BDLE1BQU1uUyxRQUFRaUMsVUFBVWpDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBT21TO0lBQ1Q7SUFDQSxPQUFPRCxxQkFBcUJDLE1BQU1uUyxNQUFNYyxNQUFNLENBQUNDLElBQUksQ0FBQzNILEtBQUs7QUFDM0Q7QUFFQSxTQUFTZ1osZUFBZSxFQUN0QjVOLFNBQVMsRUFDVDFHLEVBQUUsRUFDSDtJQUNDLE9BQU91TCxRQUFRN0UsVUFBVWMsT0FBTyxDQUFDeEgsR0FBRyxJQUFJMEcsVUFBVWEsU0FBUyxDQUFDdkgsR0FBRztBQUNqRTtBQUVBLFNBQVN1VSxRQUFRLEVBQ2ZoUCxTQUFTLEVBQ1RrSSxPQUFPLEVBQ1B2TixVQUFVLEVBQ1g7SUFDQyxJQUFJLENBQUN1TixTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDdk4sWUFBWTtRQUNmLE9BQU91TixRQUFRM0ksVUFBVSxDQUFDekYsS0FBSztJQUNqQztJQUNBLElBQUlvTyxRQUFRM0ksVUFBVSxDQUFDekYsS0FBSyxHQUFHa0csVUFBVVQsVUFBVSxDQUFDekYsS0FBSyxFQUFFO1FBQ3pELE9BQU9vTyxRQUFRM0ksVUFBVSxDQUFDekYsS0FBSyxHQUFHO0lBQ3BDO0lBQ0EsT0FBT29PLFFBQVEzSSxVQUFVLENBQUN6RixLQUFLO0FBQ2pDO0FBQ0EsSUFBSW1WLG1CQUFtQixDQUFDLEVBQ3RCQyxrQ0FBa0NDLFVBQVUsRUFDNUNuUCxTQUFTLEVBQ1Q3RixXQUFXLEVBQ1gyRyxpQkFBaUIsRUFDakJTLElBQUksRUFDSnlDLFFBQVEsRUFDUitCLGFBQWEsRUFDZDtJQUNDLE1BQU1sSSxPQUFPMUQsWUFBWTBELElBQUk7SUFDN0IsTUFBTXNFLGNBQWNzSixlQUFldFIsWUFBWTBELElBQUksRUFBRW1DLFVBQVVrSCxVQUFVO0lBQ3pFLE1BQU12SixlQUFld0UsWUFBWXBNLEtBQUs7SUFDdEMsTUFBTXFaLGNBQWNELFVBQVUsQ0FBQ3RSLEtBQUs3RCxLQUFLLENBQUM7SUFDMUMsTUFBTXFWLFlBQVlGLFVBQVUsQ0FBQ3RSLEtBQUtHLEdBQUcsQ0FBQztJQUN0QyxNQUFNeUgsa0JBQWtCakYsd0JBQXdCUixXQUFXYztJQUMzRCxNQUFNb0gsVUFBVXpDLGdCQUFnQkQsSUFBSSxDQUFDOEosQ0FBQUE7UUFDbkMsTUFBTTdVLEtBQUs2VSxNQUFNL1AsVUFBVSxDQUFDOUUsRUFBRTtRQUM5QixNQUFNaVUsY0FBY1ksTUFBTWpSLElBQUksQ0FBQzRJLFNBQVMsQ0FBQ0QsTUFBTSxDQUFDbkosS0FBSzdCLElBQUksQ0FBQztRQUMxRCxNQUFNdVQsMEJBQTBCekosc0JBQXNCckwsSUFBSXNMO1FBQzFELE1BQU1lLGNBQWNpSSxlQUFlO1lBQ2pDNU4sV0FBV0k7WUFDWDlHO1FBQ0Y7UUFDQSxJQUFJOFUseUJBQXlCO1lBQzNCLElBQUl6SSxhQUFhO2dCQUNmLE9BQU91SSxhQUFhWDtZQUN0QjtZQUNBLE9BQU9VLGNBQWNWLGNBQWMvUTtRQUNyQztRQUNBLElBQUltSixhQUFhO1lBQ2YsT0FBT3VJLGFBQWFYLGNBQWMvUTtRQUNwQztRQUNBLE9BQU95UixjQUFjVjtJQUN2QixNQUFNO0lBQ04sTUFBTXJKLFdBQVcySixRQUFRO1FBQ3ZCaFA7UUFDQWtJO1FBQ0F2TixZQUFZa0gsU0FBUzdCLFdBQVc3RjtJQUNsQztJQUNBLE9BQU9tTCx1QkFBdUI7UUFDNUJ0RjtRQUNBYztRQUNBM0c7UUFDQTZKO1FBQ0F6QztRQUNBWTtRQUNBckksT0FBT3VMO0lBQ1Q7QUFDRjtBQUVBLE1BQU1tSywwQkFBMEI7QUFDaEMsSUFBSUMsbUJBQW1CLENBQUMsRUFDdEJ6UCxTQUFTLEVBQ1RrUCxrQ0FBa0NDLFVBQVUsRUFDNUNwTyxjQUFjLEVBQ2Q1RyxXQUFXLEVBQ1gyRyxpQkFBaUIsRUFDakJpRixhQUFhLEVBQ2Q7SUFDQyxJQUFJLENBQUM1TCxZQUFZNkcsZ0JBQWdCLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsTUFBTW5ELE9BQU8xRCxZQUFZMEQsSUFBSTtJQUM3QixNQUFNc0UsY0FBY3NKLGVBQWV0UixZQUFZMEQsSUFBSSxFQUFFbUMsVUFBVWtILFVBQVU7SUFDekUsTUFBTXZKLGVBQWV3RSxZQUFZcE0sS0FBSztJQUN0QyxNQUFNcVosY0FBY0QsVUFBVSxDQUFDdFIsS0FBSzdELEtBQUssQ0FBQztJQUMxQyxNQUFNcVYsWUFBWUYsVUFBVSxDQUFDdFIsS0FBS0csR0FBRyxDQUFDO0lBQ3RDLE1BQU15SCxrQkFBa0JqRix3QkFBd0JSLFdBQVdjO0lBQzNELE1BQU1zRixjQUFjWCxnQkFBZ0JELElBQUksQ0FBQzhKLENBQUFBO1FBQ3ZDLE1BQU03VSxLQUFLNlUsTUFBTS9QLFVBQVUsQ0FBQzlFLEVBQUU7UUFDOUIsTUFBTWlWLFlBQVlKLE1BQU1qUixJQUFJLENBQUM0SSxTQUFTO1FBQ3RDLE1BQU0wSSxZQUFZRCxTQUFTLENBQUM3UixLQUFLeUYsSUFBSSxDQUFDO1FBQ3RDLE1BQU1zTSxZQUFZRCxZQUFZSDtRQUM5QixNQUFNRCwwQkFBMEJ6SixzQkFBc0JyTCxJQUFJc0w7UUFDMUQsTUFBTWUsY0FBY2lJLGVBQWU7WUFDakM1TixXQUFXSixlQUFlSSxTQUFTO1lBQ25DMUc7UUFDRjtRQUNBLElBQUk4VSx5QkFBeUI7WUFDM0IsSUFBSXpJLGFBQWE7Z0JBQ2YsT0FBT3VJLFlBQVlLLFNBQVMsQ0FBQzdSLEtBQUs3RCxLQUFLLENBQUMsR0FBRzRWLGFBQWFQLFlBQVlLLFNBQVMsQ0FBQzdSLEtBQUtHLEdBQUcsQ0FBQyxHQUFHNFI7WUFDNUY7WUFDQSxPQUFPUixjQUFjTSxTQUFTLENBQUM3UixLQUFLN0QsS0FBSyxDQUFDLEdBQUcyRCxlQUFlaVMsYUFBYVIsY0FBY00sU0FBUyxDQUFDN1IsS0FBS0csR0FBRyxDQUFDLEdBQUdMLGVBQWVpUztRQUM5SDtRQUNBLElBQUk5SSxhQUFhO1lBQ2YsT0FBT3VJLFlBQVlLLFNBQVMsQ0FBQzdSLEtBQUs3RCxLQUFLLENBQUMsR0FBRzJELGVBQWVpUyxhQUFhUCxZQUFZSyxTQUFTLENBQUM3UixLQUFLRyxHQUFHLENBQUMsR0FBR0wsZUFBZWlTO1FBQzFIO1FBQ0EsT0FBT1IsY0FBY00sU0FBUyxDQUFDN1IsS0FBSzdELEtBQUssQ0FBQyxHQUFHNFYsYUFBYVIsY0FBY00sU0FBUyxDQUFDN1IsS0FBS0csR0FBRyxDQUFDLEdBQUc0UjtJQUNoRztJQUNBLElBQUksQ0FBQ3hKLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsTUFBTS9GLFNBQVM7UUFDYjhCO1FBQ0FoQixXQUFXSixlQUFlSSxTQUFTO1FBQ25DYixJQUFJO1lBQ0YvSixNQUFNO1lBQ05tRSxTQUFTO2dCQUNQRSxhQUFhd0wsWUFBWTdHLFVBQVUsQ0FBQzlFLEVBQUU7Z0JBQ3RDSixhQUFhRixZQUFZb0YsVUFBVSxDQUFDOUUsRUFBRTtZQUN4QztRQUNGO0lBQ0Y7SUFDQSxPQUFPNEY7QUFDVDtBQUVBLElBQUl3UCxnQkFBZ0IsQ0FBQyxFQUNuQkMsVUFBVSxFQUNWOVAsU0FBUyxFQUNUUCxVQUFVLEVBQ1ZMLFVBQVUsRUFDVjJCLGNBQWMsRUFDZGlELFFBQVEsRUFDUitCLGFBQWEsRUFDZDtJQUNDLE1BQU11SSxnQkFBZ0JPLHFCQUFxQjdPLFVBQVUzQixJQUFJLENBQUM0SSxTQUFTLEVBQUU2STtJQUNyRSxNQUFNQyxnQkFBZ0J0QixpQkFBaUI7UUFDckNIO1FBQ0F0TztRQUNBWjtJQUNGO0lBQ0EsSUFBSSxDQUFDMlEsZUFBZTtRQUNsQixPQUFPN047SUFDVDtJQUNBLE1BQU0vSCxjQUFjaUYsVUFBVSxDQUFDMlEsY0FBYztJQUM3QyxNQUFNalAsb0JBQW9CaEIsNkJBQTZCM0YsWUFBWW9GLFVBQVUsQ0FBQzlFLEVBQUUsRUFBRWdGO0lBQ2xGLE1BQU15UCxtQ0FBbUMvRixvQkFBb0JoUCxhQUFhbVU7SUFDMUUsT0FBT21CLGlCQUFpQjtRQUN0QlA7UUFDQWxQO1FBQ0FlO1FBQ0E1RztRQUNBMkc7UUFDQWlGO0lBQ0YsTUFBTWtKLGlCQUFpQjtRQUNyQkM7UUFDQWxQO1FBQ0E3RjtRQUNBMkc7UUFDQVMsTUFBTVIsZUFBZUksU0FBUztRQUM5QjZDO1FBQ0ErQjtJQUNGO0FBQ0Y7QUFFQSxJQUFJaUssb0JBQW9CLENBQUM1USxZQUFZcUosVUFBYTtRQUNoRCxHQUFHckosVUFBVTtRQUNiLENBQUNxSixRQUFRbEosVUFBVSxDQUFDOUUsRUFBRSxDQUFDLEVBQUVnTztJQUMzQjtBQUVBLE1BQU13SCx5QkFBeUIsQ0FBQyxFQUM5QmxQLGNBQWMsRUFDZFYsTUFBTSxFQUNOakIsVUFBVSxFQUNYO0lBQ0MsTUFBTW1DLE9BQU82TCxrQkFBa0JyTTtJQUMvQixNQUFNbVAsTUFBTTlDLGtCQUFrQi9NO0lBQzlCLElBQUksQ0FBQ2tCLE1BQU07UUFDVCxPQUFPbkM7SUFDVDtJQUNBLElBQUltQyxTQUFTMk8sS0FBSztRQUNoQixPQUFPOVE7SUFDVDtJQUNBLE1BQU0rUSxnQkFBZ0IvUSxVQUFVLENBQUNtQyxLQUFLO0lBQ3RDLElBQUksQ0FBQzRPLGNBQWN2VCxPQUFPLENBQUNrQixlQUFlLEVBQUU7UUFDMUMsT0FBT3NCO0lBQ1Q7SUFDQSxNQUFNcUosVUFBVWtFLGtCQUFrQndEO0lBQ2xDLE9BQU9ILGtCQUFrQjVRLFlBQVlxSjtBQUN2QztBQUNBLElBQUkySCx3QkFBd0IsQ0FBQyxFQUMzQnBRLFNBQVMsRUFDVFAsVUFBVSxFQUNWTCxVQUFVLEVBQ1YyQixjQUFjLEVBQ2RWLE1BQU0sRUFDUDtJQUNDLE1BQU1nUSxVQUFVSix1QkFBdUI7UUFDckNsUDtRQUNBVjtRQUNBakI7SUFDRjtJQUNBLE1BQU0rTixTQUFTQyxrQkFBa0IvTTtJQUNqQyxJQUFJLENBQUM4TSxRQUFRO1FBQ1gsT0FBT2tEO0lBQ1Q7SUFDQSxNQUFNelIsWUFBWVEsVUFBVSxDQUFDK04sT0FBTztJQUNwQyxJQUFJdEwsU0FBUzdCLFdBQVdwQixZQUFZO1FBQ2xDLE9BQU95UjtJQUNUO0lBQ0EsSUFBSXpSLFVBQVVoQyxPQUFPLENBQUNrQixlQUFlLEVBQUU7UUFDckMsT0FBT3VTO0lBQ1Q7SUFDQSxNQUFNQyxVQUFVakUsZUFBZXpOLFdBQVdvQixXQUFXUDtJQUNyRCxPQUFPdVEsa0JBQWtCSyxTQUFTQztBQUNwQztBQUVBLElBQUl4VixTQUFTLENBQUMsRUFDWnlTLEtBQUssRUFDTG5ELGlCQUFpQm1HLHFCQUFxQixFQUN0QzlDLFlBQVkrQyxnQkFBZ0IsRUFDNUJ4TSxVQUFVeU0sY0FBYyxFQUN4QnBRLFFBQVFxUSxZQUFZLEVBQ3BCckcsaUJBQWlCLEVBQ2xCO0lBQ0MsTUFBTXJHLFdBQVd5TSxrQkFBa0JsRCxNQUFNdkosUUFBUTtJQUNqRCxNQUFNeUosYUFBYStDLG9CQUFvQmpELE1BQU1FLFVBQVU7SUFDdkQsTUFBTXJELGtCQUFrQm1HLHlCQUF5QmhELE1BQU1yTyxPQUFPLENBQUN1SyxNQUFNLENBQUNzRSxTQUFTO0lBQy9FLE1BQU03WSxTQUFTeUcsU0FBU3lPLGlCQUFpQm1ELE1BQU12TyxPQUFPLENBQUN5SyxNQUFNLENBQUNzRSxTQUFTO0lBQ3ZFLE1BQU10RSxTQUFTO1FBQ2J2VTtRQUNBNlksV0FBVzNEO1FBQ1gwRCxpQkFBaUJ0UyxJQUFJK1IsTUFBTXZPLE9BQU8sQ0FBQ3lLLE1BQU0sQ0FBQ3FFLGVBQWUsRUFBRTVZO0lBQzdEO0lBQ0EsTUFBTW1KLE9BQU87UUFDWDBQLFdBQVd2UyxJQUFJaU8sT0FBT3NFLFNBQVMsRUFBRS9KLFNBQVN2RyxNQUFNLENBQUN5QixPQUFPO1FBQ3hENE8saUJBQWlCdFMsSUFBSWlPLE9BQU9xRSxlQUFlLEVBQUU5SixTQUFTdkcsTUFBTSxDQUFDeUIsT0FBTztRQUNwRWhLLFFBQVFzRyxJQUFJaU8sT0FBT3ZVLE1BQU0sRUFBRThPLFNBQVN2RyxNQUFNLENBQUNDLElBQUksQ0FBQzNILEtBQUs7SUFDdkQ7SUFDQSxNQUFNbUosVUFBVTtRQUNkdUs7UUFDQXBMO0lBQ0Y7SUFDQSxJQUFJa1AsTUFBTVUsS0FBSyxLQUFLLGNBQWM7UUFDaEMsT0FBTztZQUNMLEdBQUdWLEtBQUs7WUFDUkU7WUFDQXpKO1lBQ0E5RTtRQUNGO0lBQ0Y7SUFDQSxNQUFNYyxZQUFZeU4sV0FBV2hPLFVBQVUsQ0FBQzhOLE1BQU1LLFFBQVEsQ0FBQzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztJQUNwRSxNQUFNMk8sWUFBWXNILGdCQUFnQmIsY0FBYztRQUM5Q0MsWUFBWXpSLEtBQUtuSixNQUFNO1FBQ3ZCOEs7UUFDQVAsWUFBWWdPLFdBQVdoTyxVQUFVO1FBQ2pDTCxZQUFZcU8sV0FBV3JPLFVBQVU7UUFDakMyQixnQkFBZ0J3TSxNQUFNbE4sTUFBTTtRQUM1QjJEO1FBQ0ErQixlQUFld0gsTUFBTXhILGFBQWE7SUFDcEM7SUFDQSxNQUFNNEssMEJBQTBCUCxzQkFBc0I7UUFDcERwUTtRQUNBSyxRQUFRK0k7UUFDUnJJLGdCQUFnQndNLE1BQU1sTixNQUFNO1FBQzVCWixZQUFZZ08sV0FBV2hPLFVBQVU7UUFDakNMLFlBQVlxTyxXQUFXck8sVUFBVTtJQUNuQztJQUNBLE1BQU1sRSxTQUFTO1FBQ2IsR0FBR3FTLEtBQUs7UUFDUnJPO1FBQ0F1TyxZQUFZO1lBQ1ZoTyxZQUFZZ08sV0FBV2hPLFVBQVU7WUFDakNMLFlBQVl1UjtRQUNkO1FBQ0F0USxRQUFRK0k7UUFDUnBGO1FBQ0FxRyxtQkFBbUJBLHFCQUFxQjtRQUN4QzVGLG9CQUFvQjRGLG9CQUFvQixRQUFRO0lBQ2xEO0lBQ0EsT0FBT25QO0FBQ1Q7QUFFQSxTQUFTMFYsY0FBY2pJLEdBQUcsRUFBRWxKLFVBQVU7SUFDcEMsT0FBT2tKLElBQUlyUixHQUFHLENBQUNtRCxDQUFBQSxLQUFNZ0YsVUFBVSxDQUFDaEYsR0FBRztBQUNyQztBQUNBLElBQUlvVyxZQUFZLENBQUMsRUFDZnhRLE1BQU0sRUFDTjJELFFBQVEsRUFDUnZFLFVBQVUsRUFDVnRGLFdBQVcsRUFDWHNLLGtCQUFrQixFQUNuQjtJQUNDLE1BQU1sRCxPQUFPbEIsT0FBT2MsU0FBUztJQUM3QixNQUFNMkQsZ0JBQWdCOEwsY0FBY3JQLEtBQUtMLEdBQUcsRUFBRXpCO0lBQzlDLE1BQU0wQixZQUFZMEQsc0JBQXNCO1FBQ3RDQztRQUNBM0s7UUFDQWdJLGFBQWE5QixPQUFPOEIsV0FBVztRQUMvQjZCLFVBQVVBLFNBQVNySCxLQUFLO1FBQ3hCOEg7UUFDQWxEO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsR0FBR2xCLE1BQU07UUFDVGM7SUFDRjtBQUNGO0FBRUEsSUFBSTJQLDJCQUEyQixDQUFDLEVBQzlCelEsTUFBTSxFQUNOTCxTQUFTLEVBQ1RwQixTQUFTLEVBQ1RhLFVBQVUsRUFDVnVFLFFBQVEsRUFDUitCLGFBQWEsRUFDZDtJQUNDLE1BQU13RCxzQkFBc0JqQixpQ0FBaUM7UUFDM0RqSTtRQUNBTDtRQUNBUDtRQUNBYjtRQUNBbUg7SUFDRjtJQUNBLE9BQU91RCxpQ0FBaUM7UUFDdENDO1FBQ0F2SjtRQUNBZ0U7SUFDRjtBQUNGO0FBRUEsSUFBSStNLGNBQWMsQ0FBQyxFQUNqQnhELEtBQUssRUFDTEUsWUFBWStDLGdCQUFnQixFQUM1QnhNLFVBQVV5TSxjQUFjLEVBQ3pCO0lBQ0MsQ0FBRWxELENBQUFBLE1BQU15RCxZQUFZLEtBQUssTUFBSyxJQUFLcmIsS0FBcUMsR0FBRzJDLGNBQWNBLENBQVdBLEdBQUcsS0FBSztJQUM1RyxNQUFNMlksdUJBQXVCMUQsTUFBTWxOLE1BQU07SUFDekMsTUFBTTJELFdBQVd5TSxrQkFBa0JsRCxNQUFNdkosUUFBUTtJQUNqRCxNQUFNeUosYUFBYStDLG9CQUFvQmpELE1BQU1FLFVBQVU7SUFDdkQsTUFBTSxFQUNKaE8sVUFBVSxFQUNWTCxVQUFVLEVBQ1gsR0FBR3FPO0lBQ0osTUFBTXpOLFlBQVlQLFVBQVUsQ0FBQzhOLE1BQU1LLFFBQVEsQ0FBQzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztJQUN6RCxNQUFNMFMsU0FBU0Msa0JBQWtCNkQ7SUFDakMsQ0FBQzlELFNBQVN4WCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNEQUFzREEsQ0FBV0EsR0FBRyxLQUFLO0lBQzVJLE1BQU02QixjQUFjaUYsVUFBVSxDQUFDK04sT0FBTztJQUN0QyxNQUFNOU0sU0FBU3dRLFVBQVU7UUFDdkJ4USxRQUFRNFE7UUFDUmpOO1FBQ0E3SjtRQUNBc0Y7SUFDRjtJQUNBLE1BQU0ySyxrQkFBa0IwRyx5QkFBeUI7UUFDL0N6UTtRQUNBTDtRQUNBcEIsV0FBV3pFO1FBQ1hzRjtRQUNBdUU7UUFDQStCLGVBQWV3SCxNQUFNeEgsYUFBYTtJQUNwQztJQUNBLE9BQU9qTCxPQUFPO1FBQ1p1RjtRQUNBK0o7UUFDQW1EO1FBQ0FFO1FBQ0F6SjtJQUNGO0FBQ0Y7QUFFQSxJQUFJa04sa0JBQWtCM1IsQ0FBQUEsYUFBZTtRQUNuQ3pGLE9BQU95RixXQUFXekYsS0FBSztRQUN2Qk8sYUFBYWtGLFdBQVdsRixXQUFXO0lBQ3JDO0FBRUEsSUFBSThXLGdCQUFnQixDQUFDLEVBQ25CblIsU0FBUyxFQUNUMk4sSUFBSSxFQUNKbE8sVUFBVSxFQUNWdUUsUUFBUSxFQUNUO0lBQ0MsTUFBTTdCLGNBQWNzSixlQUFla0MsS0FBSzlQLElBQUksRUFBRW1DLFVBQVVrSCxVQUFVO0lBQ2xFLE1BQU1rSyxhQUFhdFIsNkJBQTZCNk4sS0FBS3BPLFVBQVUsQ0FBQzlFLEVBQUUsRUFBRWdGO0lBQ3BFLE1BQU00UixXQUFXRCxXQUFXekwsT0FBTyxDQUFDM0Y7SUFDcEMsQ0FBRXFSLENBQUFBLGFBQWEsQ0FBQyxLQUFLMWIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQVdBLEdBQUcsS0FBSztJQUNoSixNQUFNd00sZ0JBQWdCc00sV0FBV3ZMLEtBQUssQ0FBQ3dMLFdBQVc7SUFDbEQsTUFBTXBMLFdBQVduQixjQUFjekYsTUFBTSxDQUFDLENBQUNDLFVBQVVxQjtRQUMvQ3JCLFFBQVEsQ0FBQ3FCLEtBQUtwQixVQUFVLENBQUM5RSxFQUFFLENBQUMsR0FBRztRQUMvQixPQUFPNkU7SUFDVCxHQUFHLENBQUM7SUFDSixNQUFNeUcsZ0JBQWdCO1FBQ3BCdUwsZUFBZTNELEtBQUtwTyxVQUFVLENBQUNxTSxJQUFJLEtBQUs7UUFDeEN6SjtRQUNBOEQ7SUFDRjtJQUNBLE1BQU05RSxZQUFZMEQsc0JBQXNCO1FBQ3RDQztRQUNBM0ssYUFBYXdUO1FBQ2J4TDtRQUNBWixNQUFNO1FBQ055QyxVQUFVQSxTQUFTckgsS0FBSztRQUN4QjhILG9CQUFvQjtJQUN0QjtJQUNBLE1BQU1wRSxTQUFTO1FBQ2JjO1FBQ0FnQjtRQUNBN0IsSUFBSTtZQUNGL0osTUFBTTtZQUNONEQsYUFBYStXLGdCQUFnQmxSLFVBQVVULFVBQVU7UUFDbkQ7SUFDRjtJQUNBLE9BQU87UUFDTGM7UUFDQTBGO0lBQ0Y7QUFDRjtBQUVBLElBQUl3TCxvQkFBb0IsQ0FBQzlELFlBQVloRixVQUFhO1FBQ2hEaEosWUFBWWdPLFdBQVdoTyxVQUFVO1FBQ2pDTCxZQUFZNFEsa0JBQWtCdkMsV0FBV3JPLFVBQVUsRUFBRXFKO0lBQ3ZEO0FBRUEsTUFBTXpPLFFBQVF3WCxDQUFBQTtJQUNaLElBQUk3YixJQUF5QixFQUFjO1FBQ3pDO1lBQ0U7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxNQUFNOGIsU0FBU0QsQ0FBQUE7SUFDYixJQUFJN2IsSUFBeUIsRUFBYztRQUN6QztZQUNFO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSStiLGtCQUFrQixDQUFDLEVBQ3JCMVIsU0FBUyxFQUNUOUssUUFBUXljLFFBQVEsRUFDaEJDLG1CQUFtQixFQUNwQjtJQUNDLE1BQU1uSSxTQUFTdlUscURBQU1BLENBQUM4SyxVQUFVeUosTUFBTSxFQUFFa0k7SUFDeEMsTUFBTXRULE9BQU9sSix5REFBVUEsQ0FBQ3NVLFFBQVFtSTtJQUNoQyxNQUFNQyxRQUFRO1FBQ1osR0FBRzdSLFNBQVM7UUFDWjhSLGFBQWE7WUFDWCxHQUFHOVIsVUFBVThSLFdBQVc7WUFDeEJySTtRQUNGO1FBQ0FBO1FBQ0FwTDtJQUNGO0lBQ0EsT0FBT3dUO0FBQ1Q7QUFFQSxJQUFJRSxXQUFXblQsQ0FBQUE7SUFDYixNQUFNakMsUUFBUWlDLFVBQVVqQyxLQUFLO0lBQzdCLENBQUNBLFFBQVFoSCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHdDQUF3Q0EsQ0FBV0EsR0FBRyxLQUFLO0lBQzdILE9BQU9xRTtBQUNUO0FBRUEsSUFBSXFWLGtDQUFrQyxDQUFDLEVBQ3JDQyxTQUFTLEVBQ1RDLGlCQUFpQixFQUNqQmxPLFFBQVEsRUFDVDtJQUNDLE1BQU1tTyxxQkFBcUJuTyxTQUFTdkcsTUFBTSxDQUFDQyxJQUFJLENBQUMzSCxLQUFLO0lBQ3JELE9BQU9rYyxVQUFVM2EsR0FBRyxDQUFDMEksQ0FBQUE7UUFDbkIsTUFBTTNGLGNBQWMyRixVQUFVVCxVQUFVLENBQUNsRixXQUFXO1FBQ3BELE1BQU0rWCxXQUFXRixpQkFBaUIsQ0FBQzdYLFlBQVk7UUFDL0MsTUFBTXNDLFFBQVFvVixTQUFTSztRQUN2QixNQUFNQyx3QkFBd0IxVixNQUFNYyxNQUFNLENBQUNDLElBQUksQ0FBQzNILEtBQUs7UUFDckQsTUFBTXVjLGNBQWM5VyxJQUFJMlcsb0JBQW9CRTtRQUM1QyxNQUFNUixRQUFRSCxnQkFBZ0I7WUFDNUIxUjtZQUNBOUssUUFBUW9kO1lBQ1JWLHFCQUFxQjVOLFNBQVN2RyxNQUFNLENBQUN1QixPQUFPO1FBQzlDO1FBQ0EsT0FBTzZTO0lBQ1Q7QUFDRjtBQUVBLE1BQU1VLGFBQWE7QUFDbkIsSUFBSUMsZ0NBQWdDLENBQUMsRUFDbkNqRixLQUFLLEVBQ0xrRixTQUFTLEVBQ1Y7SUFDQ3pZO0lBQ0EsTUFBTTBZLG1CQUFtQkQsVUFBVUwsUUFBUSxDQUFDOWEsR0FBRyxDQUFDd0QsQ0FBQUE7UUFDOUMsTUFBTTZYLFdBQVdwRixNQUFNRSxVQUFVLENBQUNyTyxVQUFVLENBQUN0RSxPQUFPVCxXQUFXLENBQUM7UUFDaEUsTUFBTWlFLFdBQVdLLGdCQUFnQmdVLFVBQVU3WCxPQUFPMkMsTUFBTTtRQUN4RCxPQUFPYTtJQUNUO0lBQ0EsTUFBTWMsYUFBYTtRQUNqQixHQUFHbU8sTUFBTUUsVUFBVSxDQUFDck8sVUFBVTtRQUM5QixHQUFHRCxlQUFldVQsaUJBQWlCO0lBQ3JDO0lBQ0EsTUFBTUUsbUJBQW1CcFQsZUFBZXdTLGdDQUFnQztRQUN0RUMsV0FBV1EsVUFBVVIsU0FBUztRQUM5QkMsbUJBQW1COVM7UUFDbkI0RSxVQUFVdUosTUFBTXZKLFFBQVE7SUFDMUI7SUFDQSxNQUFNdkUsYUFBYTtRQUNqQixHQUFHOE4sTUFBTUUsVUFBVSxDQUFDaE8sVUFBVTtRQUM5QixHQUFHbVQsZ0JBQWdCO0lBQ3JCO0lBQ0FILFVBQVVJLFFBQVEsQ0FBQzlhLE9BQU8sQ0FBQzBDLENBQUFBO1FBQ3pCLE9BQU9nRixVQUFVLENBQUNoRixHQUFHO0lBQ3ZCO0lBQ0EsTUFBTWdULGFBQWE7UUFDakJyTztRQUNBSztJQUNGO0lBQ0EsTUFBTXFULFlBQVkxRixrQkFBa0JHLE1BQU1sTixNQUFNO0lBQ2hELE1BQU0wUyxVQUFVRCxZQUFZckYsV0FBV3JPLFVBQVUsQ0FBQzBULFVBQVUsR0FBRztJQUMvRCxNQUFNOVMsWUFBWXlOLFdBQVdoTyxVQUFVLENBQUM4TixNQUFNSyxRQUFRLENBQUM1TixTQUFTLENBQUN2RixFQUFFLENBQUM7SUFDcEUsTUFBTWtULE9BQU9GLFdBQVdyTyxVQUFVLENBQUNtTyxNQUFNSyxRQUFRLENBQUNoUCxTQUFTLENBQUNuRSxFQUFFLENBQUM7SUFDL0QsTUFBTSxFQUNKNEYsUUFBUTJTLFlBQVksRUFDcEJqTixhQUFhLEVBQ2QsR0FBR29MLGNBQWM7UUFDaEJuUjtRQUNBMk47UUFDQWxPO1FBQ0F1RSxVQUFVdUosTUFBTXZKLFFBQVE7SUFDMUI7SUFDQSxNQUFNakQsaUJBQWlCZ1MsV0FBV0EsUUFBUS9SLGdCQUFnQixHQUFHdU0sTUFBTWxOLE1BQU0sR0FBRzJTO0lBQzVFLE1BQU0zUyxTQUFTd1AsY0FBYztRQUMzQkMsWUFBWXZDLE1BQU1yTyxPQUFPLENBQUNiLElBQUksQ0FBQ25KLE1BQU07UUFDckM4SyxXQUFXeU4sV0FBV2hPLFVBQVUsQ0FBQzhOLE1BQU1LLFFBQVEsQ0FBQzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztRQUM3RGdGLFlBQVlnTyxXQUFXaE8sVUFBVTtRQUNqQ0wsWUFBWXFPLFdBQVdyTyxVQUFVO1FBQ2pDMkI7UUFDQWlELFVBQVV1SixNQUFNdkosUUFBUTtRQUN4QitCO0lBQ0Y7SUFDQTBMLE9BQU9jO0lBQ1AsTUFBTVUsZ0JBQWdCO1FBQ3BCLEdBQUcxRixLQUFLO1FBQ1JVLE9BQU87UUFDUDVOO1FBQ0EyUztRQUNBdkY7UUFDQTFIO1FBQ0F0QixvQkFBb0I7SUFDdEI7SUFDQSxJQUFJOEksTUFBTVUsS0FBSyxLQUFLLGNBQWM7UUFDaEMsT0FBT2dGO0lBQ1Q7SUFDQSxNQUFNQyxjQUFjO1FBQ2xCLEdBQUdELGFBQWE7UUFDaEJoRixPQUFPO1FBQ1A5UyxRQUFRb1MsTUFBTXBTLE1BQU07UUFDcEJnWSxXQUFXO0lBQ2I7SUFDQSxPQUFPRDtBQUNUO0FBRUEsTUFBTUUsYUFBYTdGLENBQUFBLFFBQVNBLE1BQU15RCxZQUFZLEtBQUs7QUFDbkQsTUFBTXFDLHNCQUFzQixDQUFDOUYsT0FBTzlFLFNBQVM2SztJQUMzQyxNQUFNN0YsYUFBYThELGtCQUFrQmhFLE1BQU1FLFVBQVUsRUFBRWhGO0lBQ3ZELElBQUksQ0FBQzJLLFdBQVc3RixVQUFVK0YsbUJBQW1CO1FBQzNDLE9BQU94WSxPQUFPO1lBQ1p5UztZQUNBRTtRQUNGO0lBQ0Y7SUFDQSxPQUFPc0QsWUFBWTtRQUNqQnhEO1FBQ0FFO0lBQ0Y7QUFDRjtBQUNBLFNBQVM4Rix3QkFBd0JoRyxLQUFLO0lBQ3BDLElBQUlBLE1BQU12VSxVQUFVLElBQUl1VSxNQUFNeUQsWUFBWSxLQUFLLFFBQVE7UUFDckQsT0FBTztZQUNMLEdBQUd6RCxLQUFLO1lBQ1JsRCxtQkFBbUI7UUFDckI7SUFDRjtJQUNBLE9BQU9rRDtBQUNUO0FBQ0EsTUFBTWlHLFNBQVM7SUFDYnZGLE9BQU87SUFDUHdGLFdBQVc7SUFDWEMsYUFBYTtBQUNmO0FBQ0EsSUFBSUMsVUFBVSxDQUFDcEcsUUFBUWlHLE1BQU0sRUFBRUk7SUFDN0IsSUFBSUEsT0FBT3JkLElBQUksS0FBSyxTQUFTO1FBQzNCLE9BQU87WUFDTCxHQUFHaWQsTUFBTTtZQUNURSxhQUFhO1FBQ2Y7SUFDRjtJQUNBLElBQUlFLE9BQU9yZCxJQUFJLEtBQUssbUJBQW1CO1FBQ3JDLENBQUVnWCxDQUFBQSxNQUFNVSxLQUFLLEtBQUssTUFBSyxJQUFLdFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxrREFBa0RBLENBQVdBLEdBQUcsS0FBSztRQUMxSixNQUFNLEVBQ0pzVixRQUFRLEVBQ1J4RCxlQUFlLEVBQ2ZwRyxRQUFRLEVBQ1J5SixVQUFVLEVBQ1Z1RCxZQUFZLEVBQ2IsR0FBRzRDLE9BQU9DLE9BQU87UUFDbEIsTUFBTTdULFlBQVl5TixXQUFXaE8sVUFBVSxDQUFDbU8sU0FBUzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztRQUM5RCxNQUFNa1QsT0FBT0YsV0FBV3JPLFVBQVUsQ0FBQ3dPLFNBQVNoUCxTQUFTLENBQUNuRSxFQUFFLENBQUM7UUFDekQsTUFBTWdQLFNBQVM7WUFDYnNFLFdBQVczRDtZQUNYMEQsaUJBQWlCOU4sVUFBVXlKLE1BQU0sQ0FBQ3hDLFNBQVMsQ0FBQ0QsTUFBTTtZQUNsRDlSLFFBQVFtRztRQUNWO1FBQ0EsTUFBTTJELFVBQVU7WUFDZHlLO1lBQ0FwTCxNQUFNO2dCQUNKMFAsV0FBV3ZTLElBQUlpTyxPQUFPc0UsU0FBUyxFQUFFL0osU0FBU3ZHLE1BQU0sQ0FBQ3VCLE9BQU87Z0JBQ3hEOE8saUJBQWlCdFMsSUFBSWlPLE9BQU9zRSxTQUFTLEVBQUUvSixTQUFTdkcsTUFBTSxDQUFDdUIsT0FBTztnQkFDOUQ5SixRQUFRc0csSUFBSWlPLE9BQU9zRSxTQUFTLEVBQUUvSixTQUFTdkcsTUFBTSxDQUFDQyxJQUFJLENBQUMzSCxLQUFLO1lBQzFEO1FBQ0Y7UUFDQSxNQUFNK2Qsd0JBQXdCcFUsZ0JBQWdCK04sV0FBV3JPLFVBQVUsRUFBRTJVLEtBQUssQ0FBQ3BULENBQUFBLE9BQVEsQ0FBQ0EsS0FBS3FULGFBQWE7UUFDdEcsTUFBTSxFQUNKM1QsTUFBTSxFQUNOMEYsYUFBYSxFQUNkLEdBQUdvTCxjQUFjO1lBQ2hCblI7WUFDQTJOO1lBQ0FsTyxZQUFZZ08sV0FBV2hPLFVBQVU7WUFDakN1RTtRQUNGO1FBQ0EsTUFBTTlJLFNBQVM7WUFDYitTLE9BQU87WUFDUGpWLFlBQVk7WUFDWjRVO1lBQ0FvRDtZQUNBdkQ7WUFDQXpPO1lBQ0FFLFNBQVNGO1lBQ1Q4VTtZQUNBelQ7WUFDQTBGO1lBQ0FpTixjQUFjM1M7WUFDZDJEO1lBQ0FxRyxtQkFBbUI7WUFDbkI1RixvQkFBb0I7UUFDdEI7UUFDQSxPQUFPdko7SUFDVDtJQUNBLElBQUkwWSxPQUFPcmQsSUFBSSxLQUFLLHVCQUF1QjtRQUN6QyxJQUFJZ1gsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQlYsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQjtZQUNsRSxPQUFPVjtRQUNUO1FBQ0EsQ0FBRUEsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLFVBQVMsSUFBS3RZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxtQ0FBbUMsRUFBRWlWLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUkzVixDQUFXQSxHQUFHLEtBQUs7UUFDbkssTUFBTTRDLFNBQVM7WUFDYixHQUFHcVMsS0FBSztZQUNSVSxPQUFPO1FBQ1Q7UUFDQSxPQUFPL1M7SUFDVDtJQUNBLElBQUkwWSxPQUFPcmQsSUFBSSxLQUFLLDBCQUEwQjtRQUM1QyxDQUFFZ1gsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQlYsTUFBTVUsS0FBSyxLQUFLLGNBQWEsSUFBS3RZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxXQUFXLEVBQUVzYixPQUFPcmQsSUFBSSxDQUFDLG1CQUFtQixFQUFFZ1gsTUFBTVUsS0FBSyxDQUFDLENBQUMsSUFBSTNWLENBQVdBLEdBQUcsS0FBSztRQUNoTixPQUFPa2EsOEJBQThCO1lBQ25DakY7WUFDQWtGLFdBQVdtQixPQUFPQyxPQUFPO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJRCxPQUFPcmQsSUFBSSxLQUFLLFFBQVE7UUFDMUIsSUFBSWdYLE1BQU1VLEtBQUssS0FBSyxnQkFBZ0I7WUFDbEMsT0FBT1Y7UUFDVDtRQUNBLENBQUNTLGtCQUFrQlQsU0FBUzVYLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxFQUFFc2IsT0FBT3JkLElBQUksQ0FBQyx3QkFBd0IsRUFBRWdYLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUkzVixDQUFXQSxHQUFHLEtBQUs7UUFDbEssTUFBTSxFQUNKbVIsUUFBUVcsZUFBZSxFQUN4QixHQUFHd0osT0FBT0MsT0FBTztRQUNsQixJQUFJalksVUFBVXdPLGlCQUFpQm1ELE1BQU1yTyxPQUFPLENBQUN1SyxNQUFNLENBQUNzRSxTQUFTLEdBQUc7WUFDOUQsT0FBT1I7UUFDVDtRQUNBLE9BQU96UyxPQUFPO1lBQ1p5UztZQUNBbkQ7WUFDQS9KLFFBQVErUyxXQUFXN0YsU0FBU0EsTUFBTWxOLE1BQU0sR0FBRztRQUM3QztJQUNGO0lBQ0EsSUFBSXVULE9BQU9yZCxJQUFJLEtBQUssMkJBQTJCO1FBQzdDLElBQUlnWCxNQUFNVSxLQUFLLEtBQUssZ0JBQWdCO1lBQ2xDLE9BQU9zRix3QkFBd0JoRztRQUNqQztRQUNBLElBQUlBLE1BQU1VLEtBQUssS0FBSyxjQUFjO1lBQ2hDLE9BQU9zRix3QkFBd0JoRztRQUNqQztRQUNBLENBQUNTLGtCQUFrQlQsU0FBUzVYLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxFQUFFc2IsT0FBT3JkLElBQUksQ0FBQyx3QkFBd0IsRUFBRWdYLE1BQU1VLEtBQUssQ0FBQyxDQUFDLElBQUkzVixDQUFXQSxHQUFHLEtBQUs7UUFDbEssTUFBTSxFQUNKbUMsRUFBRSxFQUNGb0UsU0FBUyxFQUNWLEdBQUcrVSxPQUFPQyxPQUFPO1FBQ2xCLE1BQU12WCxTQUFTaVIsTUFBTUUsVUFBVSxDQUFDck8sVUFBVSxDQUFDM0UsR0FBRztRQUM5QyxJQUFJLENBQUM2QixRQUFRO1lBQ1gsT0FBT2lSO1FBQ1Q7UUFDQSxNQUFNalAsV0FBV0ssZ0JBQWdCckMsUUFBUXVDO1FBQ3pDLE9BQU93VSxvQkFBb0I5RixPQUFPalAsVUFBVTtJQUM5QztJQUNBLElBQUlzVixPQUFPcmQsSUFBSSxLQUFLLCtCQUErQjtRQUNqRCxJQUFJZ1gsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQjtZQUNsQyxPQUFPVjtRQUNUO1FBQ0EsQ0FBQ1Msa0JBQWtCVCxTQUFTNVgsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLDJDQUEyQyxFQUFFaVYsTUFBTVUsS0FBSyxDQUFDLENBQUMsSUFBSTNWLENBQVdBLEdBQUcsS0FBSztRQUN2SyxNQUFNLEVBQ0ptQyxFQUFFLEVBQ0Z5UCxTQUFTLEVBQ1YsR0FBRzBKLE9BQU9DLE9BQU87UUFDbEIsTUFBTXZYLFNBQVNpUixNQUFNRSxVQUFVLENBQUNyTyxVQUFVLENBQUMzRSxHQUFHO1FBQzlDLENBQUM2QixTQUFTM0csS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLDBCQUEwQixFQUFFbUMsR0FBRyw2QkFBNkIsQ0FBQyxJQUFJbkMsQ0FBV0EsR0FBRyxLQUFLO1FBQ3hKLENBQUVnRSxDQUFBQSxPQUFPNE4sU0FBUyxLQUFLQSxTQUFRLElBQUt2VSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMscUNBQXFDLEVBQUUyYixPQUFPL0osV0FBVzt3QkFDbkksRUFBRStKLE9BQU8zWCxPQUFPNE4sU0FBUyxFQUFFLENBQUMsSUFBSTVSLENBQVdBLEdBQUcsS0FBSztRQUN2RSxNQUFNbVEsVUFBVTtZQUNkLEdBQUduTSxNQUFNO1lBQ1Q0TjtRQUNGO1FBQ0EsT0FBT21KLG9CQUFvQjlGLE9BQU85RSxTQUFTO0lBQzdDO0lBQ0EsSUFBSW1MLE9BQU9yZCxJQUFJLEtBQUssdUNBQXVDO1FBQ3pELElBQUlnWCxNQUFNVSxLQUFLLEtBQUssZ0JBQWdCO1lBQ2xDLE9BQU9WO1FBQ1Q7UUFDQSxDQUFDUyxrQkFBa0JULFNBQVM1WCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsMkNBQTJDLEVBQUVpVixNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJM1YsQ0FBV0EsR0FBRyxLQUFLO1FBQ3ZLLE1BQU0sRUFDSm1DLEVBQUUsRUFDRnVHLGdCQUFnQixFQUNqQixHQUFHNFMsT0FBT0MsT0FBTztRQUNsQixNQUFNdlgsU0FBU2lSLE1BQU1FLFVBQVUsQ0FBQ3JPLFVBQVUsQ0FBQzNFLEdBQUc7UUFDOUMsQ0FBQzZCLFNBQVMzRyxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsMEJBQTBCLEVBQUVtQyxHQUFHLHNDQUFzQyxDQUFDLElBQUluQyxDQUFXQSxHQUFHLEtBQUs7UUFDakssQ0FBRWdFLENBQUFBLE9BQU8wRSxnQkFBZ0IsS0FBS0EsZ0JBQWUsSUFBS3JMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyw0Q0FBNEMsRUFBRTJiLE9BQU9qVCxrQkFBa0I7d0JBQy9KLEVBQUVpVCxPQUFPM1gsT0FBTzBFLGdCQUFnQixFQUFFLENBQUMsSUFBSTFJLENBQVdBLEdBQUcsS0FBSztRQUM5RSxNQUFNbVEsVUFBVTtZQUNkLEdBQUduTSxNQUFNO1lBQ1QwRTtRQUNGO1FBQ0EsT0FBT3FTLG9CQUFvQjlGLE9BQU85RSxTQUFTO0lBQzdDO0lBQ0EsSUFBSW1MLE9BQU9yZCxJQUFJLEtBQUsseUJBQXlCO1FBQzNDLElBQUlnWCxNQUFNVSxLQUFLLEtBQUssa0JBQWtCVixNQUFNVSxLQUFLLEtBQUssa0JBQWtCO1lBQ3RFLE9BQU9WO1FBQ1Q7UUFDQSxDQUFDUyxrQkFBa0JULFNBQVM1WCxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsK0JBQStCLEVBQUVpVixNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJM1YsQ0FBV0EsR0FBRyxLQUFLO1FBQzNKLENBQUNpVixNQUFNdUcscUJBQXFCLEdBQUduZSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGlFQUFpRUEsQ0FBV0EsR0FBRyxLQUFLO1FBQzVLLE1BQU11RyxZQUFZK1UsT0FBT0MsT0FBTyxDQUFDaFYsU0FBUztRQUMxQyxJQUFJakQsVUFBVTJSLE1BQU12SixRQUFRLENBQUN2RyxNQUFNLENBQUN5QixPQUFPLEVBQUVMLFlBQVk7WUFDdkQsT0FBTzBVLHdCQUF3QmhHO1FBQ2pDO1FBQ0EsTUFBTXZKLFdBQVd3RSxlQUFlK0UsTUFBTXZKLFFBQVEsRUFBRW5GO1FBQ2hELElBQUl1VSxXQUFXN0YsUUFBUTtZQUNyQixPQUFPd0QsWUFBWTtnQkFDakJ4RDtnQkFDQXZKO1lBQ0Y7UUFDRjtRQUNBLE9BQU9sSixPQUFPO1lBQ1p5UztZQUNBdko7UUFDRjtJQUNGO0lBQ0EsSUFBSTRQLE9BQU9yZCxJQUFJLEtBQUssOEJBQThCO1FBQ2hELElBQUksQ0FBQ3lYLGtCQUFrQlQsUUFBUTtZQUM3QixPQUFPQTtRQUNUO1FBQ0EsTUFBTWQsWUFBWW1ILE9BQU9DLE9BQU8sQ0FBQ3BILFNBQVM7UUFDMUMsSUFBSTdRLFVBQVU2USxXQUFXYyxNQUFNdkosUUFBUSxDQUFDdkcsTUFBTSxDQUFDWCxHQUFHLEdBQUc7WUFDbkQsT0FBT3lRO1FBQ1Q7UUFDQSxNQUFNbkIsZ0JBQWdCO1lBQ3BCLEdBQUdtQixNQUFNdkosUUFBUTtZQUNqQnZHLFFBQVE7Z0JBQ04sR0FBRzhQLE1BQU12SixRQUFRLENBQUN2RyxNQUFNO2dCQUN4QlgsS0FBSzJQO1lBQ1A7UUFDRjtRQUNBLE9BQU87WUFDTCxHQUFHYyxLQUFLO1lBQ1J2SixVQUFVb0k7UUFDWjtJQUNGO0lBQ0EsSUFBSXdILE9BQU9yZCxJQUFJLEtBQUssYUFBYXFkLE9BQU9yZCxJQUFJLEtBQUssZUFBZXFkLE9BQU9yZCxJQUFJLEtBQUssZUFBZXFkLE9BQU9yZCxJQUFJLEtBQUssY0FBYztRQUMzSCxJQUFJZ1gsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQlYsTUFBTVUsS0FBSyxLQUFLLGdCQUFnQjtZQUNsRSxPQUFPVjtRQUNUO1FBQ0EsQ0FBRUEsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLFVBQVMsSUFBS3RZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxFQUFFc2IsT0FBT3JkLElBQUksQ0FBQyxxQ0FBcUMsQ0FBQyxJQUFJK0IsQ0FBV0EsR0FBRyxLQUFLO1FBQ3JLLE1BQU00QyxTQUFTb1MsZ0JBQWdCO1lBQzdCQztZQUNBaFgsTUFBTXFkLE9BQU9yZCxJQUFJO1FBQ25CO1FBQ0EsSUFBSSxDQUFDMkUsUUFBUTtZQUNYLE9BQU9xUztRQUNUO1FBQ0EsT0FBT3pTLE9BQU87WUFDWnlTO1lBQ0FsTixRQUFRbkYsT0FBT21GLE1BQU07WUFDckIrSixpQkFBaUJsUCxPQUFPa1AsZUFBZTtZQUN2Q0MsbUJBQW1CblAsT0FBT21QLGlCQUFpQjtRQUM3QztJQUNGO0lBQ0EsSUFBSXVKLE9BQU9yZCxJQUFJLEtBQUssZ0JBQWdCO1FBQ2xDLE1BQU00RSxTQUFTeVksT0FBT0MsT0FBTyxDQUFDMVksTUFBTTtRQUNwQyxDQUFFb1MsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLFlBQVcsSUFBS3RZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8seUVBQXlFQSxDQUFXQSxHQUFHLEtBQUs7UUFDdkwsTUFBTTRiLFdBQVc7WUFDZixHQUFHM0csS0FBSztZQUNSVSxPQUFPO1lBQ1BrRixXQUFXO1lBQ1hoWTtRQUNGO1FBQ0EsT0FBTytZO0lBQ1Q7SUFDQSxJQUFJTixPQUFPcmQsSUFBSSxLQUFLLGdCQUFnQjtRQUNsQyxNQUFNLEVBQ0prZCxTQUFTLEVBQ1RVLFlBQVksRUFDWkMsbUJBQW1CLEVBQ3BCLEdBQUdSLE9BQU9DLE9BQU87UUFDbEIsQ0FBRXRHLENBQUFBLE1BQU1VLEtBQUssS0FBSyxjQUFjVixNQUFNVSxLQUFLLEtBQUssY0FBYSxJQUFLdFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLCtCQUErQixFQUFFaVYsTUFBTVUsS0FBSyxDQUFDLENBQUMsSUFBSTNWLENBQVdBLEdBQUcsS0FBSztRQUNqTSxNQUFNNEMsU0FBUztZQUNiK1MsT0FBTztZQUNQd0Y7WUFDQVU7WUFDQUM7WUFDQTNHLFlBQVlGLE1BQU1FLFVBQVU7UUFDOUI7UUFDQSxPQUFPdlM7SUFDVDtJQUNBLElBQUkwWSxPQUFPcmQsSUFBSSxLQUFLLGlCQUFpQjtRQUNuQyxNQUFNLEVBQ0prZCxTQUFTLEVBQ1YsR0FBR0csT0FBT0MsT0FBTztRQUNsQixPQUFPO1lBQ0w1RixPQUFPO1lBQ1B3RjtZQUNBQyxhQUFhO1FBQ2Y7SUFDRjtJQUNBLE9BQU9uRztBQUNUO0FBRUEsU0FBUzhHLE1BQU1ULE1BQU0sRUFBRVUsU0FBUztJQUM5QixPQUFPVixrQkFBa0JqVSxVQUFVLFVBQVVpVSxVQUFVQSxPQUFPcmQsSUFBSSxLQUFLK2Q7QUFDekU7QUFDQSxNQUFNQyx1QkFBdUI1YixDQUFBQSxPQUFTO1FBQ3BDcEMsTUFBTTtRQUNOc2QsU0FBU2xiO0lBQ1g7QUFDQSxNQUFNNmIsU0FBUzdiLENBQUFBLE9BQVM7UUFDdEJwQyxNQUFNO1FBQ05zZCxTQUFTbGI7SUFDWDtBQUNBLE1BQU04YixpQkFBaUI5YixDQUFBQSxPQUFTO1FBQzlCcEMsTUFBTTtRQUNOc2QsU0FBU2xiO0lBQ1g7QUFDQSxNQUFNK2IsdUJBQXVCL2IsQ0FBQUEsT0FBUztRQUNwQ3BDLE1BQU07UUFDTnNkLFNBQVNsYjtJQUNYO0FBQ0EsTUFBTWdjLHFCQUFxQixJQUFPO1FBQ2hDcGUsTUFBTTtRQUNOc2QsU0FBUztJQUNYO0FBQ0EsTUFBTWUsd0JBQXdCamMsQ0FBQUEsT0FBUztRQUNyQ3BDLE1BQU07UUFDTnNkLFNBQVNsYjtJQUNYO0FBQ0EsTUFBTWtjLDJCQUEyQmxjLENBQUFBLE9BQVM7UUFDeENwQyxNQUFNO1FBQ05zZCxTQUFTbGI7SUFDWDtBQUNBLE1BQU1tYyxrQ0FBa0NuYyxDQUFBQSxPQUFTO1FBQy9DcEMsTUFBTTtRQUNOc2QsU0FBU2xiO0lBQ1g7QUFDQSxNQUFNb2MsT0FBT3BjLENBQUFBLE9BQVM7UUFDcEJwQyxNQUFNO1FBQ05zZCxTQUFTbGI7SUFDWDtBQUNBLE1BQU1xYyxxQkFBcUJyYyxDQUFBQSxPQUFTO1FBQ2xDcEMsTUFBTTtRQUNOc2QsU0FBU2xiO0lBQ1g7QUFDQSxNQUFNc2MsMEJBQTBCdGMsQ0FBQUEsT0FBUztRQUN2Q3BDLE1BQU07UUFDTnNkLFNBQVNsYjtJQUNYO0FBQ0EsTUFBTXVjLFNBQVMsSUFBTztRQUNwQjNlLE1BQU07UUFDTnNkLFNBQVM7SUFDWDtBQUNBLE1BQU1zQixXQUFXLElBQU87UUFDdEI1ZSxNQUFNO1FBQ05zZCxTQUFTO0lBQ1g7QUFDQSxNQUFNdUIsWUFBWSxJQUFPO1FBQ3ZCN2UsTUFBTTtRQUNOc2QsU0FBUztJQUNYO0FBQ0EsTUFBTXdCLFdBQVcsSUFBTztRQUN0QjllLE1BQU07UUFDTnNkLFNBQVM7SUFDWDtBQUNBLE1BQU15QixRQUFRLElBQU87UUFDbkIvZSxNQUFNO1FBQ05zZCxTQUFTO0lBQ1g7QUFDQSxNQUFNMEIsY0FBYzVjLENBQUFBLE9BQVM7UUFDM0JwQyxNQUFNO1FBQ05zZCxTQUFTbGI7SUFDWDtBQUNBLE1BQU02YyxlQUFlN2MsQ0FBQUEsT0FBUztRQUM1QnBDLE1BQU07UUFDTnNkLFNBQVNsYjtJQUNYO0FBQ0EsTUFBTThjLE9BQU85YyxDQUFBQSxPQUFTO1FBQ3BCcEMsTUFBTTtRQUNOc2QsU0FBU2xiO0lBQ1g7QUFDQSxNQUFNdWEsY0FBY3ZhLENBQUFBLE9BQVM7UUFDM0JwQyxNQUFNO1FBQ05zZCxTQUFTbGI7SUFDWDtBQUNBLE1BQU0rYyx3QkFBd0IsSUFBTztRQUNuQ25mLE1BQU07UUFDTnNkLFNBQVM7SUFDWDtBQUVBLFNBQVM4QixhQUFhN1UsaUJBQWlCO0lBQ3JDLElBQUlBLGtCQUFrQk8sTUFBTSxJQUFJLEdBQUc7UUFDakM7SUFDRjtJQUNBLE1BQU11VSxVQUFVOVUsa0JBQWtCeEosR0FBRyxDQUFDb0ssQ0FBQUEsSUFBS0EsRUFBRW5DLFVBQVUsQ0FBQ3pGLEtBQUs7SUFDN0QsTUFBTStiLFNBQVMsQ0FBQztJQUNoQixJQUFLLElBQUloTixJQUFJLEdBQUdBLElBQUkrTSxRQUFRdlUsTUFBTSxFQUFFd0gsSUFBSztRQUN2QyxNQUFNM0osVUFBVTBXLE9BQU8sQ0FBQy9NLEVBQUU7UUFDMUIsTUFBTXZKLFdBQVdzVyxPQUFPLENBQUMvTSxJQUFJLEVBQUU7UUFDL0IsSUFBSTNKLFlBQVlJLFdBQVcsR0FBRztZQUM1QnVXLE1BQU0sQ0FBQzNXLFFBQVEsR0FBRztRQUNwQjtJQUNGO0lBQ0EsSUFBSSxDQUFDUyxPQUFPbVcsSUFBSSxDQUFDRCxRQUFReFUsTUFBTSxFQUFFO1FBQy9CO0lBQ0Y7SUFDQSxNQUFNMFUsWUFBWUgsUUFBUXRlLEdBQUcsQ0FBQ3dDLENBQUFBO1FBQzVCLE1BQU1rYyxXQUFXaFEsUUFBUTZQLE1BQU0sQ0FBQy9iLE1BQU07UUFDdEMsT0FBT2tjLFdBQVcsQ0FBQyxHQUFHLEVBQUVsYyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsTUFBTSxDQUFDO0lBQy9DLEdBQUdtYyxJQUFJLENBQUM7SUE5Z0ZWLEtBK2dGdUMsR0FBR3ZmLFFBQVEsQ0FBQzs7Ozs7SUFLL0MsRUFBRXFmLFVBQVU7RUFDZCxDQUFDLElBQUksQ0FBTTtBQUNiO0FBQ0EsU0FBU0csbUJBQW1CdEksUUFBUSxFQUFFSCxVQUFVO0lBQzlDLElBQUk5WCxJQUF5QixFQUFjO1FBQ3pDLE1BQU1tTCxvQkFBb0JoQiw2QkFBNkI4TixTQUFTaFAsU0FBUyxDQUFDbkUsRUFBRSxFQUFFZ1QsV0FBV2hPLFVBQVU7UUFDbkdrVyxhQUFhN1U7SUFDZjtBQUNGO0FBRUEsSUFBSXFWLE9BQU9DLENBQUFBLFVBQVcsQ0FBQyxFQUNyQkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1QsR0FBS0MsQ0FBQUEsT0FBUTNDLENBQUFBO2dCQUNaLElBQUksQ0FBQ1MsTUFBTVQsUUFBUSxTQUFTO29CQUMxQjJDLEtBQUszQztvQkFDTDtnQkFDRjtnQkFDQSxNQUFNLEVBQ0puWixFQUFFLEVBQ0YyUCxlQUFlLEVBQ2Y0RyxZQUFZLEVBQ2IsR0FBRzRDLE9BQU9DLE9BQU87Z0JBQ2xCLE1BQU03VSxVQUFVcVg7Z0JBQ2hCLElBQUlyWCxRQUFRaVAsS0FBSyxLQUFLLGtCQUFrQjtvQkFDdENxSSxTQUFTZCxhQUFhO3dCQUNwQi9CLFdBQVd6VSxRQUFReVUsU0FBUztvQkFDOUI7Z0JBQ0Y7Z0JBQ0EsQ0FBRTRDLENBQUFBLFdBQVdwSSxLQUFLLEtBQUssTUFBSyxJQUFLdFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxzQ0FBc0NBLENBQVdBLEdBQUcsS0FBSztnQkFDbkpnZSxTQUFTaEI7Z0JBQ1RnQixTQUFTL0IscUJBQXFCO29CQUM1QjNaLGFBQWFIO29CQUNidVc7Z0JBQ0Y7Z0JBQ0EsTUFBTXdGLGdCQUFnQjtvQkFDcEJDLDBCQUEwQnpGLGlCQUFpQjtnQkFDN0M7Z0JBQ0EsTUFBTTBGLFVBQVU7b0JBQ2Q5YixhQUFhSDtvQkFDYitiO2dCQUNGO2dCQUNBLE1BQU0sRUFDSjVJLFFBQVEsRUFDUkgsVUFBVSxFQUNWekosUUFBUSxFQUNULEdBQUdvUyxRQUFRTyxlQUFlLENBQUNEO2dCQUM1QlIsbUJBQW1CdEksVUFBVUg7Z0JBQzdCNkksU0FBUzdCLGVBQWU7b0JBQ3RCN0c7b0JBQ0FIO29CQUNBckQ7b0JBQ0E0RztvQkFDQWhOO2dCQUNGO1lBQ0Y7QUFFQSxJQUFJNFMsUUFBUVIsQ0FBQUEsVUFBVyxJQUFNRyxDQUFBQSxPQUFRM0MsQ0FBQUE7Z0JBQ25DLElBQUlTLE1BQU1ULFFBQVEsb0JBQW9CO29CQUNwQ3dDLFFBQVFTLFFBQVE7Z0JBQ2xCO2dCQUNBLElBQUl4QyxNQUFNVCxRQUFRLGlCQUFpQjtvQkFDakN3QyxRQUFRVSxRQUFRLENBQUNsRCxPQUFPQyxPQUFPLENBQUNKLFNBQVMsQ0FBQ3ZZLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDekQ7Z0JBQ0EsSUFBSWtaLE1BQU1ULFFBQVEsWUFBWVMsTUFBTVQsUUFBUSxrQkFBa0I7b0JBQzVEd0MsUUFBUVcsT0FBTztnQkFDakI7Z0JBQ0FSLEtBQUszQztZQUNQO0FBRUEsTUFBTW9ELFNBQVM7SUFDYkMsYUFBYTtJQUNieEIsTUFBTTtBQUNSO0FBQ0EsTUFBTS9hLFVBQVU7SUFDZHdjLFNBQVM7UUFDUHpCLE1BQU07UUFDTjBCLFdBQVc7SUFDYjtJQUNBQyxPQUFPO1FBQ0wzQixNQUFNO0lBQ1I7QUFDRjtBQUNBLE1BQU00QixVQUFVO0lBQ2RKLGFBQWE7SUFDYkssYUFBYTtJQUNiQyxhQUFhO0FBQ2Y7QUFDQSxNQUFNQyxvQkFBb0IsQ0FBQyxFQUFFSCxRQUFRSixXQUFXLENBQUMsRUFBRSxFQUFFRCxPQUFPQyxXQUFXLENBQUMsQ0FBQztBQUN6RSxNQUFNUSxjQUFjO0lBQ2xCQyxPQUFPLENBQUMsUUFBUSxFQUFFRixrQkFBa0IsQ0FBQztJQUNyQ0csTUFBTSxDQUFDLFVBQVUsRUFBRUgsa0JBQWtCLFVBQVUsRUFBRUEsa0JBQWtCLENBQUM7SUFDcEUvQixNQUFNbUMsQ0FBQUE7UUFDSixNQUFNQyxTQUFTLENBQUMsRUFBRUQsU0FBUyxFQUFFLEVBQUVaLE9BQU92QixJQUFJLENBQUMsQ0FBQztRQUM1QyxPQUFPLENBQUMsVUFBVSxFQUFFb0MsT0FBTyxVQUFVLEVBQUVBLE9BQU8sQ0FBQztJQUNqRDtJQUNBWixhQUFhLENBQUMsVUFBVSxFQUFFTyxrQkFBa0IsQ0FBQztJQUM3QzFGLGFBQWEsQ0FBQyxPQUFPLEVBQUUwRixrQkFBa0IsUUFBUSxFQUFFQSxrQkFBa0IsU0FBUyxFQUFFQSxrQkFBa0IsQ0FBQztBQUNyRztBQUNBLE1BQU1NLFNBQVM1aUIsQ0FBQUEsU0FBVTBHLFVBQVUxRyxRQUFRbUcsVUFBVTBjLFlBQVksQ0FBQyxVQUFVLEVBQUU3aUIsT0FBT29HLENBQUMsQ0FBQyxJQUFJLEVBQUVwRyxPQUFPcUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUMxRyxNQUFNeWMsYUFBYTtJQUNqQkY7SUFDQXJDLE1BQU0sQ0FBQ3ZnQixRQUFRK2lCO1FBQ2IsTUFBTUMsWUFBWUosT0FBTzVpQjtRQUN6QixJQUFJLENBQUNnakIsV0FBVztZQUNkLE9BQU9IO1FBQ1Q7UUFDQSxJQUFJLENBQUNFLGFBQWE7WUFDaEIsT0FBT0M7UUFDVDtRQUNBLE9BQU8sQ0FBQyxFQUFFQSxVQUFVLE9BQU8sRUFBRXhkLFFBQVEwYyxLQUFLLENBQUMzQixJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BEO0FBQ0Y7QUFFQSxNQUFNLEVBQ0o2QixXQUFXLEVBQ1hDLFdBQVcsRUFDWixHQUFHRjtBQUNKLE1BQU1jLGdCQUFnQlosY0FBY0Q7QUFDcEMsTUFBTWMsd0JBQXdCO0FBQzlCLE1BQU1DLHFCQUFxQjtBQUMzQixJQUFJQyxrQkFBa0IsQ0FBQyxFQUNyQnBaLE9BQU8sRUFDUC9FLFdBQVcsRUFDWGdCLE1BQU0sRUFDUDtJQUNDLE1BQU1vZCxhQUFhcmMsU0FBU2dELFNBQVMvRTtJQUNyQyxJQUFJb2UsY0FBYyxHQUFHO1FBQ25CLE9BQU9qQjtJQUNUO0lBQ0EsSUFBSWlCLGNBQWNILHVCQUF1QjtRQUN2QyxPQUFPYjtJQUNUO0lBQ0EsTUFBTWlCLGFBQWFELGFBQWFIO0lBQ2hDLE1BQU1SLFdBQVdOLGNBQWNhLGdCQUFnQks7SUFDL0MsTUFBTUMsZUFBZXRkLFdBQVcsV0FBV3ljLFdBQVdTLHFCQUFxQlQ7SUFDM0UsT0FBT2MsT0FBT0QsYUFBYUUsT0FBTyxDQUFDO0FBQ3JDO0FBRUEsSUFBSUMseUJBQXlCLENBQUMsRUFDNUJ2WSxNQUFNLEVBQ05MLFNBQVMsRUFDVHlOLFVBQVUsRUFDVnpKLFFBQVEsRUFDUitCLGFBQWEsRUFDZDtJQUNDLE1BQU0sRUFDSnRHLFVBQVUsRUFDVkwsVUFBVSxFQUNYLEdBQUdxTztJQUNKLE1BQU1wVCxjQUFjK1Msa0JBQWtCL007SUFDdEMsTUFBTWxHLGNBQWNFLGNBQWMrRSxVQUFVLENBQUMvRSxZQUFZLEdBQUc7SUFDNUQsTUFBTXNULE9BQU92TyxVQUFVLENBQUNZLFVBQVVULFVBQVUsQ0FBQ2xGLFdBQVcsQ0FBQztJQUN6RCxNQUFNd2Usa0JBQWtCL0gseUJBQXlCO1FBQy9DelE7UUFDQUw7UUFDQVA7UUFDQXNHO1FBQ0FuSCxXQUFXekUsZUFBZXdUO1FBQzFCM0o7SUFDRjtJQUNBLE1BQU05TyxTQUFTeUcsU0FBU2tkLGlCQUFpQjdZLFVBQVV5SixNQUFNLENBQUN4QyxTQUFTLENBQUNELE1BQU07SUFDMUUsT0FBTzlSO0FBQ1Q7QUFFQSxJQUFJNGpCLGdCQUFnQixDQUFDLEVBQ25CclosVUFBVSxFQUNWdEUsTUFBTSxFQUNONGQsVUFBVSxFQUNWcEwsSUFBSSxFQUNKM0osUUFBUSxFQUNSZ1AsWUFBWSxFQUNiO0lBQ0MsSUFBSSxDQUFDK0YsV0FBV3pZLEVBQUUsSUFBSW5GLFdBQVcsUUFBUTtRQUN2QyxNQUFNNmQsdUJBQXVCbkksVUFBVTtZQUNyQ3BSO1lBQ0FZLFFBQVEyUztZQUNSN1ksYUFBYXdUO1lBQ2IzSjtZQUNBUyxvQkFBb0I7UUFDdEI7UUFDQSxPQUFPO1lBQ0xwRSxRQUFRMlk7WUFDUkMsd0JBQXdCO1FBQzFCO0lBQ0Y7SUFDQSxJQUFJRixXQUFXelksRUFBRSxDQUFDL0osSUFBSSxLQUFLLFdBQVc7UUFDcEMsT0FBTztZQUNMOEosUUFBUTBZO1lBQ1JFLHdCQUF3QjtRQUMxQjtJQUNGO0lBQ0EsTUFBTUMsa0JBQWtCO1FBQ3RCLEdBQUdILFVBQVU7UUFDYjVYLFdBQVdZO0lBQ2I7SUFDQSxPQUFPO1FBQ0wxQixRQUFRNlk7UUFDUkQsd0JBQXdCO0lBQzFCO0FBQ0Y7QUFFQSxNQUFNRSxpQkFBaUIsQ0FBQyxFQUN0QjlDLFFBQVEsRUFDUkMsUUFBUSxFQUNULEdBQUtDLENBQUFBLE9BQVEzQyxDQUFBQTtZQUNaLElBQUksQ0FBQ1MsTUFBTVQsUUFBUSxTQUFTO2dCQUMxQjJDLEtBQUszQztnQkFDTDtZQUNGO1lBQ0EsTUFBTXJHLFFBQVE4STtZQUNkLE1BQU1sYixTQUFTeVksT0FBT0MsT0FBTyxDQUFDMVksTUFBTTtZQUNwQyxJQUFJb1MsTUFBTVUsS0FBSyxLQUFLLGNBQWM7Z0JBQ2hDcUksU0FBU3BELFlBQVk7b0JBQ25CL1g7Z0JBQ0Y7Z0JBQ0E7WUFDRjtZQUNBLElBQUlvUyxNQUFNVSxLQUFLLEtBQUssUUFBUTtnQkFDMUI7WUFDRjtZQUNBLE1BQU1tTCxtQkFBbUI3TCxNQUFNVSxLQUFLLEtBQUssa0JBQWtCVixNQUFNNEYsU0FBUztZQUMxRSxDQUFDLENBQUNpRyxtQkFBbUJ6akIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxpRUFBaUVBLENBQVdBLEdBQUcsS0FBSztZQUNsSyxDQUFFaVYsQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLGNBQWNWLE1BQU1VLEtBQUssS0FBSyxjQUFhLElBQUt0WSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsc0JBQXNCLEVBQUVpVixNQUFNVSxLQUFLLENBQUMsQ0FBQyxJQUFJM1YsQ0FBV0EsR0FBRyxLQUFLO1lBQ3hMLE1BQU1zVixXQUFXTCxNQUFNSyxRQUFRO1lBQy9CLE1BQU1ILGFBQWFGLE1BQU1FLFVBQVU7WUFDbkMsTUFBTXpOLFlBQVl5TixXQUFXaE8sVUFBVSxDQUFDOE4sTUFBTUssUUFBUSxDQUFDNU4sU0FBUyxDQUFDdkYsRUFBRSxDQUFDO1lBQ3BFLE1BQU0sRUFDSjRGLE1BQU0sRUFDTjRZLHNCQUFzQixFQUN2QixHQUFHSCxjQUFjO2dCQUNoQjNkO2dCQUNBNGQsWUFBWXhMLE1BQU1sTixNQUFNO2dCQUN4QjBGLGVBQWV3SCxNQUFNeEgsYUFBYTtnQkFDbENpTixjQUFjekYsTUFBTXlGLFlBQVk7Z0JBQ2hDckYsTUFBTUosTUFBTUUsVUFBVSxDQUFDck8sVUFBVSxDQUFDbU8sTUFBTUssUUFBUSxDQUFDaFAsU0FBUyxDQUFDbkUsRUFBRSxDQUFDO2dCQUM5RHVKLFVBQVV1SixNQUFNdkosUUFBUTtnQkFDeEJ2RSxZQUFZOE4sTUFBTUUsVUFBVSxDQUFDaE8sVUFBVTtZQUN6QztZQUNBLE1BQU10RixjQUFjOGUseUJBQXlCN1ksa0JBQWtCQyxVQUFVO1lBQ3pFLE1BQU0zRixVQUFVdWUseUJBQXlCMVksY0FBY0YsVUFBVTtZQUNqRSxNQUFNcEcsU0FBUztnQkFDYkgsT0FBTzhULFNBQVM1TixTQUFTLENBQUNsRyxLQUFLO2dCQUMvQk8sYUFBYXVULFNBQVNoUCxTQUFTLENBQUNuRSxFQUFFO1lBQ3BDO1lBQ0EsTUFBTVMsU0FBUztnQkFDYk4sYUFBYW9GLFVBQVVULFVBQVUsQ0FBQzlFLEVBQUU7Z0JBQ3BDbEUsTUFBTXlKLFVBQVVULFVBQVUsQ0FBQ2hKLElBQUk7Z0JBQy9CMEQ7Z0JBQ0FrQjtnQkFDQXlRLE1BQU0yQixNQUFNeUQsWUFBWTtnQkFDeEI3VztnQkFDQU87WUFDRjtZQUNBLE1BQU0wWixzQkFBc0J3RSx1QkFBdUI7Z0JBQ2pEdlk7Z0JBQ0FMO2dCQUNBeU47Z0JBQ0F6SixVQUFVdUosTUFBTXZKLFFBQVE7Z0JBQ3hCK0IsZUFBZXdILE1BQU14SCxhQUFhO1lBQ3BDO1lBQ0EsTUFBTTBOLFlBQVk7Z0JBQ2hCN0YsVUFBVUwsTUFBTUssUUFBUTtnQkFDeEI3SCxlQUFld0gsTUFBTXhILGFBQWE7Z0JBQ2xDN0s7Z0JBQ0FtRjtZQUNGO1lBQ0EsTUFBTWdaLHNCQUFzQixDQUFDemQsVUFBVTJSLE1BQU1yTyxPQUFPLENBQUN1SyxNQUFNLENBQUN2VSxNQUFNLEVBQUVrZix3QkFBd0JwTyxRQUFROUssT0FBT1IsT0FBTztZQUNsSCxJQUFJLENBQUMyZSxxQkFBcUI7Z0JBQ3hCL0MsU0FBU2QsYUFBYTtvQkFDcEIvQjtnQkFDRjtnQkFDQTtZQUNGO1lBQ0EsTUFBTVUsZUFBZW1FLGdCQUFnQjtnQkFDbkNwWixTQUFTcU8sTUFBTXJPLE9BQU8sQ0FBQ3VLLE1BQU0sQ0FBQ3ZVLE1BQU07Z0JBQ3BDaUYsYUFBYWlhO2dCQUNialo7WUFDRjtZQUNBLE1BQU14QyxPQUFPO2dCQUNYeWI7Z0JBQ0FEO2dCQUNBVjtZQUNGO1lBQ0E2QyxTQUFTZixZQUFZNWM7UUFDdkI7QUFFQSxJQUFJMmdCLGtCQUFrQixJQUFPO1FBQzNCaGUsR0FBRzlFLE9BQU8raUIsV0FBVztRQUNyQmhlLEdBQUcvRSxPQUFPZ2pCLFdBQVc7SUFDdkI7QUFFQSxTQUFTQyx1QkFBdUIzZSxNQUFNO0lBQ3BDLE9BQU87UUFDTHBELFdBQVc7UUFDWEYsU0FBUztZQUNQa2lCLFNBQVM7WUFDVEMsU0FBUztRQUNYO1FBQ0FoaUIsSUFBSW1CLENBQUFBO1lBQ0YsSUFBSUEsTUFBTXdELE1BQU0sS0FBSzlGLFVBQVVzQyxNQUFNd0QsTUFBTSxLQUFLOUYsT0FBT29qQixRQUFRLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFDQTllO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBUytlLGtCQUFrQixFQUN6QkMsY0FBYyxFQUNmO0lBQ0MsU0FBU0M7UUFDUEQsZUFBZVI7SUFDakI7SUFDQSxNQUFNVSxZQUFZeGtCLG9EQUFPQSxDQUFDdWtCO0lBQzFCLE1BQU14aUIsVUFBVWtpQix1QkFBdUJPO0lBQ3ZDLElBQUlwaUIsU0FBU2Y7SUFDYixTQUFTb2pCO1FBQ1AsT0FBT3JpQixXQUFXZjtJQUNwQjtJQUNBLFNBQVNtRDtRQUNQLENBQUMsQ0FBQ2lnQixhQUFhdGtCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sc0RBQXNEQSxDQUFXQSxHQUFHLEtBQUs7UUFDakpWLFNBQVNYLFdBQVdULFFBQVE7WUFBQ2U7U0FBUTtJQUN2QztJQUNBLFNBQVMyaUI7UUFDUCxDQUFDRCxhQUFhdGtCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8saURBQWlEQSxDQUFXQSxHQUFHLEtBQUs7UUFDM0kwaEIsVUFBVUcsTUFBTTtRQUNoQnZpQjtRQUNBQSxTQUFTZjtJQUNYO0lBQ0EsT0FBTztRQUNMbUQ7UUFDQWtnQjtRQUNBRDtJQUNGO0FBQ0Y7QUFFQSxNQUFNRyxlQUFleEcsQ0FBQUEsU0FBVVMsTUFBTVQsUUFBUSxvQkFBb0JTLE1BQU1ULFFBQVEsbUJBQW1CUyxNQUFNVCxRQUFRO0FBQ2hILE1BQU15RyxpQkFBaUJDLENBQUFBO0lBQ3JCLE1BQU1DLFdBQVdWLGtCQUFrQjtRQUNqQ0MsZ0JBQWdCamIsQ0FBQUE7WUFDZHliLE1BQU1oRSxRQUFRLENBQUN0QixtQkFBbUI7Z0JBQ2hDblc7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPMFgsQ0FBQUEsT0FBUTNDLENBQUFBO1lBQ2IsSUFBSSxDQUFDMkcsU0FBU04sUUFBUSxNQUFNNUYsTUFBTVQsUUFBUSxvQkFBb0I7Z0JBQzVEMkcsU0FBU3ZnQixLQUFLO1lBQ2hCO1lBQ0EsSUFBSXVnQixTQUFTTixRQUFRLE1BQU1HLGFBQWF4RyxTQUFTO2dCQUMvQzJHLFNBQVNMLElBQUk7WUFDZjtZQUNBM0QsS0FBSzNDO1FBQ1A7QUFDRjtBQUVBLElBQUk0RyxzQkFBc0JDLENBQUFBO0lBQ3hCLElBQUlDLFlBQVk7SUFDaEIsSUFBSUMsWUFBWTtJQUNoQixNQUFNQyxZQUFZQyxXQUFXO1FBQzNCRixZQUFZO0lBQ2Q7SUFDQSxNQUFNemYsU0FBUy9FLENBQUFBO1FBQ2IsSUFBSXVrQixXQUFXO1lBLzNGbkIsS0FnNEYyQyxHQUFHaGtCLFFBQVEsaUVBQWlFLENBQU07WUFDdkg7UUFDRjtRQUNBLElBQUlpa0IsV0FBVztZQW40Rm5CLEtBbzRGMkMsR0FBR2prQixRQUFRLENBQUM7OztNQUdqRCxDQUFDLElBQUksQ0FBTTtZQUNYO1FBQ0Y7UUFDQWdrQixZQUFZO1FBQ1pELFNBQVN0a0I7UUFDVDJrQixhQUFhRjtJQUNmO0lBQ0ExZixPQUFPd2YsU0FBUyxHQUFHLElBQU1BO0lBQ3pCLE9BQU94ZjtBQUNUO0FBRUEsSUFBSTZmLGtCQUFrQjtJQUNwQixNQUFNQyxVQUFVLEVBQUU7SUFDbEIsTUFBTUMsVUFBVUMsQ0FBQUE7UUFDZCxNQUFNcGhCLFFBQVFraEIsUUFBUXZaLFNBQVMsQ0FBQ2QsQ0FBQUEsT0FBUUEsS0FBS3VhLE9BQU8sS0FBS0E7UUFDekQsQ0FBRXBoQixDQUFBQSxVQUFVLENBQUMsS0FBS25FLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMEJBQTBCQSxDQUFXQSxHQUFHLEtBQUs7UUFDeEgsTUFBTSxDQUFDNmlCLE1BQU0sR0FBR0gsUUFBUUksTUFBTSxDQUFDdGhCLE9BQU87UUFDdENxaEIsTUFBTUUsUUFBUTtJQUNoQjtJQUNBLE1BQU03ZixNQUFNN0QsQ0FBQUE7UUFDVixNQUFNdWpCLFVBQVVMLFdBQVcsSUFBTUksUUFBUUM7UUFDekMsTUFBTUMsUUFBUTtZQUNaRDtZQUNBRyxVQUFVMWpCO1FBQ1o7UUFDQXFqQixRQUFRaFcsSUFBSSxDQUFDbVc7SUFDZjtJQUNBLE1BQU03RixRQUFRO1FBQ1osSUFBSSxDQUFDMEYsUUFBUTNaLE1BQU0sRUFBRTtZQUNuQjtRQUNGO1FBQ0EsTUFBTWlhLFVBQVU7ZUFBSU47U0FBUTtRQUM1QkEsUUFBUTNaLE1BQU0sR0FBRztRQUNqQmlhLFFBQVF2akIsT0FBTyxDQUFDb2pCLENBQUFBO1lBQ2RMLGFBQWFLLE1BQU1ELE9BQU87WUFDMUJDLE1BQU1FLFFBQVE7UUFDaEI7SUFDRjtJQUNBLE9BQU87UUFDTDdmO1FBQ0E4WjtJQUNGO0FBQ0Y7QUFFQSxNQUFNaUcsb0JBQW9CLENBQUN6USxPQUFPQztJQUNoQyxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxNQUFNelEsV0FBVyxLQUFLMFEsT0FBTzFRLFdBQVcsSUFBSXlRLE1BQU1oUixLQUFLLEtBQUtpUixPQUFPalIsS0FBSztBQUNqRjtBQUNBLE1BQU0waEIsaUJBQWlCLENBQUMxUSxPQUFPQztJQUM3QixJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJRCxTQUFTLFFBQVFDLFVBQVUsTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxNQUFNbFEsV0FBVyxLQUFLbVEsT0FBT25RLFdBQVcsSUFBSWtRLE1BQU16USxXQUFXLEtBQUswUSxPQUFPMVEsV0FBVztBQUM3RjtBQUNBLE1BQU1vaEIsa0JBQWtCLENBQUMzUSxPQUFPQztJQUM5QixJQUFJRCxVQUFVQyxRQUFRO1FBQ3BCLE9BQU87SUFDVDtJQUNBLE1BQU0yUSxtQkFBbUI1USxNQUFNOUssU0FBUyxDQUFDdkYsRUFBRSxLQUFLc1EsT0FBTy9LLFNBQVMsQ0FBQ3ZGLEVBQUUsSUFBSXFRLE1BQU05SyxTQUFTLENBQUMzRixXQUFXLEtBQUswUSxPQUFPL0ssU0FBUyxDQUFDM0YsV0FBVyxJQUFJeVEsTUFBTTlLLFNBQVMsQ0FBQ3pKLElBQUksS0FBS3dVLE9BQU8vSyxTQUFTLENBQUN6SixJQUFJLElBQUl1VSxNQUFNOUssU0FBUyxDQUFDbEcsS0FBSyxLQUFLaVIsT0FBTy9LLFNBQVMsQ0FBQ2xHLEtBQUs7SUFDek8sTUFBTTZoQixtQkFBbUI3USxNQUFNbE0sU0FBUyxDQUFDbkUsRUFBRSxLQUFLc1EsT0FBT25NLFNBQVMsQ0FBQ25FLEVBQUUsSUFBSXFRLE1BQU1sTSxTQUFTLENBQUNySSxJQUFJLEtBQUt3VSxPQUFPbk0sU0FBUyxDQUFDckksSUFBSTtJQUNySCxPQUFPbWxCLG9CQUFvQkM7QUFDN0I7QUFFQSxNQUFNQyxjQUFjLENBQUNwSyxLQUFLN1o7SUFDeEJxQztJQUNBckM7SUFDQThaO0FBQ0Y7QUFDQSxNQUFNb0ssZUFBZSxDQUFDak8sVUFBVWhDLE9BQVU7UUFDeENoUixhQUFhZ1QsU0FBUzVOLFNBQVMsQ0FBQ3ZGLEVBQUU7UUFDbENsRSxNQUFNcVgsU0FBU2hQLFNBQVMsQ0FBQ3JJLElBQUk7UUFDN0IwRCxRQUFRO1lBQ05JLGFBQWF1VCxTQUFTaFAsU0FBUyxDQUFDbkUsRUFBRTtZQUNsQ1gsT0FBTzhULFNBQVM1TixTQUFTLENBQUNsRyxLQUFLO1FBQ2pDO1FBQ0E4UjtJQUNGO0FBQ0EsU0FBU3FQLFFBQVFhLFNBQVMsRUFBRUMsSUFBSSxFQUFFdEIsUUFBUSxFQUFFdUIsaUJBQWlCO0lBQzNELElBQUksQ0FBQ0YsV0FBVztRQUNkckIsU0FBU3VCLGtCQUFrQkQ7UUFDM0I7SUFDRjtJQUNBLE1BQU1FLGFBQWF6QixvQkFBb0JDO0lBQ3ZDLE1BQU15QixXQUFXO1FBQ2Z6QixVQUFVd0I7SUFDWjtJQUNBSCxVQUFVQyxNQUFNRztJQUNoQixJQUFJLENBQUNELFdBQVd2QixTQUFTLElBQUk7UUFDM0JELFNBQVN1QixrQkFBa0JEO0lBQzdCO0FBQ0Y7QUFDQSxJQUFJSSxlQUFlLENBQUNDLGVBQWUzQjtJQUNqQyxNQUFNNEIsZUFBZXRCO0lBQ3JCLElBQUlsRSxXQUFXO0lBQ2YsTUFBTXlGLGdCQUFnQixDQUFDMWhCLGFBQWFnUjtRQUNsQyxDQUFDLENBQUNpTCxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNEVBQTRFQSxDQUFXQSxHQUFHLEtBQUs7UUFDcktzakIsWUFBWSxtQkFBbUI7WUFDN0IsTUFBTWprQixLQUFLeWtCLGdCQUFnQkcsZUFBZTtZQUMxQyxJQUFJNWtCLElBQUk7Z0JBQ04sTUFBTWlLLFNBQVM7b0JBQ2JoSDtvQkFDQWdSO2dCQUNGO2dCQUNBalUsR0FBR2lLO1lBQ0w7UUFDRjtJQUNGO0lBQ0EsTUFBTTRhLGNBQWMsQ0FBQzVPLFVBQVVoQztRQUM3QixDQUFDLENBQUNpTCxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOEVBQThFQSxDQUFXQSxHQUFHLEtBQUs7UUFDdktzakIsWUFBWSxxQkFBcUI7WUFDL0IsTUFBTWprQixLQUFLeWtCLGdCQUFnQkssaUJBQWlCO1lBQzVDLElBQUk5a0IsSUFBSTtnQkFDTkEsR0FBR2trQixhQUFhak8sVUFBVWhDO1lBQzVCO1FBQ0Y7SUFDRjtJQUNBLE1BQU01UixRQUFRLENBQUM0VCxVQUFVaEM7UUFDdkIsQ0FBQyxDQUFDaUwsV0FBV2xoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDhFQUE4RUEsQ0FBV0EsR0FBRyxLQUFLO1FBQ3ZLLE1BQU15akIsT0FBT0YsYUFBYWpPLFVBQVVoQztRQUNwQ2lMLFdBQVc7WUFDVGpMO1lBQ0E4USxjQUFjOU87WUFDZCtPLGNBQWNaLEtBQUs5aEIsTUFBTTtZQUN6QjJpQixhQUFhO1FBQ2Y7UUFDQVAsYUFBYTdnQixHQUFHLENBQUM7WUFDZm9nQixZQUFZLGVBQWUsSUFBTVgsUUFBUW1CLGdCQUFnQnJpQixXQUFXLEVBQUVnaUIsTUFBTXRCLFVBQVVyZixPQUFPckIsV0FBVztRQUMxRztJQUNGO0lBQ0EsTUFBTWUsU0FBUyxDQUFDOFMsVUFBVXZOO1FBQ3hCLE1BQU10RixXQUFXcUYsa0JBQWtCQztRQUNuQyxNQUFNM0YsVUFBVTZGLGNBQWNGO1FBQzlCLENBQUN3VyxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8saUVBQWlFQSxDQUFXQSxHQUFHLEtBQUs7UUFDekosTUFBTXVrQixxQkFBcUIsQ0FBQ3BCLGdCQUFnQjdOLFVBQVVpSixTQUFTNkYsWUFBWTtRQUMzRSxJQUFJRyxvQkFBb0I7WUFDdEJoRyxTQUFTNkYsWUFBWSxHQUFHOU87UUFDMUI7UUFDQSxNQUFNa1AscUJBQXFCLENBQUN2QixrQkFBa0IxRSxTQUFTOEYsWUFBWSxFQUFFNWhCO1FBQ3JFLElBQUkraEIsb0JBQW9CO1lBQ3RCakcsU0FBUzhGLFlBQVksR0FBRzVoQjtRQUMxQjtRQUNBLE1BQU1naUIscUJBQXFCLENBQUN2QixlQUFlM0UsU0FBUytGLFdBQVcsRUFBRWxpQjtRQUNqRSxJQUFJcWlCLG9CQUFvQjtZQUN0QmxHLFNBQVMrRixXQUFXLEdBQUdsaUI7UUFDekI7UUFDQSxJQUFJLENBQUNtaUIsc0JBQXNCLENBQUNDLHNCQUFzQixDQUFDQyxvQkFBb0I7WUFDckU7UUFDRjtRQUNBLE1BQU1oQixPQUFPO1lBQ1gsR0FBR0YsYUFBYWpPLFVBQVVpSixTQUFTakwsSUFBSSxDQUFDO1lBQ3hDbFI7WUFDQVAsYUFBYVk7UUFDZjtRQUNBc2hCLGFBQWE3Z0IsR0FBRyxDQUFDO1lBQ2ZvZ0IsWUFBWSxnQkFBZ0IsSUFBTVgsUUFBUW1CLGdCQUFnQnZoQixZQUFZLEVBQUVraEIsTUFBTXRCLFVBQVVyZixPQUFPUCxZQUFZO1FBQzdHO0lBQ0Y7SUFDQSxNQUFNeWEsUUFBUTtRQUNaLENBQUN1QixXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOENBQThDQSxDQUFXQSxHQUFHLEtBQUs7UUFDdEkrakIsYUFBYS9HLEtBQUs7SUFDcEI7SUFDQSxNQUFNRyxPQUFPdmEsQ0FBQUE7UUFDWCxDQUFDMmIsV0FBV2xoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGlFQUFpRUEsQ0FBV0EsR0FBRyxLQUFLO1FBQ3pKdWUsV0FBVztRQUNYK0UsWUFBWSxhQUFhLElBQU1YLFFBQVFtQixnQkFBZ0JuaEIsU0FBUyxFQUFFQyxRQUFRdWYsVUFBVXJmLE9BQU9ILFNBQVM7SUFDdEc7SUFDQSxNQUFNK2hCLFFBQVE7UUFDWixJQUFJLENBQUNuRyxVQUFVO1lBQ2I7UUFDRjtRQUNBLE1BQU0zYixTQUFTO1lBQ2IsR0FBRzJnQixhQUFhaEYsU0FBUzZGLFlBQVksRUFBRTdGLFNBQVNqTCxJQUFJLENBQUM7WUFDckRsUixTQUFTO1lBQ1RQLGFBQWE7WUFDYmdCLFFBQVE7UUFDVjtRQUNBc2EsS0FBS3ZhO0lBQ1A7SUFDQSxPQUFPO1FBQ0xvaEI7UUFDQUU7UUFDQXhpQjtRQUNBYztRQUNBd2E7UUFDQUc7UUFDQXVIO0lBQ0Y7QUFDRjtBQUVBLElBQUlDLGFBQWEsQ0FBQ2IsZUFBZTNCO0lBQy9CLE1BQU15QyxZQUFZZixhQUFhQyxlQUFlM0I7SUFDOUMsT0FBT0gsQ0FBQUEsUUFBUy9ELENBQUFBLE9BQVEzQyxDQUFBQTtnQkFDdEIsSUFBSVMsTUFBTVQsUUFBUSwyQkFBMkI7b0JBQzNDc0osVUFBVVosYUFBYSxDQUFDMUksT0FBT0MsT0FBTyxDQUFDalosV0FBVyxFQUFFZ1osT0FBT0MsT0FBTyxDQUFDN0MsWUFBWTtvQkFDL0U7Z0JBQ0Y7Z0JBQ0EsSUFBSXFELE1BQU1ULFFBQVEsb0JBQW9CO29CQUNwQyxNQUFNaEcsV0FBV2dHLE9BQU9DLE9BQU8sQ0FBQ2pHLFFBQVE7b0JBQ3hDc1AsVUFBVVYsV0FBVyxDQUFDNU8sVUFBVWdHLE9BQU9DLE9BQU8sQ0FBQzdDLFlBQVk7b0JBQzNEdUYsS0FBSzNDO29CQUNMc0osVUFBVWxqQixLQUFLLENBQUM0VCxVQUFVZ0csT0FBT0MsT0FBTyxDQUFDN0MsWUFBWTtvQkFDckQ7Z0JBQ0Y7Z0JBQ0EsSUFBSXFELE1BQU1ULFFBQVEsa0JBQWtCO29CQUNsQyxNQUFNMVksU0FBUzBZLE9BQU9DLE9BQU8sQ0FBQ0osU0FBUyxDQUFDdlksTUFBTTtvQkFDOUNnaUIsVUFBVTVILEtBQUs7b0JBQ2ZpQixLQUFLM0M7b0JBQ0xzSixVQUFVekgsSUFBSSxDQUFDdmE7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0FxYixLQUFLM0M7Z0JBQ0wsSUFBSVMsTUFBTVQsUUFBUSxVQUFVO29CQUMxQnNKLFVBQVVGLEtBQUs7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0EsTUFBTXpQLFFBQVErTSxNQUFNakUsUUFBUTtnQkFDNUIsSUFBSTlJLE1BQU1VLEtBQUssS0FBSyxZQUFZO29CQUM5QmlQLFVBQVVwaUIsTUFBTSxDQUFDeVMsTUFBTUssUUFBUSxFQUFFTCxNQUFNbE4sTUFBTTtnQkFDL0M7WUFDRjtBQUNGO0FBRUEsTUFBTThjLGdDQUFnQzdDLENBQUFBLFFBQVMvRCxDQUFBQSxPQUFRM0MsQ0FBQUE7WUFDckQsSUFBSSxDQUFDUyxNQUFNVCxRQUFRLDRCQUE0QjtnQkFDN0MyQyxLQUFLM0M7Z0JBQ0w7WUFDRjtZQUNBLE1BQU1yRyxRQUFRK00sTUFBTWpFLFFBQVE7WUFDNUIsQ0FBRTlJLENBQUFBLE1BQU1VLEtBQUssS0FBSyxnQkFBZSxJQUFLdFksS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw4REFBOERBLENBQVdBLEdBQUcsS0FBSztZQUNoTGdpQixNQUFNaEUsUUFBUSxDQUFDZCxhQUFhO2dCQUMxQi9CLFdBQVdsRyxNQUFNa0csU0FBUztZQUM1QjtRQUNGO0FBRUEsTUFBTTJKLHVDQUF1QzlDLENBQUFBO0lBQzNDLElBQUkxaUIsU0FBUztJQUNiLElBQUl5bEIsVUFBVTtJQUNkLFNBQVNDO1FBQ1AsSUFBSUQsU0FBUztZQUNYRSxxQkFBcUJGO1lBQ3JCQSxVQUFVO1FBQ1o7UUFDQSxJQUFJemxCLFFBQVE7WUFDVkE7WUFDQUEsU0FBUztRQUNYO0lBQ0Y7SUFDQSxPQUFPMmUsQ0FBQUEsT0FBUTNDLENBQUFBO1lBQ2IsSUFBSVMsTUFBTVQsUUFBUSxZQUFZUyxNQUFNVCxRQUFRLG9CQUFvQlMsTUFBTVQsUUFBUSw0QkFBNEI7Z0JBQ3hHMEo7WUFDRjtZQUNBL0csS0FBSzNDO1lBQ0wsSUFBSSxDQUFDUyxNQUFNVCxRQUFRLGlCQUFpQjtnQkFDbEM7WUFDRjtZQUNBLE1BQU1yYyxVQUFVO2dCQUNkRyxXQUFXO2dCQUNYRixTQUFTO29CQUNQbWlCLFNBQVM7b0JBQ1RELFNBQVM7b0JBQ1Q4RCxNQUFNO2dCQUNSO2dCQUNBN2xCLElBQUksU0FBUzhsQjtvQkFDWCxNQUFNbFEsUUFBUStNLE1BQU1qRSxRQUFRO29CQUM1QixJQUFJOUksTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjt3QkFDcENxTSxNQUFNaEUsUUFBUSxDQUFDWjtvQkFDakI7Z0JBQ0Y7WUFDRjtZQUNBMkgsVUFBVUssc0JBQXNCO2dCQUM5QkwsVUFBVTtnQkFDVnpsQixTQUFTWCxXQUFXVCxRQUFRO29CQUFDZTtpQkFBUTtZQUN2QztRQUNGO0FBQ0Y7QUFFQSxJQUFJb21CLDBCQUEwQnZILENBQUFBLFVBQVcsSUFBTUcsQ0FBQUEsT0FBUTNDLENBQUFBO2dCQUNyRCxJQUFJUyxNQUFNVCxRQUFRLG9CQUFvQlMsTUFBTVQsUUFBUSxZQUFZUyxNQUFNVCxRQUFRLGlCQUFpQjtvQkFDN0Z3QyxRQUFRd0gsY0FBYztnQkFDeEI7Z0JBQ0FySCxLQUFLM0M7WUFDUDtBQUVBLElBQUlpSyxRQUFRekgsQ0FBQUE7SUFDVixJQUFJMEgsYUFBYTtJQUNqQixPQUFPLElBQU12SCxDQUFBQSxPQUFRM0MsQ0FBQUE7Z0JBQ25CLElBQUlTLE1BQU1ULFFBQVEsb0JBQW9CO29CQUNwQ2tLLGFBQWE7b0JBQ2IxSCxRQUFRMkgsY0FBYyxDQUFDbkssT0FBT0MsT0FBTyxDQUFDakcsUUFBUSxDQUFDNU4sU0FBUyxDQUFDdkYsRUFBRTtvQkFDM0Q4YixLQUFLM0M7b0JBQ0x3QyxRQUFRNEgsdUJBQXVCO29CQUMvQjtnQkFDRjtnQkFDQXpILEtBQUszQztnQkFDTCxJQUFJLENBQUNrSyxZQUFZO29CQUNmO2dCQUNGO2dCQUNBLElBQUl6SixNQUFNVCxRQUFRLFVBQVU7b0JBQzFCa0ssYUFBYTtvQkFDYjFILFFBQVE0SCx1QkFBdUI7b0JBQy9CO2dCQUNGO2dCQUNBLElBQUkzSixNQUFNVCxRQUFRLGtCQUFrQjtvQkFDbENrSyxhQUFhO29CQUNiLE1BQU01aUIsU0FBUzBZLE9BQU9DLE9BQU8sQ0FBQ0osU0FBUyxDQUFDdlksTUFBTTtvQkFDOUMsSUFBSUEsT0FBT1IsT0FBTyxFQUFFO3dCQUNsQjBiLFFBQVE2SCxjQUFjLENBQUMvaUIsT0FBT04sV0FBVyxFQUFFTSxPQUFPUixPQUFPLENBQUNFLFdBQVc7b0JBQ3ZFO29CQUNBd2IsUUFBUTRILHVCQUF1QjtnQkFDakM7WUFDRjtBQUNGO0FBRUEsTUFBTUUsYUFBYXRLLENBQUFBLFNBQVVTLE1BQU1ULFFBQVEsb0JBQW9CUyxNQUFNVCxRQUFRLG1CQUFtQlMsTUFBTVQsUUFBUTtBQUM5RyxJQUFJdUssYUFBYUMsQ0FBQUEsZUFBZ0I5RCxDQUFBQSxRQUFTL0QsQ0FBQUEsT0FBUTNDLENBQUFBO2dCQUNoRCxJQUFJc0ssV0FBV3RLLFNBQVM7b0JBQ3RCd0ssYUFBYWxFLElBQUk7b0JBQ2pCM0QsS0FBSzNDO29CQUNMO2dCQUNGO2dCQUNBLElBQUlTLE1BQU1ULFFBQVEsb0JBQW9CO29CQUNwQzJDLEtBQUszQztvQkFDTCxNQUFNckcsUUFBUStNLE1BQU1qRSxRQUFRO29CQUM1QixDQUFFOUksQ0FBQUEsTUFBTVUsS0FBSyxLQUFLLFVBQVMsSUFBS3RZLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8seURBQXlEQSxDQUFXQSxHQUFHLEtBQUs7b0JBQ3JLOGxCLGFBQWFwa0IsS0FBSyxDQUFDdVQ7b0JBQ25CO2dCQUNGO2dCQUNBZ0osS0FBSzNDO2dCQUNMd0ssYUFBYTNnQixNQUFNLENBQUM2YyxNQUFNakUsUUFBUTtZQUNwQztBQUVBLE1BQU1nSSxjQUFjL0QsQ0FBQUEsUUFBUy9ELENBQUFBLE9BQVEzQyxDQUFBQTtZQUNuQzJDLEtBQUszQztZQUNMLElBQUksQ0FBQ1MsTUFBTVQsUUFBUSwyQkFBMkI7Z0JBQzVDO1lBQ0Y7WUFDQSxNQUFNMEssa0JBQWtCaEUsTUFBTWpFLFFBQVE7WUFDdEMsSUFBSWlJLGdCQUFnQnJRLEtBQUssS0FBSyxnQkFBZ0I7Z0JBQzVDO1lBQ0Y7WUFDQSxJQUFJcVEsZ0JBQWdCbkwsU0FBUyxFQUFFO2dCQUM3QjtZQUNGO1lBQ0FtSCxNQUFNaEUsUUFBUSxDQUFDYixLQUFLO2dCQUNsQnRhLFFBQVFtakIsZ0JBQWdCbmpCLE1BQU07WUFDaEM7UUFDRjtBQUVBLE1BQU1vakIsbUJBQW1CNW9CLE1BQXFILEdBQUdhLENBRS9JLEdBQUc5QiwwQ0FBT0E7QUFDWixJQUFJSCxjQUFjLENBQUMsRUFDakJtcUIsZ0JBQWdCLEVBQ2hCQyxZQUFZLEVBQ1pDLFlBQVksRUFDWnhDLGFBQWEsRUFDYjNCLFFBQVEsRUFDUjJELFlBQVksRUFDYixHQUFLNXBCLGtEQUFhQSxDQUFDbWYsU0FBUzRLLGlCQUFpQjlwQixzREFBZUEsQ0FBQ21pQixNQUFNZ0ksZUFBZWpCLHdCQUF3QmUsbUJBQW1CdkksS0FBS3VJLG1CQUFtQnZGLGdCQUFnQmdFLCtCQUErQkMsc0NBQXNDaUIsYUFBYUYsV0FBV0MsZUFBZS9ELGdCQUFnQndELE1BQU1jLGVBQWUxQixXQUFXYixlQUFlM0I7QUFFalYsTUFBTW9FLFVBQVUsSUFBTztRQUNyQjVNLFdBQVcsQ0FBQztRQUNaWSxVQUFVLENBQUM7UUFDWFQsVUFBVSxDQUFDO0lBQ2I7QUFDQSxTQUFTME0sZ0JBQWdCLEVBQ3ZCQyxRQUFRLEVBQ1JubUIsU0FBUyxFQUNWO0lBQ0MsSUFBSW9tQixVQUFVSDtJQUNkLElBQUl4QixVQUFVO0lBQ2QsTUFBTTRCLFVBQVU7UUFDZCxJQUFJNUIsU0FBUztZQUNYO1FBQ0Y7UUFDQXprQixVQUFVK2Isa0JBQWtCO1FBQzVCMEksVUFBVUssc0JBQXNCO1lBQzlCTCxVQUFVO1lBQ1ZyakI7WUFDQSxNQUFNLEVBQ0ppWSxTQUFTLEVBQ1RZLFFBQVEsRUFDUlQsUUFBUSxFQUNULEdBQUc0TTtZQUNKLE1BQU16UyxRQUFRNU0sT0FBT21XLElBQUksQ0FBQzdELFdBQVczYSxHQUFHLENBQUNtRCxDQUFBQSxLQUFNc2tCLFNBQVMvZSxTQUFTLENBQUNrZixPQUFPLENBQUN6a0IsSUFBSTBrQixZQUFZLENBQUM5akIsU0FBUzRFLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFWCxVQUFVLENBQUN6RixLQUFLLEdBQUdxRyxFQUFFWixVQUFVLENBQUN6RixLQUFLO1lBQzFKLE1BQU0yTyxVQUFVOUksT0FBT21XLElBQUksQ0FBQzFELFVBQVU5YSxHQUFHLENBQUNtRCxDQUFBQTtnQkFDeEMsTUFBTTBnQixRQUFRNEQsU0FBU25nQixTQUFTLENBQUNzZ0IsT0FBTyxDQUFDemtCO2dCQUN6QyxNQUFNZ0QsU0FBUzBkLE1BQU12aUIsU0FBUyxDQUFDd21CLHNCQUFzQjtnQkFDckQsT0FBTztvQkFDTC9rQixhQUFhSTtvQkFDYmdEO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNdkMsU0FBUztnQkFDYitXLFdBQVcxRjtnQkFDWHNHLFVBQVVsVCxPQUFPbVcsSUFBSSxDQUFDakQ7Z0JBQ3RCVCxVQUFVM0o7WUFDWjtZQUNBdVcsVUFBVUg7WUFDVnBOO1lBQ0E3WSxVQUFVeW1CLE9BQU8sQ0FBQ25rQjtRQUNwQjtJQUNGO0lBQ0EsTUFBTU0sTUFBTTJmLENBQUFBO1FBQ1YsTUFBTTFnQixLQUFLMGdCLE1BQU01YixVQUFVLENBQUM5RSxFQUFFO1FBQzlCdWtCLFFBQVEvTSxTQUFTLENBQUN4WCxHQUFHLEdBQUcwZ0I7UUFDeEI2RCxRQUFRNU0sUUFBUSxDQUFDK0ksTUFBTTViLFVBQVUsQ0FBQ2xGLFdBQVcsQ0FBQyxHQUFHO1FBQ2pELElBQUkya0IsUUFBUW5NLFFBQVEsQ0FBQ3BZLEdBQUcsRUFBRTtZQUN4QixPQUFPdWtCLFFBQVFuTSxRQUFRLENBQUNwWSxHQUFHO1FBQzdCO1FBQ0F3a0I7SUFDRjtJQUNBLE1BQU14ZSxTQUFTMGEsQ0FBQUE7UUFDYixNQUFNNWIsYUFBYTRiLE1BQU01YixVQUFVO1FBQ25DeWYsUUFBUW5NLFFBQVEsQ0FBQ3RULFdBQVc5RSxFQUFFLENBQUMsR0FBRztRQUNsQ3VrQixRQUFRNU0sUUFBUSxDQUFDN1MsV0FBV2xGLFdBQVcsQ0FBQyxHQUFHO1FBQzNDLElBQUkya0IsUUFBUS9NLFNBQVMsQ0FBQzFTLFdBQVc5RSxFQUFFLENBQUMsRUFBRTtZQUNwQyxPQUFPdWtCLFFBQVEvTSxTQUFTLENBQUMxUyxXQUFXOUUsRUFBRSxDQUFDO1FBQ3pDO1FBQ0F3a0I7SUFDRjtJQUNBLE1BQU0vRSxPQUFPO1FBQ1gsSUFBSSxDQUFDbUQsU0FBUztZQUNaO1FBQ0Y7UUFDQUUscUJBQXFCRjtRQUNyQkEsVUFBVTtRQUNWMkIsVUFBVUg7SUFDWjtJQUNBLE9BQU87UUFDTHJqQjtRQUNBaUY7UUFDQXlaO0lBQ0Y7QUFDRjtBQUVBLElBQUlvRixlQUFlLENBQUMsRUFDbEJDLFlBQVksRUFDWkMsV0FBVyxFQUNYcmlCLE1BQU0sRUFDTkQsS0FBSyxFQUNOO0lBQ0MsTUFBTXVQLFlBQVk5USxTQUFTO1FBQ3pCTCxHQUFHa2tCO1FBQ0hqa0IsR0FBR2drQjtJQUNMLEdBQUc7UUFDRGprQixHQUFHNEI7UUFDSDNCLEdBQUc0QjtJQUNMO0lBQ0EsTUFBTXNpQixvQkFBb0I7UUFDeEJua0IsR0FBR2EsS0FBS1csR0FBRyxDQUFDLEdBQUcyUCxVQUFVblIsQ0FBQztRQUMxQkMsR0FBR1ksS0FBS1csR0FBRyxDQUFDLEdBQUcyUCxVQUFVbFIsQ0FBQztJQUM1QjtJQUNBLE9BQU9ra0I7QUFDVDtBQUVBLElBQUlDLHFCQUFxQjtJQUN2QixNQUFNQyxNQUFNL0YsU0FBU2dHLGVBQWU7SUFDcEMsQ0FBQ0QsTUFBTWhxQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLDBDQUEwQ0EsQ0FBV0EsR0FBRyxLQUFLO0lBQzdILE9BQU9xbkI7QUFDVDtBQUVBLElBQUlFLHFCQUFxQjtJQUN2QixNQUFNRixNQUFNRDtJQUNaLE1BQU1qVCxZQUFZNlMsYUFBYTtRQUM3QkMsY0FBY0ksSUFBSUosWUFBWTtRQUM5QkMsYUFBYUcsSUFBSUgsV0FBVztRQUM1QnRpQixPQUFPeWlCLElBQUlHLFdBQVc7UUFDdEIzaUIsUUFBUXdpQixJQUFJSSxZQUFZO0lBQzFCO0lBQ0EsT0FBT3RUO0FBQ1Q7QUFFQSxJQUFJdVQsY0FBYztJQUNoQixNQUFNdmlCLFNBQVM2YjtJQUNmLE1BQU03TSxZQUFZb1Q7SUFDbEIsTUFBTWhqQixNQUFNWSxPQUFPbEMsQ0FBQztJQUNwQixNQUFNMEIsT0FBT1EsT0FBT25DLENBQUM7SUFDckIsTUFBTXFrQixNQUFNRDtJQUNaLE1BQU14aUIsUUFBUXlpQixJQUFJRyxXQUFXO0lBQzdCLE1BQU0zaUIsU0FBU3dpQixJQUFJSSxZQUFZO0lBQy9CLE1BQU1oakIsUUFBUUUsT0FBT0M7SUFDckIsTUFBTUYsU0FBU0gsTUFBTU07SUFDckIsTUFBTVIsUUFBUTNILHNEQUFPQSxDQUFDO1FBQ3BCNkg7UUFDQUk7UUFDQUY7UUFDQUM7SUFDRjtJQUNBLE1BQU1nSCxXQUFXO1FBQ2ZySDtRQUNBYyxRQUFRO1lBQ051QixTQUFTdkI7WUFDVHlCLFNBQVN6QjtZQUNUWCxLQUFLMlA7WUFDTC9PLE1BQU07Z0JBQ0ozSCxPQUFPc0Y7Z0JBQ1BzQyxjQUFjdEM7WUFDaEI7UUFDRjtJQUNGO0lBQ0EsT0FBTzJJO0FBQ1Q7QUFFQSxJQUFJaWMsb0JBQW9CLENBQUMsRUFDdkJyUyxRQUFRLEVBQ1I0SSxhQUFhLEVBQ2J1SSxRQUFRLEVBQ1Q7SUFDQy9rQjtJQUNBLE1BQU1nSyxXQUFXZ2M7SUFDakIsTUFBTUUsZUFBZWxjLFNBQVN2RyxNQUFNLENBQUN5QixPQUFPO0lBQzVDLE1BQU15TyxPQUFPQyxTQUFTaFAsU0FBUztJQUMvQixNQUFNUSxhQUFhMmYsU0FBU25nQixTQUFTLENBQUN1aEIsWUFBWSxDQUFDeFMsS0FBS3BYLElBQUksRUFBRWUsR0FBRyxDQUFDNmpCLENBQUFBLFFBQVNBLE1BQU12aUIsU0FBUyxDQUFDd25CLDBCQUEwQixDQUFDRixjQUFjMUo7SUFDcEksTUFBTS9XLGFBQWFzZixTQUFTL2UsU0FBUyxDQUFDbWdCLFlBQVksQ0FBQ3ZTLFNBQVM1TixTQUFTLENBQUN6SixJQUFJLEVBQUVlLEdBQUcsQ0FBQzZqQixDQUFBQSxRQUFTQSxNQUFNZ0UsWUFBWSxDQUFDZTtJQUM1RyxNQUFNelMsYUFBYTtRQUNqQmhPLFlBQVlELGVBQWVDO1FBQzNCTCxZQUFZRCxlQUFlQztJQUM3QjtJQUNBcVM7SUFDQSxNQUFNdlcsU0FBUztRQUNidVM7UUFDQUc7UUFDQTVKO0lBQ0Y7SUFDQSxPQUFPOUk7QUFDVDtBQUVBLFNBQVNtbEIsb0JBQW9CdEIsUUFBUSxFQUFFbEksUUFBUSxFQUFFc0UsS0FBSztJQUNwRCxJQUFJQSxNQUFNNWIsVUFBVSxDQUFDOUUsRUFBRSxLQUFLb2MsU0FBU3BjLEVBQUUsRUFBRTtRQUN2QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJMGdCLE1BQU01YixVQUFVLENBQUNoSixJQUFJLEtBQUtzZ0IsU0FBU3RnQixJQUFJLEVBQUU7UUFDM0MsT0FBTztJQUNUO0lBQ0EsTUFBTW9YLE9BQU9vUixTQUFTbmdCLFNBQVMsQ0FBQ3NnQixPQUFPLENBQUMvRCxNQUFNNWIsVUFBVSxDQUFDbEYsV0FBVztJQUNwRSxJQUFJc1QsS0FBS3BPLFVBQVUsQ0FBQ3FNLElBQUksS0FBSyxXQUFXO1FBdjZHMUMsS0F3Nkd5QyxHQUFHbFYsUUFBUSxDQUFDOzJEQUNNLEVBQUV5a0IsTUFBTTViLFVBQVUsQ0FBQzlFLEVBQUUsQ0FBQzs7OztJQUk3RSxDQUFDLElBQUksQ0FBTTtRQUNYLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLElBQUk2bEIseUJBQXlCLENBQUN2QixVQUFVbm1CO0lBQ3RDLElBQUkybkIsYUFBYTtJQUNqQixNQUFNckQsWUFBWTRCLGdCQUFnQjtRQUNoQ2xtQixXQUFXO1lBQ1R5bUIsU0FBU3ptQixVQUFVOGIsb0JBQW9CO1lBQ3ZDQyxvQkFBb0IvYixVQUFVK2Isa0JBQWtCO1FBQ2xEO1FBQ0FvSztJQUNGO0lBQ0EsTUFBTWxLLDJCQUEyQixDQUFDcGEsSUFBSXlQO1FBQ3BDLENBQUM2VSxTQUFTbmdCLFNBQVMsQ0FBQzRoQixNQUFNLENBQUMvbEIsTUFBTTlFLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQywyQ0FBMkMsRUFBRW1DLEdBQUcsd0JBQXdCLENBQUMsSUFBSW5DLENBQVdBLEdBQUcsS0FBSztRQUMzTCxJQUFJLENBQUNpb0IsWUFBWTtZQUNmO1FBQ0Y7UUFDQTNuQixVQUFVaWMsd0JBQXdCLENBQUM7WUFDakNwYTtZQUNBeVA7UUFDRjtJQUNGO0lBQ0EsTUFBTTRLLGtDQUFrQyxDQUFDcmEsSUFBSXVHO1FBQzNDLElBQUksQ0FBQ3VmLFlBQVk7WUFDZjtRQUNGO1FBQ0EsQ0FBQ3hCLFNBQVNuZ0IsU0FBUyxDQUFDNGhCLE1BQU0sQ0FBQy9sQixNQUFNOUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLGlEQUFpRCxFQUFFbUMsR0FBRyx3QkFBd0IsQ0FBQyxJQUFJbkMsQ0FBV0EsR0FBRyxLQUFLO1FBQ2pNTSxVQUFVa2MsK0JBQStCLENBQUM7WUFDeENyYTtZQUNBdUc7UUFDRjtJQUNGO0lBQ0EsTUFBTTRULHdCQUF3QixDQUFDbmEsSUFBSW9FO1FBQ2pDLElBQUksQ0FBQzBoQixZQUFZO1lBQ2Y7UUFDRjtRQUNBLENBQUN4QixTQUFTbmdCLFNBQVMsQ0FBQzRoQixNQUFNLENBQUMvbEIsTUFBTTlFLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxzQ0FBc0MsRUFBRW1DLEdBQUcsd0JBQXdCLENBQUMsSUFBSW5DLENBQVdBLEdBQUcsS0FBSztRQUN0TE0sVUFBVWdjLHFCQUFxQixDQUFDO1lBQzlCbmE7WUFDQW9FO1FBQ0Y7SUFDRjtJQUNBLE1BQU1GLGtCQUFrQixDQUFDbEUsSUFBSWdtQjtRQUMzQixJQUFJLENBQUNGLFlBQVk7WUFDZjtRQUNGO1FBQ0F4QixTQUFTbmdCLFNBQVMsQ0FBQ3NnQixPQUFPLENBQUN6a0IsSUFBSTdCLFNBQVMsQ0FBQzZFLE1BQU0sQ0FBQ2dqQjtJQUNsRDtJQUNBLE1BQU03QyxpQkFBaUI7UUFDckIsSUFBSSxDQUFDMkMsWUFBWTtZQUNmO1FBQ0Y7UUFDQXJELFVBQVVoRCxJQUFJO1FBQ2QsTUFBTXZNLE9BQU80UyxXQUFXM1MsUUFBUSxDQUFDaFAsU0FBUztRQUMxQ21nQixTQUFTbmdCLFNBQVMsQ0FBQ3VoQixZQUFZLENBQUN4UyxLQUFLcFgsSUFBSSxFQUFFd0IsT0FBTyxDQUFDb2pCLENBQUFBLFFBQVNBLE1BQU12aUIsU0FBUyxDQUFDOG5CLFdBQVc7UUFDdkZILFdBQVdJLFdBQVc7UUFDdEJKLGFBQWE7SUFDZjtJQUNBLE1BQU1LLGFBQWE5bkIsQ0FBQUE7UUFDakIsQ0FBQ3luQixhQUFhNXFCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sOERBQThEQSxDQUFXQSxHQUFHLEtBQUs7UUFDeEosTUFBTXVlLFdBQVcwSixXQUFXM1MsUUFBUSxDQUFDNU4sU0FBUztRQUM5QyxJQUFJbEgsTUFBTXZDLElBQUksS0FBSyxZQUFZO1lBQzdCLElBQUk4cEIsb0JBQW9CdEIsVUFBVWxJLFVBQVUvZCxNQUFNL0MsS0FBSyxHQUFHO2dCQUN4RG1uQixVQUFVMWhCLEdBQUcsQ0FBQzFDLE1BQU0vQyxLQUFLO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJK0MsTUFBTXZDLElBQUksS0FBSyxXQUFXO1lBQzVCLElBQUk4cEIsb0JBQW9CdEIsVUFBVWxJLFVBQVUvZCxNQUFNL0MsS0FBSyxHQUFHO2dCQUN4RG1uQixVQUFVemMsTUFBTSxDQUFDM0gsTUFBTS9DLEtBQUs7WUFDOUI7UUFDRjtJQUNGO0lBQ0EsTUFBTTRnQixrQkFBa0JELENBQUFBO1FBQ3RCLENBQUMsQ0FBQzZKLGFBQWE1cUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxpRkFBaUZBLENBQVdBLEdBQUcsS0FBSztRQUM1SyxNQUFNNmlCLFFBQVE0RCxTQUFTL2UsU0FBUyxDQUFDa2YsT0FBTyxDQUFDeEksUUFBUTliLFdBQVc7UUFDNUQsTUFBTStTLE9BQU9vUixTQUFTbmdCLFNBQVMsQ0FBQ3NnQixPQUFPLENBQUMvRCxNQUFNNWIsVUFBVSxDQUFDbEYsV0FBVztRQUNwRSxNQUFNdVQsV0FBVztZQUNmNU4sV0FBV21iLE1BQU01YixVQUFVO1lBQzNCWCxXQUFXK08sS0FBS3BPLFVBQVU7UUFDNUI7UUFDQSxNQUFNb2hCLGNBQWM1QixTQUFTOEIsU0FBUyxDQUFDRDtRQUN2Q0wsYUFBYTtZQUNYM1M7WUFDQStTO1FBQ0Y7UUFDQSxPQUFPVixrQkFBa0I7WUFDdkJyUztZQUNBbVI7WUFDQXZJLGVBQWVFLFFBQVFGLGFBQWE7UUFDdEM7SUFDRjtJQUNBLE1BQU1KLFVBQVU7UUFDZHZCO1FBQ0FDO1FBQ0FuVztRQUNBaVc7UUFDQStCO1FBQ0FpSDtJQUNGO0lBQ0EsT0FBT3hIO0FBQ1Q7QUFFQSxJQUFJMEssZUFBZSxDQUFDdlQsT0FBTzlTO0lBQ3pCLElBQUk4UyxNQUFNVSxLQUFLLEtBQUssUUFBUTtRQUMxQixPQUFPO0lBQ1Q7SUFDQSxJQUFJVixNQUFNVSxLQUFLLEtBQUssa0JBQWtCO1FBQ3BDLE9BQU87SUFDVDtJQUNBLElBQUlWLE1BQU1rRyxTQUFTLENBQUN2WSxNQUFNLENBQUNOLFdBQVcsS0FBS0gsSUFBSTtRQUM3QyxPQUFPO0lBQ1Q7SUFDQSxPQUFPOFMsTUFBTWtHLFNBQVMsQ0FBQ3ZZLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLO0FBQzNDO0FBRUEsSUFBSTRsQixlQUFlTixDQUFBQTtJQUNqQmpxQixPQUFPd3FCLFFBQVEsQ0FBQ1AsT0FBT25sQixDQUFDLEVBQUVtbEIsT0FBT2xsQixDQUFDO0FBQ3BDO0FBRUEsTUFBTTBsQiwwQkFBMEIxckIsdURBQVVBLENBQUM2SixDQUFBQSxhQUFjTSxnQkFBZ0JOLFlBQVlXLE1BQU0sQ0FBQ25CLENBQUFBO1FBQzFGLElBQUksQ0FBQ0EsVUFBVXNMLFNBQVMsRUFBRTtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUN0TCxVQUFVakMsS0FBSyxFQUFFO1lBQ3BCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtBQUNBLE1BQU11a0IsNkJBQTZCLENBQUM1a0IsUUFBUThDO0lBQzFDLE1BQU0raEIsUUFBUUYsd0JBQXdCN2hCLFlBQVlvRyxJQUFJLENBQUM1RyxDQUFBQTtRQUNyRCxDQUFDQSxVQUFVakMsS0FBSyxHQUFHaEgsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxvQkFBb0JBLENBQVdBLEdBQUcsS0FBSztRQUNuSCxPQUFPNFYsa0JBQWtCdFAsVUFBVWpDLEtBQUssQ0FBQ3dCLGFBQWEsRUFBRTdCO0lBQzFELE1BQU07SUFDTixPQUFPNmtCO0FBQ1Q7QUFDQSxJQUFJQyw2QkFBNkIsQ0FBQyxFQUNoQ3BhLE1BQU0sRUFDTjdNLFdBQVcsRUFDWGlGLFVBQVUsRUFDWDtJQUNDLElBQUlqRixhQUFhO1FBQ2YsTUFBTThSLFlBQVk3TSxVQUFVLENBQUNqRixZQUFZO1FBQ3pDLElBQUksQ0FBQzhSLFVBQVV0UCxLQUFLLEVBQUU7WUFDcEIsT0FBTztRQUNUO1FBQ0EsT0FBT3NQO0lBQ1Q7SUFDQSxNQUFNQSxZQUFZaVYsMkJBQTJCbGEsUUFBUTVIO0lBQ3JELE9BQU82TTtBQUNUO0FBRUEsTUFBTW9WLDZCQUE2QjtJQUNqQ0MscUJBQXFCO0lBQ3JCQyx1QkFBdUI7SUFDdkJDLGdCQUFnQjtJQUNoQkMsTUFBTWpKLENBQUFBLGFBQWNBLGNBQWM7SUFDbENrSixtQkFBbUI7UUFDakJDLGlCQUFpQjtRQUNqQkMsY0FBYztJQUNoQjtJQUNBQyxVQUFVO0FBQ1o7QUFFQSxJQUFJQyx3QkFBd0IsQ0FBQ0MsV0FBV2xrQixNQUFNbWtCLHlCQUF5QixJQUFNWCwwQkFBMEI7SUFDckcsTUFBTVksc0JBQXNCRDtJQUM1QixNQUFNRSxxQkFBcUJILFNBQVMsQ0FBQ2xrQixLQUFLeUYsSUFBSSxDQUFDLEdBQUcyZSxvQkFBb0JYLG1CQUFtQjtJQUN6RixNQUFNYSxtQkFBbUJKLFNBQVMsQ0FBQ2xrQixLQUFLeUYsSUFBSSxDQUFDLEdBQUcyZSxvQkFBb0JWLHFCQUFxQjtJQUN6RixNQUFNYSxhQUFhO1FBQ2pCRjtRQUNBQztJQUNGO0lBQ0EsT0FBT0M7QUFDVDtBQUVBLElBQUlDLGdCQUFnQixDQUFDLEVBQ25CQyxZQUFZLEVBQ1pDLFVBQVUsRUFDVnJqQixPQUFPLEVBQ1I7SUFDQyxNQUFNc2pCLFFBQVFELGFBQWFEO0lBQzNCLElBQUlFLFVBQVUsR0FBRztRQW5tSG5CLEtBb21IeUMsR0FBRzlyQixRQUFRLENBQUM7Ozs7SUFJakQsQ0FBQyxJQUFJLENBQU07UUFDWCxPQUFPO0lBQ1Q7SUFDQSxNQUFNK3JCLGlCQUFpQnZqQixVQUFVb2pCO0lBQ2pDLE1BQU05SixhQUFhaUssaUJBQWlCRDtJQUNwQyxPQUFPaEs7QUFDVDtBQUVBLElBQUlrSyxZQUFZO0FBRWhCLElBQUlDLHVCQUF1QixDQUFDQyxnQkFBZ0JSLFlBQVlKLHlCQUF5QixJQUFNWCwwQkFBMEI7SUFDL0csTUFBTVksc0JBQXNCRDtJQUM1QixJQUFJWSxpQkFBaUJSLFdBQVdGLGtCQUFrQixFQUFFO1FBQ2xELE9BQU87SUFDVDtJQUNBLElBQUlVLGtCQUFrQlIsV0FBV0QsZ0JBQWdCLEVBQUU7UUFDakQsT0FBT0Ysb0JBQW9CVCxjQUFjO0lBQzNDO0lBQ0EsSUFBSW9CLG1CQUFtQlIsV0FBV0Ysa0JBQWtCLEVBQUU7UUFDcEQsT0FBT1E7SUFDVDtJQUNBLE1BQU1HLGlDQUFpQ1IsY0FBYztRQUNuREMsY0FBY0YsV0FBV0QsZ0JBQWdCO1FBQ3pDSSxZQUFZSCxXQUFXRixrQkFBa0I7UUFDekNoakIsU0FBUzBqQjtJQUNYO0lBQ0EsTUFBTUUsbUNBQW1DLElBQUlEO0lBQzdDLE1BQU1wbEIsU0FBU3drQixvQkFBb0JULGNBQWMsR0FBR1Msb0JBQW9CUixJQUFJLENBQUNxQjtJQUM3RSxPQUFPM21CLEtBQUs0bUIsSUFBSSxDQUFDdGxCO0FBQ25CO0FBRUEsSUFBSXVsQixvQkFBb0IsQ0FBQ0MsZ0JBQWdCQyxlQUFlbEI7SUFDdEQsTUFBTUMsc0JBQXNCRDtJQUM1QixNQUFNSixlQUFlSyxvQkFBb0JQLGlCQUFpQixDQUFDRSxZQUFZO0lBQ3ZFLE1BQU11QixTQUFTbEIsb0JBQW9CUCxpQkFBaUIsQ0FBQ0MsZUFBZTtJQUNwRSxNQUFNVyxlQUFlWTtJQUNyQixNQUFNWCxhQUFhWTtJQUNuQixNQUFNalQsTUFBTWtULEtBQUtsVCxHQUFHO0lBQ3BCLE1BQU1tVCxVQUFVblQsTUFBTW9TO0lBQ3RCLElBQUllLFdBQVdGLFFBQVE7UUFDckIsT0FBT0Y7SUFDVDtJQUNBLElBQUlJLFVBQVV6QixjQUFjO1FBQzFCLE9BQU9jO0lBQ1Q7SUFDQSxNQUFNWSx5Q0FBeUNqQixjQUFjO1FBQzNEQyxjQUFjVjtRQUNkVztRQUNBcmpCLFNBQVNta0I7SUFDWDtJQUNBLE1BQU01bEIsU0FBU3dsQixpQkFBaUJoQixvQkFBb0JSLElBQUksQ0FBQzZCO0lBQ3pELE9BQU9ubkIsS0FBSzRtQixJQUFJLENBQUN0bEI7QUFDbkI7QUFFQSxJQUFJOGxCLFdBQVcsQ0FBQyxFQUNkWCxjQUFjLEVBQ2RSLFVBQVUsRUFDVmMsYUFBYSxFQUNiTSxzQkFBc0IsRUFDdEJ4QixzQkFBc0IsRUFDdkI7SUFDQyxNQUFNdmtCLFNBQVNrbEIscUJBQXFCQyxnQkFBZ0JSLFlBQVlKO0lBQ2hFLElBQUl2a0IsV0FBVyxHQUFHO1FBQ2hCLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQytsQix3QkFBd0I7UUFDM0IsT0FBTy9sQjtJQUNUO0lBQ0EsT0FBT3RCLEtBQUtXLEdBQUcsQ0FBQ2ttQixrQkFBa0J2bEIsUUFBUXlsQixlQUFlbEIseUJBQXlCVTtBQUNwRjtBQUVBLElBQUllLGtCQUFrQixDQUFDLEVBQ3JCMUIsU0FBUyxFQUNUMkIsZUFBZSxFQUNmUixhQUFhLEVBQ2JybEIsSUFBSSxFQUNKMmxCLHNCQUFzQixFQUN0QnhCLHNCQUFzQixFQUN2QjtJQUNDLE1BQU1JLGFBQWFOLHNCQUFzQkMsV0FBV2xrQixNQUFNbWtCO0lBQzFELE1BQU0yQixnQkFBZ0JELGVBQWUsQ0FBQzdsQixLQUFLRyxHQUFHLENBQUMsR0FBRzBsQixlQUFlLENBQUM3bEIsS0FBSzdELEtBQUssQ0FBQztJQUM3RSxJQUFJMnBCLGVBQWU7UUFDakIsT0FBT0osU0FBUztZQUNkWCxnQkFBZ0JjLGVBQWUsQ0FBQzdsQixLQUFLRyxHQUFHLENBQUM7WUFDekNva0I7WUFDQWM7WUFDQU07WUFDQXhCO1FBQ0Y7SUFDRjtJQUNBLE9BQU8sQ0FBQyxJQUFJdUIsU0FBUztRQUNuQlgsZ0JBQWdCYyxlQUFlLENBQUM3bEIsS0FBSzdELEtBQUssQ0FBQztRQUMzQ29vQjtRQUNBYztRQUNBTTtRQUNBeEI7SUFDRjtBQUNGO0FBRUEsSUFBSTRCLHNCQUFzQixDQUFDLEVBQ3pCN0IsU0FBUyxFQUNUbmxCLE9BQU8sRUFDUHFtQixjQUFjLEVBQ2Y7SUFDQyxNQUFNWSxxQkFBcUJqbkIsUUFBUU8sTUFBTSxHQUFHNGtCLFVBQVU1a0IsTUFBTTtJQUM1RCxNQUFNMm1CLHVCQUF1QmxuQixRQUFRTSxLQUFLLEdBQUc2a0IsVUFBVTdrQixLQUFLO0lBQzVELElBQUksQ0FBQzRtQix3QkFBd0IsQ0FBQ0Qsb0JBQW9CO1FBQ2hELE9BQU9aO0lBQ1Q7SUFDQSxJQUFJYSx3QkFBd0JELG9CQUFvQjtRQUM5QyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO1FBQ0x2b0IsR0FBR3dvQix1QkFBdUIsSUFBSWIsZUFBZTNuQixDQUFDO1FBQzlDQyxHQUFHc29CLHFCQUFxQixJQUFJWixlQUFlMW5CLENBQUM7SUFDOUM7QUFDRjtBQUVBLE1BQU13b0IsUUFBUXRuQixNQUFNMUcsQ0FBQUEsUUFBU0EsVUFBVSxJQUFJLElBQUlBO0FBQy9DLElBQUlpdUIsY0FBYyxDQUFDLEVBQ2pCZCxhQUFhLEVBQ2JuQixTQUFTLEVBQ1RubEIsT0FBTyxFQUNQb0ssTUFBTSxFQUNOd2Msc0JBQXNCLEVBQ3RCeEIsc0JBQXNCLEVBQ3ZCO0lBQ0MsTUFBTTBCLGtCQUFrQjtRQUN0QjdtQixLQUFLbUssT0FBT3pMLENBQUMsR0FBR3dtQixVQUFVbGxCLEdBQUc7UUFDN0JFLE9BQU9nbEIsVUFBVWhsQixLQUFLLEdBQUdpSyxPQUFPMUwsQ0FBQztRQUNqQzBCLFFBQVEra0IsVUFBVS9rQixNQUFNLEdBQUdnSyxPQUFPekwsQ0FBQztRQUNuQzBCLE1BQU0rSixPQUFPMUwsQ0FBQyxHQUFHeW1CLFVBQVU5a0IsSUFBSTtJQUNqQztJQUNBLE1BQU0xQixJQUFJa29CLGdCQUFnQjtRQUN4QjFCO1FBQ0EyQjtRQUNBUjtRQUNBcmxCLE1BQU1zRjtRQUNOcWdCO1FBQ0F4QjtJQUNGO0lBQ0EsTUFBTTFtQixJQUFJbW9CLGdCQUFnQjtRQUN4QjFCO1FBQ0EyQjtRQUNBUjtRQUNBcmxCLE1BQU02RjtRQUNOOGY7UUFDQXhCO0lBQ0Y7SUFDQSxNQUFNaUMsV0FBV0YsTUFBTTtRQUNyQnpvQjtRQUNBQztJQUNGO0lBQ0EsSUFBSUssVUFBVXFvQixVQUFVNW9CLFNBQVM7UUFDL0IsT0FBTztJQUNUO0lBQ0EsTUFBTTZvQixVQUFVTixvQkFBb0I7UUFDbEM3QjtRQUNBbmxCO1FBQ0FxbUIsZ0JBQWdCZ0I7SUFDbEI7SUFDQSxJQUFJLENBQUNDLFNBQVM7UUFDWixPQUFPO0lBQ1Q7SUFDQSxPQUFPdG9CLFVBQVVzb0IsU0FBUzdvQixVQUFVLE9BQU82b0I7QUFDN0M7QUFFQSxNQUFNQyxpQkFBaUIxbkIsTUFBTTFHLENBQUFBO0lBQzNCLElBQUlBLFVBQVUsR0FBRztRQUNmLE9BQU87SUFDVDtJQUNBLE9BQU9BLFFBQVEsSUFBSSxJQUFJLENBQUM7QUFDMUI7QUFDQSxNQUFNcXVCLGFBQWEsQ0FBQztJQUNsQixNQUFNQyxlQUFlLENBQUMvbkIsUUFBUVE7UUFDNUIsSUFBSVIsU0FBUyxHQUFHO1lBQ2QsT0FBT0E7UUFDVDtRQUNBLElBQUlBLFNBQVNRLEtBQUs7WUFDaEIsT0FBT1IsU0FBU1E7UUFDbEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPLENBQUMsRUFDTm9DLE9BQU8sRUFDUHBDLEdBQUcsRUFDSDJqQixNQUFNLEVBQ1A7UUFDQyxNQUFNNkQsZUFBZTlvQixJQUFJMEQsU0FBU3VoQjtRQUNsQyxNQUFNOEQsVUFBVTtZQUNkanBCLEdBQUcrb0IsYUFBYUMsYUFBYWhwQixDQUFDLEVBQUV3QixJQUFJeEIsQ0FBQztZQUNyQ0MsR0FBRzhvQixhQUFhQyxhQUFhL29CLENBQUMsRUFBRXVCLElBQUl2QixDQUFDO1FBQ3ZDO1FBQ0EsSUFBSUssVUFBVTJvQixTQUFTbHBCLFNBQVM7WUFDOUIsT0FBTztRQUNUO1FBQ0EsT0FBT2twQjtJQUNUO0FBQ0Y7QUFDQSxNQUFNQyxxQkFBcUIsQ0FBQyxFQUMxQjFuQixLQUFLMm5CLE1BQU0sRUFDWHZsQixPQUFPLEVBQ1B1aEIsTUFBTSxFQUNQO0lBQ0MsTUFBTTNqQixNQUFNO1FBQ1Z4QixHQUFHYSxLQUFLVyxHQUFHLENBQUNvQyxRQUFRNUQsQ0FBQyxFQUFFbXBCLE9BQU9ucEIsQ0FBQztRQUMvQkMsR0FBR1ksS0FBS1csR0FBRyxDQUFDb0MsUUFBUTNELENBQUMsRUFBRWtwQixPQUFPbHBCLENBQUM7SUFDakM7SUFDQSxNQUFNbXBCLGlCQUFpQlAsZUFBZTFEO0lBQ3RDLE1BQU04RCxVQUFVSCxXQUFXO1FBQ3pCdG5CO1FBQ0FvQztRQUNBdWhCLFFBQVFpRTtJQUNWO0lBQ0EsSUFBSSxDQUFDSCxTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsSUFBSUcsZUFBZXBwQixDQUFDLEtBQUssS0FBS2lwQixRQUFRanBCLENBQUMsS0FBSyxHQUFHO1FBQzdDLE9BQU87SUFDVDtJQUNBLElBQUlvcEIsZUFBZW5wQixDQUFDLEtBQUssS0FBS2dwQixRQUFRaHBCLENBQUMsS0FBSyxHQUFHO1FBQzdDLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLE1BQU1vcEIsa0JBQWtCLENBQUMzZ0IsVUFBVXljLFNBQVcrRCxtQkFBbUI7UUFDL0R0bEIsU0FBUzhFLFNBQVN2RyxNQUFNLENBQUN5QixPQUFPO1FBQ2hDcEMsS0FBS2tILFNBQVN2RyxNQUFNLENBQUNYLEdBQUc7UUFDeEIyakI7SUFDRjtBQUNBLE1BQU1tRSxtQkFBbUIsQ0FBQzVnQixVQUFVeWM7SUFDbEMsSUFBSSxDQUFDa0UsZ0JBQWdCM2dCLFVBQVV5YyxTQUFTO1FBQ3RDLE9BQU87SUFDVDtJQUNBLE1BQU0zakIsTUFBTWtILFNBQVN2RyxNQUFNLENBQUNYLEdBQUc7SUFDL0IsTUFBTW9DLFVBQVU4RSxTQUFTdkcsTUFBTSxDQUFDeUIsT0FBTztJQUN2QyxPQUFPa2xCLFdBQVc7UUFDaEJsbEI7UUFDQXBDO1FBQ0EyakI7SUFDRjtBQUNGO0FBQ0EsTUFBTW9FLHFCQUFxQixDQUFDam1CLFdBQVc2aEI7SUFDckMsTUFBTTlqQixRQUFRaUMsVUFBVWpDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsT0FBTzZuQixtQkFBbUI7UUFDeEJ0bEIsU0FBU3ZDLE1BQU1jLE1BQU0sQ0FBQ3lCLE9BQU87UUFDN0JwQyxLQUFLSCxNQUFNYyxNQUFNLENBQUNYLEdBQUc7UUFDckIyakI7SUFDRjtBQUNGO0FBQ0EsTUFBTXFFLHNCQUFzQixDQUFDbG1CLFdBQVc2aEI7SUFDdEMsTUFBTTlqQixRQUFRaUMsVUFBVWpDLEtBQUs7SUFDN0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDa29CLG1CQUFtQmptQixXQUFXNmhCLFNBQVM7UUFDMUMsT0FBTztJQUNUO0lBQ0EsT0FBTzJELFdBQVc7UUFDaEJsbEIsU0FBU3ZDLE1BQU1jLE1BQU0sQ0FBQ3lCLE9BQU87UUFDN0JwQyxLQUFLSCxNQUFNYyxNQUFNLENBQUNYLEdBQUc7UUFDckIyakI7SUFDRjtBQUNGO0FBRUEsSUFBSXNFLHdCQUF3QixDQUFDLEVBQzNCL2dCLFFBQVEsRUFDUnBILE9BQU8sRUFDUG9LLE1BQU0sRUFDTmtjLGFBQWEsRUFDYk0sc0JBQXNCLEVBQ3RCeEIsc0JBQXNCLEVBQ3ZCO0lBQ0MsTUFBTXZrQixTQUFTdW1CLFlBQVk7UUFDekJkO1FBQ0FuQixXQUFXL2QsU0FBU3JILEtBQUs7UUFDekJDO1FBQ0FvSztRQUNBd2M7UUFDQXhCO0lBQ0Y7SUFDQSxPQUFPdmtCLFVBQVVrbkIsZ0JBQWdCM2dCLFVBQVV2RyxVQUFVQSxTQUFTO0FBQ2hFO0FBRUEsSUFBSXVuQiwyQkFBMkIsQ0FBQyxFQUM5QnBtQixTQUFTLEVBQ1RoQyxPQUFPLEVBQ1BvSyxNQUFNLEVBQ05rYyxhQUFhLEVBQ2JNLHNCQUFzQixFQUN0QnhCLHNCQUFzQixFQUN2QjtJQUNDLE1BQU1ybEIsUUFBUWlDLFVBQVVqQyxLQUFLO0lBQzdCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU87SUFDVDtJQUNBLE1BQU1jLFNBQVN1bUIsWUFBWTtRQUN6QmQ7UUFDQW5CLFdBQVdwbEIsTUFBTXdCLGFBQWE7UUFDOUJ2QjtRQUNBb0s7UUFDQXdjO1FBQ0F4QjtJQUNGO0lBQ0EsT0FBT3ZrQixVQUFVb25CLG1CQUFtQmptQixXQUFXbkIsVUFBVUEsU0FBUztBQUNwRTtBQUVBLElBQUlBLFNBQVMsQ0FBQyxFQUNaOFAsS0FBSyxFQUNMMlYsYUFBYSxFQUNiTSxzQkFBc0IsRUFDdEJ6QyxZQUFZLEVBQ1pwaUIsZUFBZSxFQUNmcWpCLHNCQUFzQixFQUN2QjtJQUNDLE1BQU1oYixTQUFTdUcsTUFBTXJPLE9BQU8sQ0FBQ2IsSUFBSSxDQUFDeVAsZUFBZTtJQUNqRCxNQUFNOU4sWUFBWXVOLE1BQU1FLFVBQVUsQ0FBQ2hPLFVBQVUsQ0FBQzhOLE1BQU1LLFFBQVEsQ0FBQzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztJQUMxRSxNQUFNbUMsVUFBVW9ELFVBQVUzQixJQUFJLENBQUNFLFNBQVM7SUFDeEMsSUFBSWdQLE1BQU11RyxxQkFBcUIsRUFBRTtRQUMvQixNQUFNOVAsV0FBV3VKLE1BQU12SixRQUFRO1FBQy9CLE1BQU15YyxTQUFTc0Usc0JBQXNCO1lBQ25DN0I7WUFDQWxmO1lBQ0FwSDtZQUNBb0s7WUFDQXdjO1lBQ0F4QjtRQUNGO1FBQ0EsSUFBSXZCLFFBQVE7WUFDVk0sYUFBYU47WUFDYjtRQUNGO0lBQ0Y7SUFDQSxNQUFNN2hCLFlBQVl3aUIsMkJBQTJCO1FBQzNDcGE7UUFDQTdNLGFBQWFpVCxrQkFBa0JHLE1BQU1sTixNQUFNO1FBQzNDakIsWUFBWW1PLE1BQU1FLFVBQVUsQ0FBQ3JPLFVBQVU7SUFDekM7SUFDQSxJQUFJLENBQUNSLFdBQVc7UUFDZDtJQUNGO0lBQ0EsTUFBTTZoQixTQUFTdUUseUJBQXlCO1FBQ3RDOUI7UUFDQXRrQjtRQUNBaEM7UUFDQW9LO1FBQ0F3YztRQUNBeEI7SUFDRjtJQUNBLElBQUl2QixRQUFRO1FBQ1Y5aEIsZ0JBQWdCQyxVQUFVVyxVQUFVLENBQUM5RSxFQUFFLEVBQUVnbUI7SUFDM0M7QUFDRjtBQUVBLElBQUl3RSxzQkFBc0IsQ0FBQyxFQUN6QmxFLFlBQVksRUFDWnBpQixlQUFlLEVBQ2ZxakIseUJBQXlCLElBQU1YLDBCQUEwQixFQUMxRDtJQUNDLE1BQU02RCx1QkFBdUIxdkIsb0RBQU9BLENBQUN1ckI7SUFDckMsTUFBTW9FLDBCQUEwQjN2QixvREFBT0EsQ0FBQ21KO0lBQ3hDLElBQUlrWSxXQUFXO0lBQ2YsTUFBTXVPLFlBQVk3WCxDQUFBQTtRQUNoQixDQUFDc0osV0FBV2xoQixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHlDQUF5Q0EsQ0FBV0EsR0FBRyxLQUFLO1FBQ2pJLE1BQU0sRUFDSmtyQixzQkFBc0IsRUFDdEJOLGFBQWEsRUFDZCxHQUFHck07UUFDSnBaLE9BQU87WUFDTDhQO1lBQ0F3VCxjQUFjbUU7WUFDZHZtQixpQkFBaUJ3bUI7WUFDakJqQztZQUNBTTtZQUNBeEI7UUFDRjtJQUNGO0lBQ0EsTUFBTXFELFVBQVU5WCxDQUFBQTtRQUNkdlQ7UUFDQSxDQUFDLENBQUM2YyxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sc0RBQXNEQSxDQUFXQSxHQUFHLEtBQUs7UUFDL0ksTUFBTTRxQixnQkFBZ0JFLEtBQUtsVCxHQUFHO1FBQzlCLElBQUlvVixrQkFBa0I7UUFDdEIsTUFBTUMscUJBQXFCO1lBQ3pCRCxrQkFBa0I7UUFDcEI7UUFDQTduQixPQUFPO1lBQ0w4UDtZQUNBMlYsZUFBZTtZQUNmTSx3QkFBd0I7WUFDeEJ6QyxjQUFjd0U7WUFDZDVtQixpQkFBaUI0bUI7WUFDakJ2RDtRQUNGO1FBQ0FuTCxXQUFXO1lBQ1RxTTtZQUNBTSx3QkFBd0I4QjtRQUMxQjtRQUNBN1Q7UUFDQSxJQUFJNlQsaUJBQWlCO1lBQ25CRixVQUFVN1g7UUFDWjtJQUNGO0lBQ0EsTUFBTTJNLE9BQU87UUFDWCxJQUFJLENBQUNyRCxVQUFVO1lBQ2I7UUFDRjtRQUNBcU8scUJBQXFCL0ssTUFBTTtRQUMzQmdMLHdCQUF3QmhMLE1BQU07UUFDOUJ0RCxXQUFXO0lBQ2I7SUFDQSxPQUFPO1FBQ0w3YyxPQUFPcXJCO1FBQ1BuTDtRQUNBemMsUUFBUTJuQjtJQUNWO0FBQ0Y7QUFFQSxJQUFJSSxxQkFBcUIsQ0FBQyxFQUN4QnpRLElBQUksRUFDSnBXLGVBQWUsRUFDZm9pQixZQUFZLEVBQ2I7SUFDQyxNQUFNMEUsZUFBZSxDQUFDbFksT0FBT3JZO1FBQzNCLE1BQU11VSxTQUFTak8sSUFBSStSLE1BQU1yTyxPQUFPLENBQUN1SyxNQUFNLENBQUNzRSxTQUFTLEVBQUU3WTtRQUNuRDZmLEtBQUs7WUFDSHRMO1FBQ0Y7SUFDRjtJQUNBLE1BQU1pYywrQkFBK0IsQ0FBQzltQixXQUFXNmhCO1FBQy9DLElBQUksQ0FBQ29FLG1CQUFtQmptQixXQUFXNmhCLFNBQVM7WUFDMUMsT0FBT0E7UUFDVDtRQUNBLE1BQU04RCxVQUFVTyxvQkFBb0JsbUIsV0FBVzZoQjtRQUMvQyxJQUFJLENBQUM4RCxTQUFTO1lBQ1o1bEIsZ0JBQWdCQyxVQUFVVyxVQUFVLENBQUM5RSxFQUFFLEVBQUVnbUI7WUFDekMsT0FBTztRQUNUO1FBQ0EsTUFBTWtGLDRCQUE0QmhxQixTQUFTOGtCLFFBQVE4RDtRQUNuRDVsQixnQkFBZ0JDLFVBQVVXLFVBQVUsQ0FBQzlFLEVBQUUsRUFBRWtyQjtRQUN6QyxNQUFNQyxZQUFZanFCLFNBQVM4a0IsUUFBUWtGO1FBQ25DLE9BQU9DO0lBQ1Q7SUFDQSxNQUFNQyw0QkFBNEIsQ0FBQy9SLHVCQUF1QjlQLFVBQVV5YztRQUNsRSxJQUFJLENBQUMzTSx1QkFBdUI7WUFDMUIsT0FBTzJNO1FBQ1Q7UUFDQSxJQUFJLENBQUNrRSxnQkFBZ0IzZ0IsVUFBVXljLFNBQVM7WUFDdEMsT0FBT0E7UUFDVDtRQUNBLE1BQU04RCxVQUFVSyxpQkFBaUI1Z0IsVUFBVXljO1FBQzNDLElBQUksQ0FBQzhELFNBQVM7WUFDWnhELGFBQWFOO1lBQ2IsT0FBTztRQUNUO1FBQ0EsTUFBTXFGLHlCQUF5Qm5xQixTQUFTOGtCLFFBQVE4RDtRQUNoRHhELGFBQWErRTtRQUNiLE1BQU1GLFlBQVlqcUIsU0FBUzhrQixRQUFRcUY7UUFDbkMsT0FBT0Y7SUFDVDtJQUNBLE1BQU1HLGVBQWV4WSxDQUFBQTtRQUNuQixNQUFNbUosVUFBVW5KLE1BQU1sRCxpQkFBaUI7UUFDdkMsSUFBSSxDQUFDcU0sU0FBUztZQUNaO1FBQ0Y7UUFDQSxNQUFNdmMsY0FBY2lULGtCQUFrQkcsTUFBTWxOLE1BQU07UUFDbEQsQ0FBQ2xHLGNBQWN4RSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLCtEQUErREEsQ0FBV0EsR0FBRyxLQUFLO1FBQzFKLE1BQU0wdEIscUJBQXFCTiw2QkFBNkJuWSxNQUFNRSxVQUFVLENBQUNyTyxVQUFVLENBQUNqRixZQUFZLEVBQUV1YztRQUNsRyxJQUFJLENBQUNzUCxvQkFBb0I7WUFDdkI7UUFDRjtRQUNBLE1BQU1oaUIsV0FBV3VKLE1BQU12SixRQUFRO1FBQy9CLE1BQU1paUIsa0JBQWtCSiwwQkFBMEJ0WSxNQUFNdUcscUJBQXFCLEVBQUU5UCxVQUFVZ2lCO1FBQ3pGLElBQUksQ0FBQ0MsaUJBQWlCO1lBQ3BCO1FBQ0Y7UUFDQVIsYUFBYWxZLE9BQU8wWTtJQUN0QjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSxJQUFJRyxxQkFBcUIsQ0FBQyxFQUN4QnZuQixlQUFlLEVBQ2ZvaUIsWUFBWSxFQUNaaE0sSUFBSSxFQUNKaU4sc0JBQXNCLEVBQ3ZCO0lBQ0MsTUFBTW1FLGdCQUFnQmxCLG9CQUFvQjtRQUN4Q2xFO1FBQ0FwaUI7UUFDQXFqQjtJQUNGO0lBQ0EsTUFBTW9FLGFBQWFaLG1CQUFtQjtRQUNwQ3pRO1FBQ0FnTTtRQUNBcGlCO0lBQ0Y7SUFDQSxNQUFNbEIsU0FBUzhQLENBQUFBO1FBQ2IsTUFBTTBVLHNCQUFzQkQ7UUFDNUIsSUFBSUMsb0JBQW9CSixRQUFRLElBQUl0VSxNQUFNVSxLQUFLLEtBQUssWUFBWTtZQUM5RDtRQUNGO1FBQ0EsSUFBSVYsTUFBTXlELFlBQVksS0FBSyxTQUFTO1lBQ2xDbVYsY0FBYzFvQixNQUFNLENBQUM4UDtZQUNyQjtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxNQUFNbEQsaUJBQWlCLEVBQUU7WUFDNUI7UUFDRjtRQUNBK2IsV0FBVzdZO0lBQ2I7SUFDQSxNQUFNOFksV0FBVztRQUNmNW9CO1FBQ0F6RCxPQUFPbXNCLGNBQWNuc0IsS0FBSztRQUMxQmtnQixNQUFNaU0sY0FBY2pNLElBQUk7SUFDMUI7SUFDQSxPQUFPbU07QUFDVDtBQUVBLE1BQU1DLFNBQVM7QUFDZixNQUFNQyxhQUFhLENBQUM7SUFDbEIsTUFBTUMsT0FBTyxDQUFDLEVBQUVGLE9BQU8sWUFBWSxDQUFDO0lBQ3BDLE9BQU87UUFDTEU7UUFDQTVyQixhQUFhLENBQUMsRUFBRTRyQixLQUFLLGFBQWEsQ0FBQztRQUNuQ0MsV0FBVyxDQUFDLEVBQUVELEtBQUssV0FBVyxDQUFDO0lBQ2pDO0FBQ0Y7QUFDQSxNQUFNeG1CLFlBQVksQ0FBQztJQUNqQixNQUFNd21CLE9BQU8sQ0FBQyxFQUFFRixPQUFPLFVBQVUsQ0FBQztJQUNsQyxPQUFPO1FBQ0xFO1FBQ0FDLFdBQVcsQ0FBQyxFQUFFRCxLQUFLLFdBQVcsQ0FBQztRQUMvQi9yQixJQUFJLENBQUMsRUFBRStyQixLQUFLLEdBQUcsQ0FBQztJQUNsQjtBQUNGO0FBQ0EsTUFBTTVuQixZQUFZLENBQUM7SUFDakIsTUFBTTRuQixPQUFPLENBQUMsRUFBRUYsT0FBTyxVQUFVLENBQUM7SUFDbEMsT0FBTztRQUNMRTtRQUNBQyxXQUFXLENBQUMsRUFBRUQsS0FBSyxXQUFXLENBQUM7UUFDL0IvckIsSUFBSSxDQUFDLEVBQUUrckIsS0FBSyxHQUFHLENBQUM7SUFDbEI7QUFDRjtBQUNBLE1BQU1FLGtCQUFrQjtJQUN0QkQsV0FBVyxDQUFDLEVBQUVILE9BQU8sNEJBQTRCLENBQUM7QUFDcEQ7QUFFQSxNQUFNSyxrQkFBa0JDLENBQUFBLFVBQVdDLENBQUFBLFlBQWEsQ0FBQyxDQUFDLEVBQUVBLFVBQVUsRUFBRSxFQUFFRCxRQUFRLEVBQUUsQ0FBQztBQUM3RSxNQUFNRSxZQUFZLENBQUNDLE9BQU9DLFdBQWFELE1BQU16dkIsR0FBRyxDQUFDMnZCLENBQUFBO1FBQy9DLE1BQU1seEIsUUFBUWt4QixLQUFLQyxNQUFNLENBQUNGLFNBQVM7UUFDbkMsSUFBSSxDQUFDanhCLE9BQU87WUFDVixPQUFPO1FBQ1Q7UUFDQSxPQUFPLENBQUMsRUFBRWt4QixLQUFLRSxRQUFRLENBQUMsR0FBRyxFQUFFcHhCLE1BQU0sRUFBRSxDQUFDO0lBQ3hDLEdBQUdrZ0IsSUFBSSxDQUFDO0FBQ1IsTUFBTW1SLGtCQUFrQjtBQUN4QixJQUFJQyxjQUFjWixDQUFBQTtJQUNoQixNQUFNYSxjQUFjWCxnQkFBZ0JGO0lBQ3BDLE1BQU1jLGVBQWUsQ0FBQztRQUNwQixNQUFNQyxhQUFhLENBQUM7OztJQUdwQixDQUFDO1FBQ0QsT0FBTztZQUNMTCxVQUFVRyxZQUFZZixXQUFXRSxTQUFTO1lBQzFDUyxRQUFRO2dCQUNOTyxRQUFRLENBQUM7Ozs7UUFJVCxDQUFDO2dCQUNEMVEsU0FBU3lRO2dCQUNUM1EsVUFBVXVRO2dCQUNWTSxlQUFlRjtZQUNqQjtRQUNGO0lBQ0Y7SUFDQSxNQUFNRyxjQUFjLENBQUM7UUFDbkIsTUFBTUMsYUFBYSxDQUFDO2tCQUNOLEVBQUVuUSxZQUFZUixXQUFXLENBQUM7SUFDeEMsQ0FBQztRQUNELE9BQU87WUFDTGtRLFVBQVVHLFlBQVl0bkIsVUFBVXltQixTQUFTO1lBQ3pDUyxRQUFRO2dCQUNOclEsVUFBVStRO2dCQUNWRixlQUFlRTtnQkFDZkMsWUFBWUQ7WUFDZDtRQUNGO0lBQ0Y7SUFDQSxNQUFNRSxjQUFjO1FBQ2xCWCxVQUFVRyxZQUFZMW9CLFVBQVU2bkIsU0FBUztRQUN6Q1MsUUFBUTtZQUNOTyxRQUFRLENBQUMsc0JBQXNCLENBQUM7UUFDbEM7SUFDRjtJQUNBLE1BQU1NLE9BQU87UUFDWFosVUFBVTtRQUNWRCxRQUFRO1lBQ05yUSxVQUFVLENBQUM7Ozs7Ozs7O01BUVgsQ0FBQztRQUNIO0lBQ0Y7SUFDQSxNQUFNa1EsUUFBUTtRQUFDWTtRQUFhSjtRQUFjTztRQUFhQztLQUFLO0lBQzVELE9BQU87UUFDTE4sUUFBUVgsVUFBVUMsT0FBTztRQUN6QmhRLFNBQVMrUCxVQUFVQyxPQUFPO1FBQzFCbFEsVUFBVWlRLFVBQVVDLE9BQU87UUFDM0JXLGVBQWVaLFVBQVVDLE9BQU87UUFDaENjLFlBQVlmLFVBQVVDLE9BQU87SUFDL0I7QUFDRjtBQUVBLE1BQU1pQiw0QkFBNEIsTUFBb0gsR0FBY2gwQixDQUFlQSxHQUFHQyw0Q0FBU0E7QUFFL0wsTUFBTWkwQixVQUFVO0lBQ2QsTUFBTUMsT0FBT3ZPLFNBQVN3TyxhQUFhLENBQUM7SUFDcEMsQ0FBQ0QsT0FBT3h5QixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLCtDQUErQ0EsQ0FBV0EsR0FBRyxLQUFLO0lBQ25JLE9BQU82dkI7QUFDVDtBQUNBLE1BQU1FLGdCQUFnQkMsQ0FBQUE7SUFDcEIsTUFBTXB4QixLQUFLMGlCLFNBQVNxTyxhQUFhLENBQUM7SUFDbEMsSUFBSUssT0FBTztRQUNUcHhCLEdBQUdxeEIsWUFBWSxDQUFDLFNBQVNEO0lBQzNCO0lBQ0FweEIsR0FBR1gsSUFBSSxHQUFHO0lBQ1YsT0FBT1c7QUFDVDtBQUNBLFNBQVNzeEIsZ0JBQWdCL0IsU0FBUyxFQUFFNkIsS0FBSztJQUN2QyxNQUFNcEIsU0FBU3B5QixxREFBT0EsQ0FBQyxJQUFNdXlCLFlBQVlaLFlBQVk7UUFBQ0E7S0FBVTtJQUNoRSxNQUFNZ0MsWUFBWXYwQiw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNdzBCLGFBQWF4MEIsNkNBQU1BLENBQUM7SUFDMUIsTUFBTXkwQixrQkFBa0I1ekIseURBQVdBLENBQUNRLHVEQUFVQSxDQUFDdVgsQ0FBQUE7UUFDN0MsTUFBTTVWLEtBQUt3eEIsV0FBV3hwQixPQUFPO1FBQzdCLENBQUNoSSxLQUFLdkIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyx1REFBdURBLENBQVdBLEdBQUcsS0FBSztRQUN6SXBCLEdBQUcweEIsV0FBVyxHQUFHOWI7SUFDbkIsSUFBSSxFQUFFO0lBQ04sTUFBTStiLGlCQUFpQjl6Qix5REFBV0EsQ0FBQytYLENBQUFBO1FBQ2pDLE1BQU01VixLQUFLdXhCLFVBQVV2cEIsT0FBTztRQUM1QixDQUFDaEksS0FBS3ZCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sdURBQXVEQSxDQUFXQSxHQUFHLEtBQUs7UUFDeklwQixHQUFHMHhCLFdBQVcsR0FBRzliO0lBQ25CLEdBQUcsRUFBRTtJQUNMa2IsMEJBQTBCO1FBQ3hCLENBQUUsRUFBQ1MsVUFBVXZwQixPQUFPLElBQUksQ0FBQ3dwQixXQUFXeHBCLE9BQU8sSUFBSXZKLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sb0NBQW9DQSxDQUFXQSxHQUFHLEtBQUs7UUFDL0osTUFBTW12QixTQUFTWSxjQUFjQztRQUM3QixNQUFNUSxVQUFVVCxjQUFjQztRQUM5QkcsVUFBVXZwQixPQUFPLEdBQUd1b0I7UUFDcEJpQixXQUFXeHBCLE9BQU8sR0FBRzRwQjtRQUNyQnJCLE9BQU9jLFlBQVksQ0FBQyxDQUFDLEVBQUVqQyxPQUFPLE9BQU8sQ0FBQyxFQUFFRztRQUN4Q3FDLFFBQVFQLFlBQVksQ0FBQyxDQUFDLEVBQUVqQyxPQUFPLFFBQVEsQ0FBQyxFQUFFRztRQUMxQ3lCLFVBQVVhLFdBQVcsQ0FBQ3RCO1FBQ3RCUyxVQUFVYSxXQUFXLENBQUNEO1FBQ3RCRCxlQUFlM0IsT0FBT08sTUFBTTtRQUM1QmtCLGdCQUFnQnpCLE9BQU9uUSxPQUFPO1FBQzlCLE9BQU87WUFDTCxNQUFNdFcsU0FBU3VvQixDQUFBQTtnQkFDYixNQUFNOXBCLFVBQVU4cEIsSUFBSTlwQixPQUFPO2dCQUMzQixDQUFDQSxVQUFVdkosS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyx5Q0FBeUNBLENBQVdBLEdBQUcsS0FBSztnQkFDaEk0dkIsVUFBVWUsV0FBVyxDQUFDL3BCO2dCQUN0QjhwQixJQUFJOXBCLE9BQU8sR0FBRztZQUNoQjtZQUNBdUIsT0FBT2dvQjtZQUNQaG9CLE9BQU9pb0I7UUFDVDtJQUNGLEdBQUc7UUFBQ0o7UUFBT087UUFBZ0JGO1FBQWlCekIsT0FBT08sTUFBTTtRQUFFUCxPQUFPblEsT0FBTztRQUFFMFA7S0FBVTtJQUNyRixNQUFNNVAsV0FBVzloQix5REFBV0EsQ0FBQyxJQUFNNHpCLGdCQUFnQnpCLE9BQU9yUSxRQUFRLEdBQUc7UUFBQzhSO1FBQWlCekIsT0FBT3JRLFFBQVE7S0FBQztJQUN2RyxNQUFNQyxXQUFXL2hCLHlEQUFXQSxDQUFDb0csQ0FBQUE7UUFDM0IsSUFBSUEsV0FBVyxRQUFRO1lBQ3JCd3RCLGdCQUFnQnpCLE9BQU9RLGFBQWE7WUFDcEM7UUFDRjtRQUNBaUIsZ0JBQWdCekIsT0FBT1csVUFBVTtJQUNuQyxHQUFHO1FBQUNjO1FBQWlCekIsT0FBT1EsYUFBYTtRQUFFUixPQUFPVyxVQUFVO0tBQUM7SUFDN0QsTUFBTTlRLFVBQVVoaUIseURBQVdBLENBQUM7UUFDMUIsSUFBSSxDQUFDMnpCLFdBQVd4cEIsT0FBTyxFQUFFO1lBQ3ZCO1FBQ0Y7UUFDQXlwQixnQkFBZ0J6QixPQUFPblEsT0FBTztJQUNoQyxHQUFHO1FBQUM0UjtRQUFpQnpCLE9BQU9uUSxPQUFPO0tBQUM7SUFDcEMsTUFBTVgsVUFBVXRoQixxREFBT0EsQ0FBQyxJQUFPO1lBQzdCK2hCO1lBQ0FDO1lBQ0FDO1FBQ0YsSUFBSTtRQUFDRjtRQUFVQztRQUFVQztLQUFRO0lBQ2pDLE9BQU9YO0FBQ1Q7QUFFQSxTQUFTOFMsaUJBQWlCQyxVQUFVLEVBQUVoQyxRQUFRO0lBQzVDLE9BQU9pQyxNQUFNQyxJQUFJLENBQUNGLFdBQVdELGdCQUFnQixDQUFDL0I7QUFDaEQ7QUFFQSxJQUFJbUMsa0JBQWtCcHlCLENBQUFBO0lBQ3BCLElBQUlBLE1BQU1BLEdBQUdxeUIsYUFBYSxJQUFJcnlCLEdBQUdxeUIsYUFBYSxDQUFDQyxXQUFXLEVBQUU7UUFDMUQsT0FBT3R5QixHQUFHcXlCLGFBQWEsQ0FBQ0MsV0FBVztJQUNyQztJQUNBLE9BQU9oekI7QUFDVDtBQUVBLFNBQVNpekIsY0FBY3Z5QixFQUFFO0lBQ3ZCLE9BQU9BLGNBQWNveUIsZ0JBQWdCcHlCLElBQUl3eUIsV0FBVztBQUN0RDtBQUVBLFNBQVNDLGVBQWVsRCxTQUFTLEVBQUU3ckIsV0FBVztJQUM1QyxNQUFNdXNCLFdBQVcsQ0FBQyxDQUFDLEVBQUVaLFdBQVdFLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsRUFBRSxDQUFDO0lBQzNELE1BQU1tRCxXQUFXVixpQkFBaUJ0UCxVQUFVdU47SUFDNUMsSUFBSSxDQUFDeUMsU0FBU3ZvQixNQUFNLEVBQUU7UUFuekl4QixLQW96SXlDLEdBQUczSyxRQUFRLENBQUMsZ0RBQWdELEVBQUUrdkIsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFNO1FBQ3pILE9BQU87SUFDVDtJQUNBLE1BQU1vRCxTQUFTRCxTQUFTcGtCLElBQUksQ0FBQ3RPLENBQUFBO1FBQzNCLE9BQU9BLEdBQUc0eUIsWUFBWSxDQUFDdkQsV0FBVzNyQixXQUFXLE1BQU1BO0lBQ3JEO0lBQ0EsSUFBSSxDQUFDaXZCLFFBQVE7UUExeklmLEtBMnpJeUMsR0FBR256QixRQUFRLENBQUMsb0NBQW9DLEVBQUVrRSxZQUFZLDJDQUEyQyxDQUFDLElBQUksQ0FBTTtRQUN6SixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUM2dUIsY0FBY0ksU0FBUztRQTl6STlCLEtBK3pJeUMsR0FBR256QixRQUFRLDJDQUEyQyxDQUFNO1FBQ2pHLE9BQU87SUFDVDtJQUNBLE9BQU9tekI7QUFDVDtBQUVBLFNBQVNFLGdCQUFnQnRELFNBQVM7SUFDaEMsTUFBTXVELGFBQWE5MUIsNkNBQU1BLENBQUMsQ0FBQztJQUMzQixNQUFNKzFCLFlBQVkvMUIsNkNBQU1BLENBQUM7SUFDekIsTUFBTWcyQix1QkFBdUJoMkIsNkNBQU1BLENBQUM7SUFDcEMsTUFBTWkyQixlQUFlajJCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU1rMkIsV0FBV3IxQix5REFBV0EsQ0FBQyxTQUFTcTFCLFNBQVMzdkIsRUFBRSxFQUFFb2pCLEtBQUs7UUFDdEQsTUFBTTFDLFFBQVE7WUFDWjFnQjtZQUNBb2pCO1FBQ0Y7UUFDQW1NLFdBQVc5cUIsT0FBTyxDQUFDekUsR0FBRyxHQUFHMGdCO1FBQ3pCLE9BQU8sU0FBU2tQO1lBQ2QsTUFBTXJQLFVBQVVnUCxXQUFXOXFCLE9BQU87WUFDbEMsTUFBTUEsVUFBVThiLE9BQU8sQ0FBQ3ZnQixHQUFHO1lBQzNCLElBQUl5RSxZQUFZaWMsT0FBTztnQkFDckIsT0FBT0gsT0FBTyxDQUFDdmdCLEdBQUc7WUFDcEI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU02dkIsZUFBZXYxQix5REFBV0EsQ0FBQyxTQUFTdTFCLGFBQWFDLGNBQWM7UUFDbkUsTUFBTVYsU0FBU0YsZUFBZWxELFdBQVc4RDtRQUN6QyxJQUFJVixVQUFVQSxXQUFXalEsU0FBUzRRLGFBQWEsRUFBRTtZQUMvQ1gsT0FBT2hNLEtBQUs7UUFDZDtJQUNGLEdBQUc7UUFBQzRJO0tBQVU7SUFDZCxNQUFNeEksaUJBQWlCbHBCLHlEQUFXQSxDQUFDLFNBQVNrcEIsZUFBZTNlLFFBQVEsRUFBRW1yQixVQUFVO1FBQzdFLElBQUlSLFVBQVUvcUIsT0FBTyxLQUFLSSxVQUFVO1lBQ2xDMnFCLFVBQVUvcUIsT0FBTyxHQUFHdXJCO1FBQ3RCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTXpNLDBCQUEwQmpwQix5REFBV0EsQ0FBQyxTQUFTaXBCO1FBQ25ELElBQUlrTSxxQkFBcUJockIsT0FBTyxFQUFFO1lBQ2hDO1FBQ0Y7UUFDQSxJQUFJLENBQUNpckIsYUFBYWpyQixPQUFPLEVBQUU7WUFDekI7UUFDRjtRQUNBZ3JCLHFCQUFxQmhyQixPQUFPLEdBQUd3ZSxzQkFBc0I7WUFDbkR3TSxxQkFBcUJockIsT0FBTyxHQUFHO1lBQy9CLE1BQU13ckIsU0FBU1QsVUFBVS9xQixPQUFPO1lBQ2hDLElBQUl3ckIsUUFBUTtnQkFDVkosYUFBYUk7WUFDZjtRQUNGO0lBQ0YsR0FBRztRQUFDSjtLQUFhO0lBQ2pCLE1BQU12TSxpQkFBaUJocEIseURBQVdBLENBQUMsU0FBU2dwQixlQUFldGpCLEVBQUU7UUFDM0R3dkIsVUFBVS9xQixPQUFPLEdBQUc7UUFDcEIsTUFBTXlyQixVQUFVL1EsU0FBUzRRLGFBQWE7UUFDdEMsSUFBSSxDQUFDRyxTQUFTO1lBQ1o7UUFDRjtRQUNBLElBQUlBLFFBQVFiLFlBQVksQ0FBQ3ZELFdBQVczckIsV0FBVyxNQUFNSCxJQUFJO1lBQ3ZEO1FBQ0Y7UUFDQXd2QixVQUFVL3FCLE9BQU8sR0FBR3pFO0lBQ3RCLEdBQUcsRUFBRTtJQUNMdXRCLDBCQUEwQjtRQUN4Qm1DLGFBQWFqckIsT0FBTyxHQUFHO1FBQ3ZCLE9BQU8sU0FBUzByQjtZQUNkVCxhQUFhanJCLE9BQU8sR0FBRztZQUN2QixNQUFNbWUsVUFBVTZNLHFCQUFxQmhyQixPQUFPO1lBQzVDLElBQUltZSxTQUFTO2dCQUNYRSxxQkFBcUJGO1lBQ3ZCO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNakgsVUFBVXRoQixxREFBT0EsQ0FBQyxJQUFPO1lBQzdCczFCO1lBQ0FyTTtZQUNBQztZQUNBQztRQUNGLElBQUk7UUFBQ21NO1FBQVVyTTtRQUFnQkM7UUFBeUJDO0tBQWU7SUFDdkUsT0FBTzdIO0FBQ1Q7QUFFQSxTQUFTeVU7SUFDUCxNQUFNN1AsVUFBVTtRQUNkdmIsWUFBWSxDQUFDO1FBQ2JMLFlBQVksQ0FBQztJQUNmO0lBQ0EsTUFBTTByQixjQUFjLEVBQUU7SUFDdEIsU0FBU2pLLFVBQVVrSyxFQUFFO1FBQ25CRCxZQUFZOWxCLElBQUksQ0FBQytsQjtRQUNqQixPQUFPLFNBQVNwSztZQUNkLE1BQU03bUIsUUFBUWd4QixZQUFZbmxCLE9BQU8sQ0FBQ29sQjtZQUNsQyxJQUFJanhCLFVBQVUsQ0FBQyxHQUFHO2dCQUNoQjtZQUNGO1lBQ0FneEIsWUFBWTFQLE1BQU0sQ0FBQ3RoQixPQUFPO1FBQzVCO0lBQ0Y7SUFDQSxTQUFTa3hCLE9BQU9seUIsS0FBSztRQUNuQixJQUFJZ3lCLFlBQVl6cEIsTUFBTSxFQUFFO1lBQ3RCeXBCLFlBQVkveUIsT0FBTyxDQUFDZ3pCLENBQUFBLEtBQU1BLEdBQUdqeUI7UUFDL0I7SUFDRjtJQUNBLFNBQVNteUIsa0JBQWtCeHdCLEVBQUU7UUFDM0IsT0FBT3VnQixRQUFRdmIsVUFBVSxDQUFDaEYsR0FBRyxJQUFJO0lBQ25DO0lBQ0EsU0FBU3l3QixpQkFBaUJ6d0IsRUFBRTtRQUMxQixNQUFNMGdCLFFBQVE4UCxrQkFBa0J4d0I7UUFDaEMsQ0FBQzBnQixRQUFReGxCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxxQ0FBcUMsRUFBRW1DLEdBQUcsQ0FBQyxDQUFDLElBQUluQyxDQUFXQSxHQUFHLEtBQUs7UUFDdEksT0FBTzZpQjtJQUNUO0lBQ0EsTUFBTWdRLGVBQWU7UUFDbkJmLFVBQVVqUCxDQUFBQTtZQUNSSCxRQUFRdmIsVUFBVSxDQUFDMGIsTUFBTTViLFVBQVUsQ0FBQzlFLEVBQUUsQ0FBQyxHQUFHMGdCO1lBQzFDNlAsT0FBTztnQkFDTHowQixNQUFNO2dCQUNOUixPQUFPb2xCO1lBQ1Q7UUFDRjtRQUNBcmdCLFFBQVEsQ0FBQ3FnQixPQUFPNVo7WUFDZCxNQUFNckMsVUFBVThiLFFBQVF2YixVQUFVLENBQUM4QixLQUFLaEMsVUFBVSxDQUFDOUUsRUFBRSxDQUFDO1lBQ3RELElBQUksQ0FBQ3lFLFNBQVM7Z0JBQ1o7WUFDRjtZQUNBLElBQUlBLFFBQVFrc0IsUUFBUSxLQUFLalEsTUFBTWlRLFFBQVEsRUFBRTtnQkFDdkM7WUFDRjtZQUNBLE9BQU9wUSxRQUFRdmIsVUFBVSxDQUFDOEIsS0FBS2hDLFVBQVUsQ0FBQzlFLEVBQUUsQ0FBQztZQUM3Q3VnQixRQUFRdmIsVUFBVSxDQUFDMGIsTUFBTTViLFVBQVUsQ0FBQzlFLEVBQUUsQ0FBQyxHQUFHMGdCO1FBQzVDO1FBQ0FrUCxZQUFZbFAsQ0FBQUE7WUFDVixNQUFNdmdCLGNBQWN1Z0IsTUFBTTViLFVBQVUsQ0FBQzlFLEVBQUU7WUFDdkMsTUFBTXlFLFVBQVUrckIsa0JBQWtCcndCO1lBQ2xDLElBQUksQ0FBQ3NFLFNBQVM7Z0JBQ1o7WUFDRjtZQUNBLElBQUlpYyxNQUFNaVEsUUFBUSxLQUFLbHNCLFFBQVFrc0IsUUFBUSxFQUFFO2dCQUN2QztZQUNGO1lBQ0EsT0FBT3BRLFFBQVF2YixVQUFVLENBQUM3RSxZQUFZO1lBQ3RDLElBQUlvZ0IsUUFBUTViLFVBQVUsQ0FBQytiLE1BQU01YixVQUFVLENBQUNsRixXQUFXLENBQUMsRUFBRTtnQkFDcEQyd0IsT0FBTztvQkFDTHowQixNQUFNO29CQUNOUixPQUFPb2xCO2dCQUNUO1lBQ0Y7UUFDRjtRQUNBK0QsU0FBU2dNO1FBQ1RHLFVBQVVKO1FBQ1Z6SyxRQUFRL2xCLENBQUFBLEtBQU11TCxRQUFRaWxCLGtCQUFrQnh3QjtRQUN4QzBsQixjQUFjNXBCLENBQUFBLE9BQVFvSixPQUFPQyxNQUFNLENBQUNvYixRQUFRdmIsVUFBVSxFQUFFTSxNQUFNLENBQUNvYixDQUFBQSxRQUFTQSxNQUFNNWIsVUFBVSxDQUFDaEosSUFBSSxLQUFLQTtJQUNwRztJQUNBLFNBQVMrMEIsa0JBQWtCN3dCLEVBQUU7UUFDM0IsT0FBT3VnQixRQUFRNWIsVUFBVSxDQUFDM0UsR0FBRyxJQUFJO0lBQ25DO0lBQ0EsU0FBUzh3QixpQkFBaUI5d0IsRUFBRTtRQUMxQixNQUFNMGdCLFFBQVFtUSxrQkFBa0I3d0I7UUFDaEMsQ0FBQzBnQixRQUFReGxCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxxQ0FBcUMsRUFBRW1DLEdBQUcsQ0FBQyxDQUFDLElBQUluQyxDQUFXQSxHQUFHLEtBQUs7UUFDdEksT0FBTzZpQjtJQUNUO0lBQ0EsTUFBTXFRLGVBQWU7UUFDbkJwQixVQUFValAsQ0FBQUE7WUFDUkgsUUFBUTViLFVBQVUsQ0FBQytiLE1BQU01YixVQUFVLENBQUM5RSxFQUFFLENBQUMsR0FBRzBnQjtRQUM1QztRQUNBa1AsWUFBWWxQLENBQUFBO1lBQ1YsTUFBTWpjLFVBQVVvc0Isa0JBQWtCblEsTUFBTTViLFVBQVUsQ0FBQzlFLEVBQUU7WUFDckQsSUFBSSxDQUFDeUUsU0FBUztnQkFDWjtZQUNGO1lBQ0EsSUFBSWljLE1BQU1pUSxRQUFRLEtBQUtsc0IsUUFBUWtzQixRQUFRLEVBQUU7Z0JBQ3ZDO1lBQ0Y7WUFDQSxPQUFPcFEsUUFBUTViLFVBQVUsQ0FBQytiLE1BQU01YixVQUFVLENBQUM5RSxFQUFFLENBQUM7UUFDaEQ7UUFDQXlrQixTQUFTcU07UUFDVEYsVUFBVUM7UUFDVjlLLFFBQVEvbEIsQ0FBQUEsS0FBTXVMLFFBQVFzbEIsa0JBQWtCN3dCO1FBQ3hDMGxCLGNBQWM1cEIsQ0FBQUEsT0FBUW9KLE9BQU9DLE1BQU0sQ0FBQ29iLFFBQVE1YixVQUFVLEVBQUVXLE1BQU0sQ0FBQ29iLENBQUFBLFFBQVNBLE1BQU01YixVQUFVLENBQUNoSixJQUFJLEtBQUtBO0lBQ3BHO0lBQ0EsU0FBU3d0QjtRQUNQL0ksUUFBUXZiLFVBQVUsR0FBRyxDQUFDO1FBQ3RCdWIsUUFBUTViLFVBQVUsR0FBRyxDQUFDO1FBQ3RCMHJCLFlBQVl6cEIsTUFBTSxHQUFHO0lBQ3ZCO0lBQ0EsT0FBTztRQUNMckIsV0FBV21yQjtRQUNYdnNCLFdBQVc0c0I7UUFDWDNLO1FBQ0FrRDtJQUNGO0FBQ0Y7QUFFQSxTQUFTMEg7SUFDUCxNQUFNMU0sV0FBV2pxQixxREFBT0EsQ0FBQysxQixnQkFBZ0IsRUFBRTtJQUMzQzUyQixnREFBU0EsQ0FBQztRQUNSLE9BQU8sU0FBU3kzQjtZQUNkM00sU0FBU2dGLEtBQUs7UUFDaEI7SUFDRixHQUFHO1FBQUNoRjtLQUFTO0lBQ2IsT0FBT0E7QUFDVDtBQUVBLElBQUk0TSw2QkFBZTUzQiwwREFBbUIsQ0FBQztBQUV2QyxJQUFJODNCLGlCQUFpQjtJQUNuQixNQUFNOUQsT0FBT25PLFNBQVNtTyxJQUFJO0lBQzFCLENBQUNBLE9BQU9weUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQkFBK0JBLENBQVdBLEdBQUcsS0FBSztJQUNuSCxPQUFPeXZCO0FBQ1Q7QUFFQSxNQUFNK0QsaUJBQWlCO0lBQ3JCanlCLFVBQVU7SUFDVnFELE9BQU87SUFDUEMsUUFBUTtJQUNSa0ssUUFBUTtJQUNSMGtCLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZodUIsTUFBTTtJQUNOLGFBQWE7QUFDZjtBQUVBLE1BQU1pdUIsUUFBUXpGLENBQUFBLFlBQWEsQ0FBQyxpQkFBaUIsRUFBRUEsVUFBVSxDQUFDO0FBQzFELFNBQVMwRixhQUFhMUYsU0FBUztJQUM3QixNQUFNaHNCLEtBQUszRixxREFBT0EsQ0FBQyxJQUFNbzNCLE1BQU16RixZQUFZO1FBQUNBO0tBQVU7SUFDdEQsTUFBTXVDLE1BQU05MEIsNkNBQU1BLENBQUM7SUFDbkJELGdEQUFTQSxDQUFDLFNBQVNtNEI7UUFDakIsTUFBTWwxQixLQUFLMGlCLFNBQVNxTyxhQUFhLENBQUM7UUFDbENlLElBQUk5cEIsT0FBTyxHQUFHaEk7UUFDZEEsR0FBR3VELEVBQUUsR0FBR0E7UUFDUnZELEdBQUdxeEIsWUFBWSxDQUFDLGFBQWE7UUFDN0JyeEIsR0FBR3F4QixZQUFZLENBQUMsZUFBZTtRQUMvQjl5Qiw4RUFBUUEsQ0FBQ3lCLEdBQUcwZixLQUFLLEVBQUVrVjtRQUNuQkQsaUJBQWlCOUMsV0FBVyxDQUFDN3hCO1FBQzdCLE9BQU8sU0FBU20xQjtZQUNkeFIsV0FBVyxTQUFTcGE7Z0JBQ2xCLE1BQU1zbkIsT0FBTzhEO2dCQUNiLElBQUk5RCxLQUFLOWMsUUFBUSxDQUFDL1QsS0FBSztvQkFDckI2d0IsS0FBS2tCLFdBQVcsQ0FBQy94QjtnQkFDbkI7Z0JBQ0EsSUFBSUEsT0FBTzh4QixJQUFJOXBCLE9BQU8sRUFBRTtvQkFDdEI4cEIsSUFBSTlwQixPQUFPLEdBQUc7Z0JBQ2hCO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ3pFO0tBQUc7SUFDUCxNQUFNZ2dCLFdBQVcxbEIseURBQVdBLENBQUNvQixDQUFBQTtRQUMzQixNQUFNZSxLQUFLOHhCLElBQUk5cEIsT0FBTztRQUN0QixJQUFJaEksSUFBSTtZQUNOQSxHQUFHMHhCLFdBQVcsR0FBR3p5QjtZQUNqQjtRQUNGO1FBempKSixLQTBqSnlDLEdBQUdPLFFBQVEsQ0FBQzs7Ozs7Ozs7T0FROUMsRUFBRVAsUUFBUTtJQUNiLENBQUMsSUFBSSxDQUFNO0lBQ2IsR0FBRyxFQUFFO0lBQ0wsT0FBT3NrQjtBQUNUO0FBRUEsTUFBTTZSLFdBQVc7SUFDZkMsV0FBVztBQUNiO0FBQ0EsU0FBU0MsWUFBWWxHLE1BQU0sRUFBRTl1QixVQUFVODBCLFFBQVE7SUFDN0MsTUFBTTd4QixLQUFLMUcsa0RBQVc7SUFDdEIsT0FBT2UscURBQU9BLENBQUMsSUFBTSxDQUFDLEVBQUV3eEIsT0FBTyxFQUFFOXVCLFFBQVErMEIsU0FBUyxDQUFDLEVBQUU5eEIsR0FBRyxDQUFDLEVBQUU7UUFBQ2pELFFBQVErMEIsU0FBUztRQUFFakc7UUFBUTdyQjtLQUFHO0FBQzVGO0FBRUEsU0FBU2l5QixhQUFhLEVBQ3BCakcsU0FBUyxFQUNUMkUsUUFBUSxFQUNUO0lBQ0MsT0FBTyxDQUFDLGdCQUFnQixFQUFFM0UsVUFBVSxDQUFDLEVBQUUyRSxTQUFTLENBQUM7QUFDbkQ7QUFDQSxTQUFTdUIscUJBQXFCLEVBQzVCbEcsU0FBUyxFQUNUbUcsSUFBSSxFQUNMO0lBQ0MsTUFBTXhCLFdBQVdvQixZQUFZLGVBQWU7UUFDMUNELFdBQVc7SUFDYjtJQUNBLE1BQU05eEIsS0FBSzNGLHFEQUFPQSxDQUFDLElBQU00M0IsYUFBYTtZQUNwQ2pHO1lBQ0EyRTtRQUNGLElBQUk7UUFBQ0E7UUFBVTNFO0tBQVU7SUFDekJ4eUIsZ0RBQVNBLENBQUMsU0FBUzQ0QjtRQUNqQixNQUFNMzFCLEtBQUswaUIsU0FBU3FPLGFBQWEsQ0FBQztRQUNsQy93QixHQUFHdUQsRUFBRSxHQUFHQTtRQUNSdkQsR0FBRzB4QixXQUFXLEdBQUdnRTtRQUNqQjExQixHQUFHMGYsS0FBSyxDQUFDa1csT0FBTyxHQUFHO1FBQ25CakIsaUJBQWlCOUMsV0FBVyxDQUFDN3hCO1FBQzdCLE9BQU8sU0FBU3cwQjtZQUNkLE1BQU0zRCxPQUFPOEQ7WUFDYixJQUFJOUQsS0FBSzljLFFBQVEsQ0FBQy9ULEtBQUs7Z0JBQ3JCNndCLEtBQUtrQixXQUFXLENBQUMveEI7WUFDbkI7UUFDRjtJQUNGLEdBQUc7UUFBQ3VEO1FBQUlteUI7S0FBSztJQUNiLE9BQU9ueUI7QUFDVDtBQUVBLElBQUlzeUIsMkJBQWFoNUIsMERBQW1CLENBQUM7QUFFckMsSUFBSWk1QixtQkFBbUI7SUFDdEJDLE9BQU87SUFDUCxhQUFhO0FBQ2Q7QUFFQSxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsYUFBYXAzQixDQUFBQTtJQUNqQixNQUFNbUYsU0FBU2d5QixPQUFPRSxJQUFJLENBQUNyM0I7SUFDM0IsQ0FBRW1GLENBQUFBLFVBQVUsSUFBRyxJQUFLdkYsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLDhCQUE4QixFQUFFdkMsTUFBTSxDQUFDLElBQUl1QyxDQUFXQSxHQUFHLEtBQUs7SUFDNUksTUFBTSswQixRQUFRM1UsT0FBT3hkLE1BQU0sQ0FBQyxFQUFFO0lBQzlCLE1BQU1veUIsUUFBUTVVLE9BQU94ZCxNQUFNLENBQUMsRUFBRTtJQUM5QixNQUFNYSxRQUFRMmMsT0FBT3hkLE1BQU0sQ0FBQyxFQUFFO0lBQzlCLE9BQU87UUFDTG15QjtRQUNBQztRQUNBdnhCO1FBQ0F3eEIsS0FBS3gzQjtJQUNQO0FBQ0Y7QUFDQSxNQUFNeTNCLGNBQWMsQ0FBQ0MsVUFBVUM7SUFDN0IsSUFBSUEsT0FBT0wsS0FBSyxHQUFHSSxTQUFTSixLQUFLLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsSUFBSUssT0FBT0wsS0FBSyxHQUFHSSxTQUFTSixLQUFLLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsSUFBSUssT0FBT0osS0FBSyxHQUFHRyxTQUFTSCxLQUFLLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsSUFBSUksT0FBT0osS0FBSyxHQUFHRyxTQUFTSCxLQUFLLEVBQUU7UUFDakMsT0FBTztJQUNUO0lBQ0EsT0FBT0ksT0FBTzN4QixLQUFLLElBQUkweEIsU0FBUzF4QixLQUFLO0FBQ3ZDO0FBQ0EsSUFBSTR4QixvQkFBb0IsQ0FBQ0MsY0FBY0M7SUFDckMsTUFBTUMsVUFBVVgsV0FBV1M7SUFDM0IsTUFBTUYsU0FBU1AsV0FBV1U7SUFDMUIsSUFBSUwsWUFBWU0sU0FBU0osU0FBUztRQUNoQztJQUNGO0lBMXBKRixLQTJwSnVDLEdBQUdoM0IsUUFBUSxDQUFDO29CQUMvQixFQUFFZzNCLE9BQU9ILEdBQUcsQ0FBQzt3REFDdUIsRUFBRU8sUUFBUVAsR0FBRyxDQUFDOzs7RUFHcEUsQ0FBQyxJQUFJLENBQU07QUFDYjtBQUVBLE1BQU1RLFNBQVMsQ0FBQzs7Ozs7QUFLaEIsQ0FBQztBQUNELElBQUlDLGVBQWVyTyxDQUFBQTtJQUNqQixNQUFNc08sVUFBVXRPLElBQUlzTyxPQUFPO0lBQzNCLElBQUksQ0FBQ0EsU0FBUztRQTNxSmhCLEtBNHFKeUMsR0FBR3YzQixRQUFRLENBQUM7OztNQUcvQyxFQUFFcTNCLE9BQU87SUFDWCxDQUFDLElBQUksQ0FBTTtRQUNYO0lBQ0Y7SUFDQSxJQUFJRSxRQUFReFAsSUFBSSxDQUFDeVAsV0FBVyxPQUFPLFFBQVE7UUFucko3QyxLQW9ySnlDLEdBQUd4M0IsUUFBUSxDQUFDO29DQUNqQixFQUFFdTNCLFFBQVF4UCxJQUFJLENBQUM7O01BRTdDLEVBQUVzUCxPQUFPO0lBQ1gsQ0FBQyxJQUFJLENBQU07SUFDYjtJQUNBLElBQUlFLFFBQVFFLFFBQVEsS0FBSyxJQUFJO1FBMXJKL0IsS0Eyckp5QyxHQUFHejNCLFFBQVEsQ0FBQzs2Q0FDUixFQUFFdTNCLFFBQVFFLFFBQVEsQ0FBQzs7O01BRzFELEVBQUVKLE9BQU87SUFDWCxDQUFDLElBQUksQ0FBTTtJQUNiO0FBQ0Y7QUFFQSxTQUFTSyxPQUFPQyxPQUFPO0lBQ3JCLElBQUkxNEIsSUFBeUIsRUFBYztRQUN6QzA0QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxtQkFBbUIzMkIsRUFBRSxFQUFFNDJCLE1BQU07SUFDcENILE9BQU87UUFDTG42QixnREFBU0EsQ0FBQztZQUNSLElBQUk7Z0JBQ0YwRDtZQUNGLEVBQUUsT0FBTzYyQixHQUFHO2dCQUNWNTNCLE1BQU0sQ0FBQzs7O1lBR0gsRUFBRTQzQixFQUFFcjRCLE9BQU8sQ0FBQztRQUNoQixDQUFDO1lBQ0g7UUFDRixHQUFHbzRCO0lBQ0w7QUFDRjtBQUVBLFNBQVNFO0lBQ1BILG1CQUFtQjtRQUNqQlgsa0JBQWtCWCxpQkFBaUJDLEtBQUssRUFBRWw1QixzREFBYTtRQUN2RGk2QixhQUFhcFU7SUFDZixHQUFHLEVBQUU7QUFDUDtBQUVBLFNBQVMrVSxZQUFZenZCLE9BQU87SUFDMUIsTUFBTThwQixNQUFNOTBCLDZDQUFNQSxDQUFDZ0w7SUFDbkJqTCxnREFBU0EsQ0FBQztRQUNSKzBCLElBQUk5cEIsT0FBTyxHQUFHQTtJQUNoQjtJQUNBLE9BQU84cEI7QUFDVDtBQUVBLFNBQVM0RjtJQUNQLElBQUlDLE9BQU87SUFDWCxTQUFTQztRQUNQLE9BQU85b0IsUUFBUTZvQjtJQUNqQjtJQUNBLFNBQVM1VSxTQUFTbGtCLEtBQUs7UUFDckIsT0FBT0EsVUFBVTg0QjtJQUNuQjtJQUNBLFNBQVNFLE1BQU1DLE9BQU87UUFDcEIsQ0FBQyxDQUFDSCxPQUFPbDVCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sZ0RBQWdEQSxDQUFXQSxHQUFHLEtBQUs7UUFDckksTUFBTTIyQixVQUFVO1lBQ2REO1FBQ0Y7UUFDQUgsT0FBT0k7UUFDUCxPQUFPQTtJQUNUO0lBQ0EsU0FBU0M7UUFDUCxDQUFDTCxPQUFPbDVCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sK0NBQStDQSxDQUFXQSxHQUFHLEtBQUs7UUFDbkl1MkIsT0FBTztJQUNUO0lBQ0EsU0FBU007UUFDUCxJQUFJTixNQUFNO1lBQ1JBLEtBQUtHLE9BQU87WUFDWkU7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMSjtRQUNBN1U7UUFDQThVO1FBQ0FHO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNuMkIsV0FBV3VVLEtBQUs7SUFDdkIsSUFBSUEsTUFBTVUsS0FBSyxLQUFLLFVBQVVWLE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7UUFDOUQsT0FBTztJQUNUO0lBQ0EsT0FBT1YsTUFBTXZVLFVBQVU7QUFDekI7QUFFQSxNQUFNbzJCLE1BQU07QUFDWixNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsV0FBVztBQUNqQixNQUFNenhCLE1BQU07QUFDWixNQUFNMlAsT0FBTztBQUNiLE1BQU0raEIsWUFBWTtBQUNsQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsWUFBWTtBQUVsQixNQUFNQyxnQkFBZ0I7SUFDcEIsQ0FBQ1QsTUFBTSxFQUFFO0lBQ1QsQ0FBQ0QsSUFBSSxFQUFFO0FBQ1Q7QUFDQSxJQUFJVywyQkFBMkJqM0IsQ0FBQUE7SUFDN0IsSUFBSWczQixhQUFhLENBQUNoM0IsTUFBTWszQixPQUFPLENBQUMsRUFBRTtRQUNoQ2wzQixNQUFNSyxjQUFjO0lBQ3RCO0FBQ0Y7QUFFQSxNQUFNODJCLHFCQUFxQixDQUFDO0lBQzFCLE1BQU16SixPQUFPO0lBQ2IsSUFBSSxPQUFPNU0sYUFBYSxhQUFhO1FBQ25DLE9BQU80TTtJQUNUO0lBQ0EsTUFBTTdiLGFBQWE7UUFBQzZiO1FBQU0sQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQztRQUFFLENBQUMsTUFBTSxFQUFFQSxLQUFLLENBQUM7UUFBRSxDQUFDLEdBQUcsRUFBRUEsS0FBSyxDQUFDO1FBQUUsQ0FBQyxDQUFDLEVBQUVBLEtBQUssQ0FBQztLQUFDO0lBQ2pGLE1BQU0wSixZQUFZdmxCLFdBQVduRixJQUFJLENBQUM5TixDQUFBQSxZQUFhLENBQUMsRUFBRSxFQUFFQSxVQUFVLENBQUMsSUFBSWtpQjtJQUNuRSxPQUFPc1csYUFBYTFKO0FBQ3RCO0FBRUEsTUFBTTJKLGdCQUFnQjtBQUN0QixNQUFNQyx1QkFBdUI7QUFDN0IsU0FBU0MsK0JBQStCaG9CLFFBQVEsRUFBRW5KLE9BQU87SUFDdkQsT0FBTy9DLEtBQUttMEIsR0FBRyxDQUFDcHhCLFFBQVE1RCxDQUFDLEdBQUcrTSxTQUFTL00sQ0FBQyxLQUFLODBCLHdCQUF3QmowQixLQUFLbTBCLEdBQUcsQ0FBQ3B4QixRQUFRM0QsQ0FBQyxHQUFHOE0sU0FBUzlNLENBQUMsS0FBSzYwQjtBQUN6RztBQUNBLE1BQU1HLFNBQVM7SUFDYmg2QixNQUFNO0FBQ1I7QUFDQSxTQUFTaTZCLG1CQUFtQixFQUMxQnJXLE1BQU0sRUFDTjFHLFNBQVMsRUFDVGdkLFFBQVEsRUFDUkMsUUFBUSxFQUNUO0lBQ0MsT0FBTztRQUFDO1lBQ05oNUIsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTSxFQUNKNjNCLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRy8zQjtnQkFDSixJQUFJNjNCLFdBQVdSLGVBQWU7b0JBQzVCO2dCQUNGO2dCQUNBLE1BQU1yMEIsUUFBUTtvQkFDWlIsR0FBR3MxQjtvQkFDSHIxQixHQUFHczFCO2dCQUNMO2dCQUNBLE1BQU01aUIsUUFBUXdpQjtnQkFDZCxJQUFJeGlCLE1BQU0xWCxJQUFJLEtBQUssWUFBWTtvQkFDN0J1QyxNQUFNSyxjQUFjO29CQUNwQjhVLE1BQU02aUIsT0FBTyxDQUFDL2IsSUFBSSxDQUFDalo7b0JBQ25CO2dCQUNGO2dCQUNBLENBQUVtUyxDQUFBQSxNQUFNMVgsSUFBSSxLQUFLLFNBQVEsSUFBS1osS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxvQkFBb0JBLENBQVdBLEdBQUcsS0FBSztnQkFDOUgsTUFBTXk0QixVQUFVOWlCLE1BQU1uUyxLQUFLO2dCQUMzQixJQUFJLENBQUN1MEIsK0JBQStCVSxTQUFTajFCLFFBQVE7b0JBQ25EO2dCQUNGO2dCQUNBaEQsTUFBTUssY0FBYztnQkFDcEIsTUFBTTIzQixVQUFVN2lCLE1BQU02aUIsT0FBTyxDQUFDRSxTQUFTLENBQUNsMUI7Z0JBQ3hDNDBCLFNBQVM7b0JBQ1BuNkIsTUFBTTtvQkFDTnU2QjtnQkFDRjtZQUNGO1FBQ0Y7UUFBRztZQUNEcDVCLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGLE1BQU1tVixRQUFRd2lCO2dCQUNkLElBQUl4aUIsTUFBTTFYLElBQUksS0FBSyxZQUFZO29CQUM3QjRqQjtvQkFDQTtnQkFDRjtnQkFDQXJoQixNQUFNSyxjQUFjO2dCQUNwQjhVLE1BQU02aUIsT0FBTyxDQUFDcmIsSUFBSSxDQUFDO29CQUNqQndiLHNCQUFzQjtnQkFDeEI7Z0JBQ0F4ZDtZQUNGO1FBQ0Y7UUFBRztZQUNEL2IsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsSUFBSTIzQixXQUFXbDZCLElBQUksS0FBSyxZQUFZO29CQUNsQ3VDLE1BQU1LLGNBQWM7Z0JBQ3RCO2dCQUNBZ2hCO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R6aUIsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTW1WLFFBQVF3aUI7Z0JBQ2QsSUFBSXhpQixNQUFNMVgsSUFBSSxLQUFLLFdBQVc7b0JBQzVCNGpCO29CQUNBO2dCQUNGO2dCQUNBLElBQUlyaEIsTUFBTWszQixPQUFPLEtBQUtWLFFBQVE7b0JBQzVCeDJCLE1BQU1LLGNBQWM7b0JBQ3BCZ2hCO29CQUNBO2dCQUNGO2dCQUNBNFYseUJBQXlCajNCO1lBQzNCO1FBQ0Y7UUFBRztZQUNEcEIsV0FBVztZQUNYQyxJQUFJd2lCO1FBQ047UUFBRztZQUNEemlCLFdBQVc7WUFDWEYsU0FBUztnQkFDUGtpQixTQUFTO2dCQUNUQyxTQUFTO1lBQ1g7WUFDQWhpQixJQUFJO2dCQUNGLElBQUk4NEIsV0FBV2w2QixJQUFJLEtBQUssV0FBVztvQkFDakM0akI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQUc7WUFDRHppQixXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixNQUFNbVYsUUFBUXdpQjtnQkFDZCxDQUFFeGlCLENBQUFBLE1BQU0xWCxJQUFJLEtBQUssTUFBSyxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNCQUFzQkEsQ0FBV0EsR0FBRyxLQUFLO2dCQUM3SCxJQUFJMlYsTUFBTTZpQixPQUFPLENBQUNJLHVCQUF1QixJQUFJO29CQUMzQy9XO29CQUNBO2dCQUNGO2dCQUNBcmhCLE1BQU1LLGNBQWM7WUFDdEI7UUFDRjtRQUFHO1lBQ0R6QixXQUFXdTRCO1lBQ1h0NEIsSUFBSXdpQjtRQUNOO0tBQUU7QUFDSjtBQUNBLFNBQVNnWCxlQUFlQyxHQUFHO0lBQ3pCLE1BQU1DLFdBQVduOUIsNkNBQU1BLENBQUNxOEI7SUFDeEIsTUFBTWUsa0JBQWtCcDlCLDZDQUFNQSxDQUFDMkM7SUFDL0IsTUFBTTA2QixzQkFBc0J6OEIscURBQU9BLENBQUMsSUFBTztZQUN6QzRDLFdBQVc7WUFDWEMsSUFBSSxTQUFTNjVCLFlBQVkxNEIsS0FBSztnQkFDNUIsSUFBSUEsTUFBTTI0QixnQkFBZ0IsRUFBRTtvQkFDMUI7Z0JBQ0Y7Z0JBQ0EsSUFBSTM0QixNQUFNNjNCLE1BQU0sS0FBS1IsZUFBZTtvQkFDbEM7Z0JBQ0Y7Z0JBQ0EsSUFBSXIzQixNQUFNNDRCLE9BQU8sSUFBSTU0QixNQUFNNjRCLE9BQU8sSUFBSTc0QixNQUFNODRCLFFBQVEsSUFBSTk0QixNQUFNKzRCLE1BQU0sRUFBRTtvQkFDcEU7Z0JBQ0Y7Z0JBQ0EsTUFBTWozQixjQUFjdzJCLElBQUlVLHNCQUFzQixDQUFDaDVCO2dCQUMvQyxJQUFJLENBQUM4QixhQUFhO29CQUNoQjtnQkFDRjtnQkFDQSxNQUFNazJCLFVBQVVNLElBQUlXLFVBQVUsQ0FBQ24zQixhQUFhc2YsTUFBTTtvQkFDaEQ4WCxhQUFhbDVCO2dCQUNmO2dCQUNBLElBQUksQ0FBQ2c0QixTQUFTO29CQUNaO2dCQUNGO2dCQUNBaDRCLE1BQU1LLGNBQWM7Z0JBQ3BCLE1BQU0yQyxRQUFRO29CQUNaUixHQUFHeEMsTUFBTTgzQixPQUFPO29CQUNoQnIxQixHQUFHekMsTUFBTSszQixPQUFPO2dCQUNsQjtnQkFDQVMsZ0JBQWdCcHlCLE9BQU87Z0JBQ3ZCK3lCLGlCQUFpQm5CLFNBQVNoMUI7WUFDNUI7UUFDRixJQUFJO1FBQUNzMUI7S0FBSTtJQUNULE1BQU1jLDJCQUEyQnA5QixxREFBT0EsQ0FBQyxJQUFPO1lBQzlDNEMsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsSUFBSUEsTUFBTTI0QixnQkFBZ0IsRUFBRTtvQkFDMUI7Z0JBQ0Y7Z0JBQ0EsTUFBTWgzQixLQUFLMjJCLElBQUlVLHNCQUFzQixDQUFDaDVCO2dCQUN0QyxJQUFJLENBQUMyQixJQUFJO29CQUNQO2dCQUNGO2dCQUNBLE1BQU1qRCxVQUFVNDVCLElBQUllLHVCQUF1QixDQUFDMTNCO2dCQUM1QyxJQUFJLENBQUNqRCxTQUFTO29CQUNaO2dCQUNGO2dCQUNBLElBQUlBLFFBQVEwNUIsdUJBQXVCLEVBQUU7b0JBQ25DO2dCQUNGO2dCQUNBLElBQUksQ0FBQ0UsSUFBSWdCLFVBQVUsQ0FBQzMzQixLQUFLO29CQUN2QjtnQkFDRjtnQkFDQTNCLE1BQU1LLGNBQWM7WUFDdEI7UUFDRixJQUFJO1FBQUNpNEI7S0FBSTtJQUNULE1BQU1pQixtQkFBbUJ0OUIseURBQVdBLENBQUMsU0FBU3M5QjtRQUM1QyxNQUFNNzZCLFVBQVU7WUFDZGtpQixTQUFTO1lBQ1RDLFNBQVM7UUFDWDtRQUNBMlgsZ0JBQWdCcHlCLE9BQU8sR0FBR2pJLFdBQVdULFFBQVE7WUFBQzA3QjtZQUEwQlg7U0FBb0IsRUFBRS81QjtJQUNoRyxHQUFHO1FBQUMwNkI7UUFBMEJYO0tBQW9CO0lBQ2xELE1BQU1yWCxPQUFPbmxCLHlEQUFXQSxDQUFDO1FBQ3ZCLE1BQU1tSyxVQUFVbXlCLFNBQVNueUIsT0FBTztRQUNoQyxJQUFJQSxRQUFRM0ksSUFBSSxLQUFLLFFBQVE7WUFDM0I7UUFDRjtRQUNBODZCLFNBQVNueUIsT0FBTyxHQUFHcXhCO1FBQ25CZSxnQkFBZ0JweUIsT0FBTztRQUN2Qm16QjtJQUNGLEdBQUc7UUFBQ0E7S0FBaUI7SUFDckIsTUFBTWxZLFNBQVNwbEIseURBQVdBLENBQUM7UUFDekIsTUFBTWtaLFFBQVFvakIsU0FBU255QixPQUFPO1FBQzlCZ2I7UUFDQSxJQUFJak0sTUFBTTFYLElBQUksS0FBSyxZQUFZO1lBQzdCMFgsTUFBTTZpQixPQUFPLENBQUMzVyxNQUFNLENBQUM7Z0JBQ25COFcsc0JBQXNCO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJaGpCLE1BQU0xWCxJQUFJLEtBQUssV0FBVztZQUM1QjBYLE1BQU02aUIsT0FBTyxDQUFDOVQsS0FBSztRQUNyQjtJQUNGLEdBQUc7UUFBQzlDO0tBQUs7SUFDVCxNQUFNb1ksc0JBQXNCdjlCLHlEQUFXQSxDQUFDLFNBQVN1OUI7UUFDL0MsTUFBTTk2QixVQUFVO1lBQ2RtaUIsU0FBUztZQUNURCxTQUFTO1FBQ1g7UUFDQSxNQUFNdmlCLFdBQVdxNUIsbUJBQW1CO1lBQ2xDclc7WUFDQTFHLFdBQVd5RztZQUNYdVcsVUFBVSxJQUFNWSxTQUFTbnlCLE9BQU87WUFDaEN3eEIsVUFBVXppQixDQUFBQTtnQkFDUm9qQixTQUFTbnlCLE9BQU8sR0FBRytPO1lBQ3JCO1FBQ0Y7UUFDQXFqQixnQkFBZ0JweUIsT0FBTyxHQUFHakksV0FBV1QsUUFBUVcsVUFBVUs7SUFDekQsR0FBRztRQUFDMmlCO1FBQVFEO0tBQUs7SUFDakIsTUFBTStYLG1CQUFtQmw5Qix5REFBV0EsQ0FBQyxTQUFTazlCLGlCQUFpQm5CLE9BQU8sRUFBRWgxQixLQUFLO1FBQzNFLENBQUV1MUIsQ0FBQUEsU0FBU255QixPQUFPLENBQUMzSSxJQUFJLEtBQUssTUFBSyxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGdEQUFnREEsQ0FBV0EsR0FBRyxLQUFLO1FBQ2xLKzRCLFNBQVNueUIsT0FBTyxHQUFHO1lBQ2pCM0ksTUFBTTtZQUNOdUY7WUFDQWcxQjtRQUNGO1FBQ0F3QjtJQUNGLEdBQUc7UUFBQ0E7S0FBb0I7SUFDeEJ0SywwQkFBMEIsU0FBUzZFO1FBQ2pDd0Y7UUFDQSxPQUFPLFNBQVMzRztZQUNkNEYsZ0JBQWdCcHlCLE9BQU87UUFDekI7SUFDRixHQUFHO1FBQUNtekI7S0FBaUI7QUFDdkI7QUFFQSxTQUFTRSxVQUFVO0FBQ25CLE1BQU1DLGlCQUFpQjtJQUNyQixDQUFDL0MsU0FBUyxFQUFFO0lBQ1osQ0FBQ0QsT0FBTyxFQUFFO0lBQ1YsQ0FBQzdoQixLQUFLLEVBQUU7SUFDUixDQUFDM1AsSUFBSSxFQUFFO0FBQ1Q7QUFDQSxTQUFTeTBCLG9CQUFvQjNCLE9BQU8sRUFBRTVXLElBQUk7SUFDeEMsU0FBU0M7UUFDUEQ7UUFDQTRXLFFBQVEzVyxNQUFNO0lBQ2hCO0lBQ0EsU0FBUzFFO1FBQ1B5RTtRQUNBNFcsUUFBUXJiLElBQUk7SUFDZDtJQUNBLE9BQU87UUFBQztZQUNOL2QsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsSUFBSUEsTUFBTWszQixPQUFPLEtBQUtWLFFBQVE7b0JBQzVCeDJCLE1BQU1LLGNBQWM7b0JBQ3BCZ2hCO29CQUNBO2dCQUNGO2dCQUNBLElBQUlyaEIsTUFBTWszQixPQUFPLEtBQUtULE9BQU87b0JBQzNCejJCLE1BQU1LLGNBQWM7b0JBQ3BCc2M7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsSUFBSTNjLE1BQU1rM0IsT0FBTyxLQUFLSCxXQUFXO29CQUMvQi8yQixNQUFNSyxjQUFjO29CQUNwQjIzQixRQUFRM2IsUUFBUTtvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsSUFBSXJjLE1BQU1rM0IsT0FBTyxLQUFLTCxTQUFTO29CQUM3QjcyQixNQUFNSyxjQUFjO29CQUNwQjIzQixRQUFRNWIsTUFBTTtvQkFDZDtnQkFDRjtnQkFDQSxJQUFJcGMsTUFBTWszQixPQUFPLEtBQUtKLFlBQVk7b0JBQ2hDOTJCLE1BQU1LLGNBQWM7b0JBQ3BCMjNCLFFBQVExYixTQUFTO29CQUNqQjtnQkFDRjtnQkFDQSxJQUFJdGMsTUFBTWszQixPQUFPLEtBQUtOLFdBQVc7b0JBQy9CNTJCLE1BQU1LLGNBQWM7b0JBQ3BCMjNCLFFBQVF6YixRQUFRO29CQUNoQjtnQkFDRjtnQkFDQSxJQUFJbWQsY0FBYyxDQUFDMTVCLE1BQU1rM0IsT0FBTyxDQUFDLEVBQUU7b0JBQ2pDbDNCLE1BQU1LLGNBQWM7b0JBQ3BCO2dCQUNGO2dCQUNBNDJCLHlCQUF5QmozQjtZQUMzQjtRQUNGO1FBQUc7WUFDRHBCLFdBQVc7WUFDWEMsSUFBSXdpQjtRQUNOO1FBQUc7WUFDRHppQixXQUFXO1lBQ1hDLElBQUl3aUI7UUFDTjtRQUFHO1lBQ0R6aUIsV0FBVztZQUNYQyxJQUFJd2lCO1FBQ047UUFBRztZQUNEemlCLFdBQVc7WUFDWEMsSUFBSXdpQjtRQUNOO1FBQUc7WUFDRHppQixXQUFXO1lBQ1hDLElBQUl3aUI7UUFDTjtRQUFHO1lBQ0R6aUIsV0FBVztZQUNYQyxJQUFJd2lCO1lBQ0ozaUIsU0FBUztnQkFDUGtpQixTQUFTO1lBQ1g7UUFDRjtRQUFHO1lBQ0RoaUIsV0FBV3U0QjtZQUNYdDRCLElBQUl3aUI7UUFDTjtLQUFFO0FBQ0o7QUFDQSxTQUFTdVksa0JBQWtCdEIsR0FBRztJQUM1QixNQUFNRSxrQkFBa0JwOUIsNkNBQU1BLENBQUNxK0I7SUFDL0IsTUFBTWhCLHNCQUFzQno4QixxREFBT0EsQ0FBQyxJQUFPO1lBQ3pDNEMsV0FBVztZQUNYQyxJQUFJLFNBQVNnN0IsVUFBVTc1QixLQUFLO2dCQUMxQixJQUFJQSxNQUFNMjRCLGdCQUFnQixFQUFFO29CQUMxQjtnQkFDRjtnQkFDQSxJQUFJMzRCLE1BQU1rM0IsT0FBTyxLQUFLVCxPQUFPO29CQUMzQjtnQkFDRjtnQkFDQSxNQUFNMzBCLGNBQWN3MkIsSUFBSVUsc0JBQXNCLENBQUNoNUI7Z0JBQy9DLElBQUksQ0FBQzhCLGFBQWE7b0JBQ2hCO2dCQUNGO2dCQUNBLE1BQU1nNEIsVUFBVXhCLElBQUlXLFVBQVUsQ0FBQ24zQixhQUFhc2YsTUFBTTtvQkFDaEQ4WCxhQUFhbDVCO2dCQUNmO2dCQUNBLElBQUksQ0FBQzg1QixTQUFTO29CQUNaO2dCQUNGO2dCQUNBOTVCLE1BQU1LLGNBQWM7Z0JBQ3BCLElBQUkwNUIsY0FBYztnQkFDbEIsTUFBTS9CLFVBQVU4QixRQUFRRSxRQUFRO2dCQUNoQ3hCLGdCQUFnQnB5QixPQUFPO2dCQUN2QixTQUFTZ2I7b0JBQ1AsQ0FBQzJZLGNBQWNsOUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw4REFBOERBLENBQVdBLEdBQUcsS0FBSztvQkFDekp1NkIsY0FBYztvQkFDZHZCLGdCQUFnQnB5QixPQUFPO29CQUN2Qm16QjtnQkFDRjtnQkFDQWYsZ0JBQWdCcHlCLE9BQU8sR0FBR2pJLFdBQVdULFFBQVFpOEIsb0JBQW9CM0IsU0FBUzVXLE9BQU87b0JBQy9FUCxTQUFTO29CQUNURCxTQUFTO2dCQUNYO1lBQ0Y7UUFDRixJQUFJO1FBQUMwWDtLQUFJO0lBQ1QsTUFBTWlCLG1CQUFtQnQ5Qix5REFBV0EsQ0FBQyxTQUFTZytCO1FBQzVDLE1BQU12N0IsVUFBVTtZQUNka2lCLFNBQVM7WUFDVEMsU0FBUztRQUNYO1FBQ0EyWCxnQkFBZ0JweUIsT0FBTyxHQUFHakksV0FBV1QsUUFBUTtZQUFDKzZCO1NBQW9CLEVBQUUvNUI7SUFDdEUsR0FBRztRQUFDKzVCO0tBQW9CO0lBQ3hCdkosMEJBQTBCLFNBQVM2RTtRQUNqQ3dGO1FBQ0EsT0FBTyxTQUFTM0c7WUFDZDRGLGdCQUFnQnB5QixPQUFPO1FBQ3pCO0lBQ0YsR0FBRztRQUFDbXpCO0tBQWlCO0FBQ3ZCO0FBRUEsTUFBTVcsT0FBTztJQUNYejhCLE1BQU07QUFDUjtBQUNBLE1BQU0wOEIsbUJBQW1CO0FBQ3pCLE1BQU1DLHNCQUFzQjtBQUM1QixTQUFTQyxrQkFBa0IsRUFDekJoWixNQUFNLEVBQ05zVyxRQUFRLEVBQ1Q7SUFDQyxPQUFPO1FBQUM7WUFDTi80QixXQUFXO1lBQ1hDLElBQUl3aUI7UUFDTjtRQUFHO1lBQ0R6aUIsV0FBVztZQUNYQyxJQUFJd2lCO1FBQ047UUFBRztZQUNEemlCLFdBQVc7WUFDWEMsSUFBSW1CLENBQUFBO2dCQUNGQSxNQUFNSyxjQUFjO1lBQ3RCO1FBQ0Y7UUFBRztZQUNEekIsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsSUFBSTIzQixXQUFXbDZCLElBQUksS0FBSyxZQUFZO29CQUNsQzRqQjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJcmhCLE1BQU1rM0IsT0FBTyxLQUFLVixRQUFRO29CQUM1QngyQixNQUFNSyxjQUFjO2dCQUN0QjtnQkFDQWdoQjtZQUNGO1FBQ0Y7UUFBRztZQUNEemlCLFdBQVd1NEI7WUFDWHQ0QixJQUFJd2lCO1FBQ047S0FBRTtBQUNKO0FBQ0EsU0FBU2laLGtCQUFrQixFQUN6QmpaLE1BQU0sRUFDTjFHLFNBQVMsRUFDVGdkLFFBQVEsRUFDVDtJQUNDLE9BQU87UUFBQztZQUNOLzRCLFdBQVc7WUFDWEYsU0FBUztnQkFDUG1pQixTQUFTO1lBQ1g7WUFDQWhpQixJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTW1WLFFBQVF3aUI7Z0JBQ2QsSUFBSXhpQixNQUFNMVgsSUFBSSxLQUFLLFlBQVk7b0JBQzdCNGpCO29CQUNBO2dCQUNGO2dCQUNBbE0sTUFBTW9sQixRQUFRLEdBQUc7Z0JBQ2pCLE1BQU0sRUFDSnpDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcvM0IsTUFBTXc2QixPQUFPLENBQUMsRUFBRTtnQkFDcEIsTUFBTXgzQixRQUFRO29CQUNaUixHQUFHczFCO29CQUNIcjFCLEdBQUdzMUI7Z0JBQ0w7Z0JBQ0EvM0IsTUFBTUssY0FBYztnQkFDcEI4VSxNQUFNNmlCLE9BQU8sQ0FBQy9iLElBQUksQ0FBQ2paO1lBQ3JCO1FBQ0Y7UUFBRztZQUNEcEUsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTW1WLFFBQVF3aUI7Z0JBQ2QsSUFBSXhpQixNQUFNMVgsSUFBSSxLQUFLLFlBQVk7b0JBQzdCNGpCO29CQUNBO2dCQUNGO2dCQUNBcmhCLE1BQU1LLGNBQWM7Z0JBQ3BCOFUsTUFBTTZpQixPQUFPLENBQUNyYixJQUFJLENBQUM7b0JBQ2pCd2Isc0JBQXNCO2dCQUN4QjtnQkFDQXhkO1lBQ0Y7UUFDRjtRQUFHO1lBQ0QvYixXQUFXO1lBQ1hDLElBQUltQixDQUFBQTtnQkFDRixJQUFJMjNCLFdBQVdsNkIsSUFBSSxLQUFLLFlBQVk7b0JBQ2xDNGpCO29CQUNBO2dCQUNGO2dCQUNBcmhCLE1BQU1LLGNBQWM7Z0JBQ3BCZ2hCO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R6aUIsV0FBVztZQUNYQyxJQUFJbUIsQ0FBQUE7Z0JBQ0YsTUFBTW1WLFFBQVF3aUI7Z0JBQ2QsQ0FBRXhpQixDQUFBQSxNQUFNMVgsSUFBSSxLQUFLLE1BQUssSUFBS1osS0FBcUMsR0FBRzJDLGNBQWNBLENBQVdBLEdBQUcsS0FBSztnQkFDcEcsTUFBTWk3QixRQUFRejZCLE1BQU13NkIsT0FBTyxDQUFDLEVBQUU7Z0JBQzlCLElBQUksQ0FBQ0MsT0FBTztvQkFDVjtnQkFDRjtnQkFDQSxNQUFNQyxlQUFlRCxNQUFNRSxLQUFLLElBQUlQO2dCQUNwQyxJQUFJLENBQUNNLGNBQWM7b0JBQ2pCO2dCQUNGO2dCQUNBLE1BQU1FLGdCQUFnQnpsQixNQUFNNmlCLE9BQU8sQ0FBQ0ksdUJBQXVCO2dCQUMzRCxJQUFJampCLE1BQU0xWCxJQUFJLEtBQUssV0FBVztvQkFDNUIsSUFBSW05QixlQUFlO3dCQUNqQnZaO29CQUNGO29CQUNBO2dCQUNGO2dCQUNBLElBQUl1WixlQUFlO29CQUNqQixJQUFJemxCLE1BQU1vbEIsUUFBUSxFQUFFO3dCQUNsQnY2QixNQUFNSyxjQUFjO3dCQUNwQjtvQkFDRjtvQkFDQWdoQjtvQkFDQTtnQkFDRjtnQkFDQXJoQixNQUFNSyxjQUFjO1lBQ3RCO1FBQ0Y7UUFBRztZQUNEekIsV0FBV3U0QjtZQUNYdDRCLElBQUl3aUI7UUFDTjtLQUFFO0FBQ0o7QUFDQSxTQUFTd1osZUFBZXZDLEdBQUc7SUFDekIsTUFBTUMsV0FBV245Qiw2Q0FBTUEsQ0FBQzgrQjtJQUN4QixNQUFNMUIsa0JBQWtCcDlCLDZDQUFNQSxDQUFDMkM7SUFDL0IsTUFBTTQ1QixXQUFXMTdCLHlEQUFXQSxDQUFDLFNBQVMwN0I7UUFDcEMsT0FBT1ksU0FBU255QixPQUFPO0lBQ3pCLEdBQUcsRUFBRTtJQUNMLE1BQU13eEIsV0FBVzM3Qix5REFBV0EsQ0FBQyxTQUFTMjdCLFNBQVN6aUIsS0FBSztRQUNsRG9qQixTQUFTbnlCLE9BQU8sR0FBRytPO0lBQ3JCLEdBQUcsRUFBRTtJQUNMLE1BQU1zakIsc0JBQXNCejhCLHFEQUFPQSxDQUFDLElBQU87WUFDekM0QyxXQUFXO1lBQ1hDLElBQUksU0FBU2k4QixhQUFhOTZCLEtBQUs7Z0JBQzdCLElBQUlBLE1BQU0yNEIsZ0JBQWdCLEVBQUU7b0JBQzFCO2dCQUNGO2dCQUNBLE1BQU03MkIsY0FBY3cyQixJQUFJVSxzQkFBc0IsQ0FBQ2g1QjtnQkFDL0MsSUFBSSxDQUFDOEIsYUFBYTtvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsTUFBTWsyQixVQUFVTSxJQUFJVyxVQUFVLENBQUNuM0IsYUFBYXNmLE1BQU07b0JBQ2hEOFgsYUFBYWw1QjtnQkFDZjtnQkFDQSxJQUFJLENBQUNnNEIsU0FBUztvQkFDWjtnQkFDRjtnQkFDQSxNQUFNeUMsUUFBUXo2QixNQUFNdzZCLE9BQU8sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLEVBQ0oxQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHMEM7Z0JBQ0osTUFBTXozQixRQUFRO29CQUNaUixHQUFHczFCO29CQUNIcjFCLEdBQUdzMUI7Z0JBQ0w7Z0JBQ0FTLGdCQUFnQnB5QixPQUFPO2dCQUN2Qit5QixpQkFBaUJuQixTQUFTaDFCO1lBQzVCO1FBQ0YsSUFBSTtRQUFDczFCO0tBQUk7SUFDVCxNQUFNaUIsbUJBQW1CdDlCLHlEQUFXQSxDQUFDLFNBQVNzOUI7UUFDNUMsTUFBTTc2QixVQUFVO1lBQ2RtaUIsU0FBUztZQUNURCxTQUFTO1FBQ1g7UUFDQTRYLGdCQUFnQnB5QixPQUFPLEdBQUdqSSxXQUFXVCxRQUFRO1lBQUMrNkI7U0FBb0IsRUFBRS81QjtJQUN0RSxHQUFHO1FBQUMrNUI7S0FBb0I7SUFDeEIsTUFBTXJYLE9BQU9ubEIseURBQVdBLENBQUM7UUFDdkIsTUFBTW1LLFVBQVVteUIsU0FBU255QixPQUFPO1FBQ2hDLElBQUlBLFFBQVEzSSxJQUFJLEtBQUssUUFBUTtZQUMzQjtRQUNGO1FBQ0EsSUFBSTJJLFFBQVEzSSxJQUFJLEtBQUssV0FBVztZQUM5QnVrQixhQUFhNWIsUUFBUTIwQixnQkFBZ0I7UUFDdkM7UUFDQW5ELFNBQVNzQztRQUNUMUIsZ0JBQWdCcHlCLE9BQU87UUFDdkJtekI7SUFDRixHQUFHO1FBQUNBO1FBQWtCM0I7S0FBUztJQUMvQixNQUFNdlcsU0FBU3BsQix5REFBV0EsQ0FBQztRQUN6QixNQUFNa1osUUFBUW9qQixTQUFTbnlCLE9BQU87UUFDOUJnYjtRQUNBLElBQUlqTSxNQUFNMVgsSUFBSSxLQUFLLFlBQVk7WUFDN0IwWCxNQUFNNmlCLE9BQU8sQ0FBQzNXLE1BQU0sQ0FBQztnQkFDbkI4VyxzQkFBc0I7WUFDeEI7UUFDRjtRQUNBLElBQUloakIsTUFBTTFYLElBQUksS0FBSyxXQUFXO1lBQzVCMFgsTUFBTTZpQixPQUFPLENBQUM5VCxLQUFLO1FBQ3JCO0lBQ0YsR0FBRztRQUFDOUM7S0FBSztJQUNULE1BQU1vWSxzQkFBc0J2OUIseURBQVdBLENBQUMsU0FBU3U5QjtRQUMvQyxNQUFNOTZCLFVBQVU7WUFDZG1pQixTQUFTO1lBQ1RELFNBQVM7UUFDWDtRQUNBLE1BQU0vZ0IsT0FBTztZQUNYd2hCO1lBQ0ExRyxXQUFXeUc7WUFDWHVXO1FBQ0Y7UUFDQSxNQUFNcUQsZUFBZTc4QixXQUFXVCxRQUFRNDhCLGtCQUFrQno2QixPQUFPbkI7UUFDakUsTUFBTXU4QixlQUFlOThCLFdBQVdULFFBQVEyOEIsa0JBQWtCeDZCLE9BQU9uQjtRQUNqRTg1QixnQkFBZ0JweUIsT0FBTyxHQUFHLFNBQVNwSDtZQUNqQ2c4QjtZQUNBQztRQUNGO0lBQ0YsR0FBRztRQUFDNVo7UUFBUXNXO1FBQVV2VztLQUFLO0lBQzNCLE1BQU04WixnQkFBZ0JqL0IseURBQVdBLENBQUMsU0FBU2kvQjtRQUN6QyxNQUFNL2xCLFFBQVF3aUI7UUFDZCxDQUFFeGlCLENBQUFBLE1BQU0xWCxJQUFJLEtBQUssU0FBUSxJQUFLWixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsaUNBQWlDLEVBQUUyVixNQUFNMVgsSUFBSSxDQUFDLENBQUMsSUFBSStCLENBQVdBLEdBQUcsS0FBSztRQUM5SixNQUFNdzRCLFVBQVU3aUIsTUFBTTZpQixPQUFPLENBQUNFLFNBQVMsQ0FBQy9pQixNQUFNblMsS0FBSztRQUNuRDQwQixTQUFTO1lBQ1BuNkIsTUFBTTtZQUNOdTZCO1lBQ0F1QyxVQUFVO1FBQ1o7SUFDRixHQUFHO1FBQUM1QztRQUFVQztLQUFTO0lBQ3ZCLE1BQU11QixtQkFBbUJsOUIseURBQVdBLENBQUMsU0FBU2s5QixpQkFBaUJuQixPQUFPLEVBQUVoMUIsS0FBSztRQUMzRSxDQUFFMjBCLENBQUFBLFdBQVdsNkIsSUFBSSxLQUFLLE1BQUssSUFBS1osS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnREFBZ0RBLENBQVdBLEdBQUcsS0FBSztRQUM1SixNQUFNdTdCLG1CQUFtQmhaLFdBQVdtWixlQUFlZjtRQUNuRHZDLFNBQVM7WUFDUG42QixNQUFNO1lBQ051RjtZQUNBZzFCO1lBQ0ErQztRQUNGO1FBQ0F2QjtJQUNGLEdBQUc7UUFBQ0E7UUFBcUI3QjtRQUFVQztRQUFVc0Q7S0FBYztJQUMzRGhNLDBCQUEwQixTQUFTNkU7UUFDakN3RjtRQUNBLE9BQU8sU0FBUzNHO1lBQ2Q0RixnQkFBZ0JweUIsT0FBTztZQUN2QixNQUFNK08sUUFBUXdpQjtZQUNkLElBQUl4aUIsTUFBTTFYLElBQUksS0FBSyxXQUFXO2dCQUM1QnVrQixhQUFhN00sTUFBTTRsQixnQkFBZ0I7Z0JBQ25DbkQsU0FBU3NDO1lBQ1g7UUFDRjtJQUNGLEdBQUc7UUFBQ3ZDO1FBQVU0QjtRQUFrQjNCO0tBQVM7SUFDekMxSSwwQkFBMEIsU0FBU2lNO1FBQ2pDLE1BQU1yOEIsU0FBU1gsV0FBV1QsUUFBUTtZQUFDO2dCQUNqQ2tCLFdBQVc7Z0JBQ1hDLElBQUksS0FBTztnQkFDWEgsU0FBUztvQkFDUG1pQixTQUFTO29CQUNURCxTQUFTO2dCQUNYO1lBQ0Y7U0FBRTtRQUNGLE9BQU85aEI7SUFDVCxHQUFHLEVBQUU7QUFDUDtBQUVBLFNBQVNzOEIsdUJBQXVCQyxXQUFXO0lBQ3pDL0YsT0FBTztRQUNMLE1BQU1nRyxjQUFjekYsWUFBWXdGO1FBQ2hDN0YsbUJBQW1CO1lBQ2pCLENBQUU4RixDQUFBQSxZQUFZbDFCLE9BQU8sQ0FBQ21DLE1BQU0sS0FBSzh5QixZQUFZOXlCLE1BQU0sSUFBSTFMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNkRBQTZEQSxDQUFnQixHQUFHLEtBQUs7UUFDdk07SUFDRjtBQUNGO0FBRUEsTUFBTSs3QixzQkFBc0I7SUFBQztJQUFTO0lBQVU7SUFBWTtJQUFVO0lBQVU7SUFBWTtJQUFTO0NBQVE7QUFDN0csU0FBU0MsdUJBQXVCQyxNQUFNLEVBQUVyMUIsT0FBTztJQUM3QyxJQUFJQSxXQUFXLE1BQU07UUFDbkIsT0FBTztJQUNUO0lBQ0EsTUFBTXMxQixzQkFBc0JILG9CQUFvQkksUUFBUSxDQUFDdjFCLFFBQVF3MUIsT0FBTyxDQUFDeEcsV0FBVztJQUNwRixJQUFJc0cscUJBQXFCO1FBQ3ZCLE9BQU87SUFDVDtJQUNBLE1BQU0zTixZQUFZM25CLFFBQVE0cUIsWUFBWSxDQUFDO0lBQ3ZDLElBQUlqRCxjQUFjLFVBQVVBLGNBQWMsSUFBSTtRQUM1QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJM25CLFlBQVlxMUIsUUFBUTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxPQUFPRCx1QkFBdUJDLFFBQVFyMUIsUUFBUXkxQixhQUFhO0FBQzdEO0FBQ0EsU0FBU0MsNEJBQTRCNTBCLFNBQVMsRUFBRWxILEtBQUs7SUFDbkQsTUFBTXdELFNBQVN4RCxNQUFNd0QsTUFBTTtJQUMzQixJQUFJLENBQUNtdEIsY0FBY250QixTQUFTO1FBQzFCLE9BQU87SUFDVDtJQUNBLE9BQU9nNEIsdUJBQXVCdDBCLFdBQVcxRDtBQUMzQztBQUVBLElBQUl1NEIsNkJBQTZCMzlCLENBQUFBLEtBQU1sQyxzREFBT0EsQ0FBQ2tDLEdBQUc0OUIscUJBQXFCLElBQUk5dEIsTUFBTTtBQUVqRixTQUFTK3RCLFVBQVU3OUIsRUFBRTtJQUNuQixPQUFPQSxjQUFjb3lCLGdCQUFnQnB5QixJQUFJODlCLE9BQU87QUFDbEQ7QUFFQSxNQUFNQyx1QkFBdUIsQ0FBQztJQUM1QixNQUFNek8sT0FBTztJQUNiLElBQUksT0FBTzVNLGFBQWEsYUFBYTtRQUNuQyxPQUFPNE07SUFDVDtJQUNBLE1BQU03YixhQUFhO1FBQUM2YjtRQUFNO1FBQXFCO0tBQXdCO0lBQ3ZFLE1BQU16d0IsUUFBUTRVLFdBQVduRixJQUFJLENBQUNpWixDQUFBQSxPQUFRQSxRQUFRdVcsUUFBUTU4QixTQUFTO0lBQy9ELE9BQU9yQyxTQUFTeXdCO0FBQ2xCO0FBQ0EsU0FBUzBPLGdCQUFnQmgrQixFQUFFLEVBQUVpd0IsUUFBUTtJQUNuQyxJQUFJandCLE1BQU0sTUFBTTtRQUNkLE9BQU87SUFDVDtJQUNBLElBQUlBLEVBQUUsQ0FBQys5QixxQkFBcUIsQ0FBQzlOLFdBQVc7UUFDdEMsT0FBT2p3QjtJQUNUO0lBQ0EsT0FBT2crQixnQkFBZ0JoK0IsR0FBR3k5QixhQUFhLEVBQUV4TjtBQUMzQztBQUNBLFNBQVNqZixRQUFRaFIsRUFBRSxFQUFFaXdCLFFBQVE7SUFDM0IsSUFBSWp3QixHQUFHZ1IsT0FBTyxFQUFFO1FBQ2QsT0FBT2hSLEdBQUdnUixPQUFPLENBQUNpZjtJQUNwQjtJQUNBLE9BQU8rTixnQkFBZ0JoK0IsSUFBSWl3QjtBQUM3QjtBQUVBLFNBQVNHLFlBQVliLFNBQVM7SUFDNUIsT0FBTyxDQUFDLENBQUMsRUFBRUYsV0FBV0UsU0FBUyxDQUFDLEVBQUUsRUFBRUEsVUFBVSxFQUFFLENBQUM7QUFDbkQ7QUFDQSxTQUFTME8sK0JBQStCMU8sU0FBUyxFQUFFM3RCLEtBQUs7SUFDdEQsTUFBTXdELFNBQVN4RCxNQUFNd0QsTUFBTTtJQUMzQixJQUFJLENBQUN5NEIsVUFBVXo0QixTQUFTO1FBdCtLMUIsS0F1K0t5QyxHQUFHNUYsUUFBUSxvQ0FBb0MsQ0FBTTtRQUMxRixPQUFPO0lBQ1Q7SUFDQSxNQUFNeXdCLFdBQVdHLFlBQVliO0lBQzdCLE1BQU1vRCxTQUFTM2hCLFFBQVE1TCxRQUFRNnFCO0lBQy9CLElBQUksQ0FBQzBDLFFBQVE7UUFDWCxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNKLGNBQWNJLFNBQVM7UUEvK0s5QixLQWcvS3lDLEdBQUduekIsUUFBUSx1Q0FBdUMsQ0FBTTtRQUM3RixPQUFPO0lBQ1Q7SUFDQSxPQUFPbXpCO0FBQ1Q7QUFDQSxTQUFTdUwsa0NBQWtDM08sU0FBUyxFQUFFM3RCLEtBQUs7SUFDekQsTUFBTSt3QixTQUFTc0wsK0JBQStCMU8sV0FBVzN0QjtJQUN6RCxJQUFJLENBQUMrd0IsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUNBLE9BQU9BLE9BQU9DLFlBQVksQ0FBQ3ZELFdBQVczckIsV0FBVztBQUNuRDtBQUVBLFNBQVN5NkIsY0FBYzVPLFNBQVMsRUFBRTdyQixXQUFXO0lBQzNDLE1BQU11c0IsV0FBVyxDQUFDLENBQUMsRUFBRW5uQixVQUFVeW1CLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsRUFBRSxDQUFDO0lBQzFELE1BQU1tRCxXQUFXVixpQkFBaUJ0UCxVQUFVdU47SUFDNUMsTUFBTVEsY0FBY2lDLFNBQVNwa0IsSUFBSSxDQUFDdE8sQ0FBQUE7UUFDaEMsT0FBT0EsR0FBRzR5QixZQUFZLENBQUM5cEIsVUFBVXZGLEVBQUUsTUFBTUc7SUFDM0M7SUFDQSxJQUFJLENBQUMrc0IsYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUM4QixjQUFjOUIsY0FBYztRQXRnTG5DLEtBdWdMeUMsR0FBR2p4QixRQUFRLDRDQUE0QyxDQUFNO1FBQ2xHLE9BQU87SUFDVDtJQUNBLE9BQU9peEI7QUFDVDtBQUVBLFNBQVN4dUIsZUFBZUwsS0FBSztJQUMzQkEsTUFBTUssY0FBYztBQUN0QjtBQUNBLFNBQVM4Z0IsU0FBUyxFQUNoQndULFFBQVEsRUFDUnhmLEtBQUssRUFDTHFuQixZQUFZLEVBQ1pDLFVBQVUsRUFDWDtJQUNDLElBQUksQ0FBQ0QsZ0JBQWdCO1FBQ25CLElBQUlDLFlBQVk7WUF2aExwQixLQXdoTDJDLEdBQUc3K0IsUUFBUSxDQUFDOzs7Ozs7OztNQVFqRCxDQUFDLElBQUksQ0FBTTtRQUNiO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSSsyQixhQUFheGYsT0FBTztRQUN0QixJQUFJc25CLFlBQVk7WUFyaUxwQixLQXNpTDJDLEdBQUc3K0IsUUFBUSxDQUFDOzs7O3VCQUloQyxFQUFFKzJCLFNBQVM7a0RBQ2dCLEVBQUV4ZixNQUFNOzs7OztNQUtwRCxDQUFDLElBQUksQ0FBTTtRQUNiO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3VuQixTQUFTLEVBQ2hCQyxPQUFPLEVBQ1BuYixLQUFLLEVBQ0x5RSxRQUFRLEVBQ1Jua0IsV0FBVyxFQUNaO0lBQ0MsSUFBSTY2QixRQUFRM0csU0FBUyxJQUFJO1FBQ3ZCLE9BQU87SUFDVDtJQUNBLE1BQU0zVCxRQUFRNEQsU0FBUy9lLFNBQVMsQ0FBQ3FyQixRQUFRLENBQUN6d0I7SUFDMUMsSUFBSSxDQUFDdWdCLE9BQU87UUFoa0xkLEtBaWtMeUMsR0FBR3prQixRQUFRLENBQUMsa0NBQWtDLEVBQUVrRSxZQUFZLENBQUMsSUFBSSxDQUFNO1FBQzVHLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ3VnQixNQUFNM2pCLE9BQU8sQ0FBQzBTLFNBQVMsRUFBRTtRQUM1QixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUM0VyxhQUFheEcsTUFBTWpFLFFBQVEsSUFBSXpiLGNBQWM7UUFDaEQsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUzg2QixTQUFTLEVBQ2hCRCxPQUFPLEVBQ1BoUCxTQUFTLEVBQ1RuTSxLQUFLLEVBQ0x5RSxRQUFRLEVBQ1Jua0IsV0FBVyxFQUNYKzZCLGVBQWUsRUFDZjNELFdBQVcsRUFDWjtJQUNDLE1BQU00RCxjQUFjSixTQUFTO1FBQzNCQztRQUNBbmI7UUFDQXlFO1FBQ0Fua0I7SUFDRjtJQUNBLElBQUksQ0FBQ2c3QixhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUNBLE1BQU16YSxRQUFRNEQsU0FBUy9lLFNBQVMsQ0FBQ2tmLE9BQU8sQ0FBQ3RrQjtJQUN6QyxNQUFNMUQsS0FBS20rQixjQUFjNU8sV0FBV3RMLE1BQU01YixVQUFVLENBQUM5RSxFQUFFO0lBQ3ZELElBQUksQ0FBQ3ZELElBQUk7UUFobUxYLEtBaW1MeUMsR0FBR1IsUUFBUSxDQUFDLDBDQUEwQyxFQUFFa0UsWUFBWSxDQUFDLElBQUksQ0FBTTtRQUNwSCxPQUFPO0lBQ1Q7SUFDQSxJQUFJbzNCLGVBQWUsQ0FBQzdXLE1BQU0zakIsT0FBTyxDQUFDcStCLDBCQUEwQixJQUFJakIsNEJBQTRCMTlCLElBQUk4NkIsY0FBYztRQUM1RyxPQUFPO0lBQ1Q7SUFDQSxNQUFNbkQsT0FBTzRHLFFBQVExRyxLQUFLLENBQUM0RyxtQkFBbUI5K0I7SUFDOUMsSUFBSW9YLFFBQVE7SUFDWixTQUFTNm5CO1FBQ1AsT0FBTzNhLE1BQU0zakIsT0FBTyxDQUFDMDVCLHVCQUF1QjtJQUM5QztJQUNBLFNBQVNvRTtRQUNQLE9BQU9HLFFBQVF4YixRQUFRLENBQUM0VTtJQUMxQjtJQUNBLFNBQVNrSCxZQUFZdEksUUFBUSxFQUFFdUksU0FBUztRQUN0QyxJQUFJL2IsU0FBUztZQUNYd1Q7WUFDQXhmO1lBQ0FxbkI7WUFDQUMsWUFBWTtRQUNkLElBQUk7WUFDRmpiLE1BQU1oRSxRQUFRLENBQUMwZjtRQUNqQjtJQUNGO0lBQ0EsTUFBTUMsMEJBQTBCRixZQUFZcC9CLElBQUksQ0FBQyxNQUFNO0lBQ3ZELFNBQVN3ZixLQUFLeGQsSUFBSTtRQUNoQixTQUFTOGE7WUFDUGdpQixRQUFRdkcsT0FBTztZQUNmamhCLFFBQVE7UUFDVjtRQUNBLElBQUlBLFVBQVUsWUFBWTtZQUN4QndGO1lBaG9MTixLQWlvTDJDLEdBQUduYixVQUFVLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTJWLE1BQU0sQ0FBQyxJQUFJM1YsQ0FBV0E7UUFDekc7UUFDQWdpQixNQUFNaEUsUUFBUSxDQUFDOUIsT0FBTzdiLEtBQUt1OUIsY0FBYztRQUN6Q2pvQixRQUFRO1FBQ1IsU0FBU3dELE9BQU90VyxNQUFNLEVBQUUzRCxVQUFVO1lBQ2hDeTVCLHNCQUFzQjtRQUN4QixDQUFDO1lBQ0N0NEIsS0FBSzB6QixPQUFPO1lBQ1osSUFBSTcwQixRQUFReTVCLG9CQUFvQixFQUFFO2dCQUNoQyxNQUFNcjVCLFNBQVNYLFdBQVdULFFBQVE7b0JBQUM7d0JBQ2pDa0IsV0FBVzt3QkFDWEMsSUFBSXdCO3dCQUNKM0IsU0FBUzs0QkFDUGdtQixNQUFNOzRCQUNOOUQsU0FBUzs0QkFDVEMsU0FBUzt3QkFDWDtvQkFDRjtpQkFBRTtnQkFDRmtCLFdBQVdqakI7WUFDYjtZQUNBNmI7WUFDQTZHLE1BQU1oRSxRQUFRLENBQUNiLEtBQUs7Z0JBQ2xCdGE7WUFDRjtRQUNGO1FBQ0EsT0FBTztZQUNMOGUsVUFBVSxJQUFNQSxTQUFTO29CQUN2QndULFVBQVU7b0JBQ1Z4ZjtvQkFDQXFuQjtvQkFDQUMsWUFBWTtnQkFDZDtZQUNBckUseUJBQXlCNEU7WUFDekJyZ0IsTUFBTWplLENBQUFBLFVBQVdpYSxPQUFPLFFBQVFqYTtZQUNoQzJpQixRQUFRM2lCLENBQUFBLFVBQVdpYSxPQUFPLFVBQVVqYTtZQUNwQyxHQUFHbUIsS0FBS200QixPQUFPO1FBQ2pCO0lBQ0Y7SUFDQSxTQUFTRSxVQUFVNW1CLGVBQWU7UUFDaEMsTUFBTStyQixTQUFTM2dDLG9EQUFPQSxDQUFDaVUsQ0FBQUE7WUFDckJ3c0Isd0JBQXdCLElBQU1saEIsS0FBSztvQkFDakN0TDtnQkFDRjtRQUNGO1FBQ0EsTUFBTTJuQixNQUFNamIsS0FBSztZQUNmK2YsZ0JBQWdCO2dCQUNkejdCLElBQUlHO2dCQUNKd1A7Z0JBQ0E0RyxjQUFjO1lBQ2hCO1lBQ0FxYixTQUFTLElBQU04SixPQUFPaGMsTUFBTTtZQUM1QjJXLFNBQVM7Z0JBQ1AvYixNQUFNb2hCO1lBQ1I7UUFDRjtRQUNBLE9BQU87WUFDTCxHQUFHL0UsR0FBRztZQUNOcmMsTUFBTW9oQjtRQUNSO0lBQ0Y7SUFDQSxTQUFTckQ7UUFDUCxNQUFNaEMsVUFBVTtZQUNkNWIsUUFBUSxJQUFNK2dCLHdCQUF3Qi9nQjtZQUN0Q0UsV0FBVyxJQUFNNmdCLHdCQUF3QjdnQjtZQUN6Q0QsVUFBVSxJQUFNOGdCLHdCQUF3QjlnQjtZQUN4Q0UsVUFBVSxJQUFNNGdCLHdCQUF3QjVnQjtRQUMxQztRQUNBLE9BQU9jLEtBQUs7WUFDVitmLGdCQUFnQjtnQkFDZHo3QixJQUFJRztnQkFDSndQLGlCQUFpQnlxQiwyQkFBMkIzOUI7Z0JBQzVDOFosY0FBYztZQUNoQjtZQUNBcWIsU0FBU3gxQjtZQUNUaTZCO1FBQ0Y7SUFDRjtJQUNBLFNBQVNzRjtRQUNQLE1BQU1DLGdCQUFnQnBjLFNBQVM7WUFDN0J3VCxVQUFVO1lBQ1Z4ZjtZQUNBcW5CO1lBQ0FDLFlBQVk7UUFDZDtRQUNBLElBQUljLGVBQWU7WUFDakJaLFFBQVF2RyxPQUFPO1FBQ2pCO0lBQ0Y7SUFDQSxNQUFNMEQsVUFBVTtRQUNkM1ksVUFBVSxJQUFNQSxTQUFTO2dCQUN2QndULFVBQVU7Z0JBQ1Z4ZjtnQkFDQXFuQjtnQkFDQUMsWUFBWTtZQUNkO1FBQ0FyRSx5QkFBeUI0RTtRQUN6QjlFO1FBQ0E4QjtRQUNBOVYsT0FBT29aO0lBQ1Q7SUFDQSxPQUFPeEQ7QUFDVDtBQUNBLE1BQU0wRCxpQkFBaUI7SUFBQ25GO0lBQWdCdUI7SUFBbUJpQjtDQUFlO0FBQzFFLFNBQVM0QyxpQkFBaUIsRUFDeEI5UCxTQUFTLEVBQ1RuTSxLQUFLLEVBQ0x5RSxRQUFRLEVBQ1J5WCxhQUFhLEVBQ2JDLG9CQUFvQixFQUNyQjtJQUNDLE1BQU1DLGFBQWE7V0FBS0QsdUJBQXVCSCxpQkFBaUIsRUFBRTtXQUFPRSxpQkFBaUIsRUFBRTtLQUFFO0lBQzlGLE1BQU1mLFVBQVV0aEMsK0NBQVFBLENBQUMsSUFBTXk2QixTQUFTLENBQUMsRUFBRTtJQUMzQyxNQUFNK0gsaUJBQWlCNWhDLHlEQUFXQSxDQUFDLFNBQVM0aEMsZUFBZXIzQixRQUFRLEVBQUVKLE9BQU87UUFDMUUsSUFBSWxHLFdBQVdzRyxhQUFhLENBQUN0RyxXQUFXa0csVUFBVTtZQUNoRHUyQixRQUFRdEcsVUFBVTtRQUNwQjtJQUNGLEdBQUc7UUFBQ3NHO0tBQVE7SUFDWnpOLDBCQUEwQixTQUFTNE87UUFDakMsSUFBSXQzQixXQUFXZ2IsTUFBTWpFLFFBQVE7UUFDN0IsTUFBTXNLLGNBQWNyRyxNQUFNdUcsU0FBUyxDQUFDO1lBQ2xDLE1BQU0zaEIsVUFBVW9iLE1BQU1qRSxRQUFRO1lBQzlCc2dCLGVBQWVyM0IsVUFBVUo7WUFDekJJLFdBQVdKO1FBQ2I7UUFDQSxPQUFPeWhCO0lBQ1QsR0FBRztRQUFDOFU7UUFBU25iO1FBQU9xYztLQUFlO0lBQ25DM08sMEJBQTBCO1FBQ3hCLE9BQU95TixRQUFRdEcsVUFBVTtJQUMzQixHQUFHO1FBQUNzRyxRQUFRdEcsVUFBVTtLQUFDO0lBQ3ZCLE1BQU1pRCxhQUFhcjlCLHlEQUFXQSxDQUFDNkYsQ0FBQUE7UUFDN0IsT0FBTzQ2QixTQUFTO1lBQ2RDO1lBQ0ExVztZQUNBekU7WUFDQTFmO1FBQ0Y7SUFDRixHQUFHO1FBQUM2NkI7UUFBUzFXO1FBQVV6RTtLQUFNO0lBQzdCLE1BQU15WCxhQUFhaDlCLHlEQUFXQSxDQUFDLENBQUM2RixhQUFhaThCLFdBQVdyL0IsVUFBWWsrQixTQUFTO1lBQzNFRDtZQUNBMVc7WUFDQTBIO1lBQ0FuTTtZQUNBMWY7WUFDQSs2QixpQkFBaUJrQixhQUFhO1lBQzlCN0UsYUFBYXg2QixXQUFXQSxRQUFRdzZCLFdBQVcsR0FBR3g2QixRQUFRdzZCLFdBQVcsR0FBRztRQUN0RSxJQUFJO1FBQUN2TDtRQUFXZ1A7UUFBUzFXO1FBQVV6RTtLQUFNO0lBQ3pDLE1BQU13WCx5QkFBeUIvOEIseURBQVdBLENBQUMrRCxDQUFBQSxRQUFTczhCLGtDQUFrQzNPLFdBQVczdEIsUUFBUTtRQUFDMnRCO0tBQVU7SUFDcEgsTUFBTTBMLDBCQUEwQnA5Qix5REFBV0EsQ0FBQzBGLENBQUFBO1FBQzFDLE1BQU0wZ0IsUUFBUTRELFNBQVMvZSxTQUFTLENBQUNxckIsUUFBUSxDQUFDNXdCO1FBQzFDLE9BQU8wZ0IsUUFBUUEsTUFBTTNqQixPQUFPLEdBQUc7SUFDakMsR0FBRztRQUFDdW5CLFNBQVMvZSxTQUFTO0tBQUM7SUFDdkIsTUFBTTgyQixpQkFBaUIvaEMseURBQVdBLENBQUMsU0FBUytoQztRQUMxQyxJQUFJLENBQUNyQixRQUFRM0csU0FBUyxJQUFJO1lBQ3hCO1FBQ0Y7UUFDQTJHLFFBQVF0RyxVQUFVO1FBQ2xCLElBQUk3VSxNQUFNakUsUUFBUSxHQUFHcEksS0FBSyxLQUFLLFFBQVE7WUFDckNxTSxNQUFNaEUsUUFBUSxDQUFDaEI7UUFDakI7SUFDRixHQUFHO1FBQUNtZ0I7UUFBU25iO0tBQU07SUFDbkIsTUFBTXljLGdCQUFnQmhpQyx5REFBV0EsQ0FBQyxJQUFNMGdDLFFBQVEzRyxTQUFTLElBQUk7UUFBQzJHO0tBQVE7SUFDdEUsTUFBTXJFLE1BQU10OEIscURBQU9BLENBQUMsSUFBTztZQUN6QnM5QjtZQUNBTDtZQUNBRDtZQUNBSztZQUNBMkU7WUFDQUM7UUFDRixJQUFJO1FBQUMzRTtRQUFZTDtRQUFZRDtRQUF3Qks7UUFBeUIyRTtRQUFnQkM7S0FBYztJQUM1RzdDLHVCQUF1QndDO0lBQ3ZCLElBQUssSUFBSTd0QixJQUFJLEdBQUdBLElBQUk2dEIsV0FBV3IxQixNQUFNLEVBQUV3SCxJQUFLO1FBQzFDNnRCLFVBQVUsQ0FBQzd0QixFQUFFLENBQUN1b0I7SUFDaEI7QUFDRjtBQUVBLE1BQU00RixtQkFBbUJ0OUIsQ0FBQUEsUUFBVTtRQUNqQzZpQixpQkFBaUIwYSxDQUFBQTtZQUNmLE1BQU1DLHlCQUF5QjtnQkFDN0IsSUFBSXg5QixNQUFNNmlCLGVBQWUsRUFBRTtvQkFDekI3aUIsTUFBTTZpQixlQUFlLENBQUMwYTtnQkFDeEI7WUFDRjtZQUNBM2lDLG9EQUFTQSxDQUFDNGlDO1FBQ1o7UUFDQXphLG1CQUFtQi9pQixNQUFNK2lCLGlCQUFpQjtRQUMxQzFpQixhQUFhTCxNQUFNSyxXQUFXO1FBQzlCa0IsV0FBV3ZCLE1BQU11QixTQUFTO1FBQzFCSixjQUFjbkIsTUFBTW1CLFlBQVk7SUFDbEM7QUFDQSxNQUFNczhCLDRCQUE0Qno5QixDQUFBQSxRQUFVO1FBQzFDLEdBQUcybkIsMEJBQTBCO1FBQzdCLEdBQUczbkIsTUFBTXVvQixtQkFBbUI7UUFDNUJQLG1CQUFtQjtZQUNqQixHQUFHTCwyQkFBMkJLLGlCQUFpQjtZQUMvQyxHQUFHaG9CLE1BQU11b0IsbUJBQW1CO1FBQzlCO0lBQ0Y7QUFDQSxTQUFTbVYsU0FBU0MsT0FBTztJQUN2QixDQUFDQSxRQUFRbjRCLE9BQU8sR0FBR3ZKLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sd0NBQXdDQSxDQUFXQSxHQUFHLEtBQUs7SUFDdkksT0FBTysrQixRQUFRbjRCLE9BQU87QUFDeEI7QUFDQSxTQUFTbzRCLElBQUk1OUIsS0FBSztJQUNoQixNQUFNLEVBQ0orc0IsU0FBUyxFQUNUcnRCLFlBQVksRUFDWm0rQixPQUFPLEVBQ1BqUCxLQUFLLEVBQ0wxdUIsMkJBQTJCLEVBQzVCLEdBQUdGO0lBQ0osTUFBTTg5QixlQUFldGpDLDZDQUFNQSxDQUFDO0lBQzVCdTZCO0lBQ0EsTUFBTWdKLGVBQWU5SSxZQUFZajFCO0lBQ2pDLE1BQU0waUIsZ0JBQWdCcm5CLHlEQUFXQSxDQUFDO1FBQ2hDLE9BQU9paUMsaUJBQWlCUyxhQUFhdjRCLE9BQU87SUFDOUMsR0FBRztRQUFDdTRCO0tBQWE7SUFDakIsTUFBTXpWLHlCQUF5Qmp0Qix5REFBV0EsQ0FBQztRQUN6QyxPQUFPb2lDLDBCQUEwQk0sYUFBYXY0QixPQUFPO0lBQ3ZELEdBQUc7UUFBQ3U0QjtLQUFhO0lBQ2pCLE1BQU1oZCxXQUFXMFIsYUFBYTFGO0lBQzlCLE1BQU1pUixnQ0FBZ0MvSyxxQkFBcUI7UUFDekRsRztRQUNBbUcsTUFBTWh6QjtJQUNSO0lBQ0EsTUFBTWdsQixlQUFlNEosZ0JBQWdCL0IsV0FBVzZCO0lBQ2hELE1BQU1xUCxlQUFlNWlDLHlEQUFXQSxDQUFDNmUsQ0FBQUE7UUFDL0J3akIsU0FBU0ksY0FBY2xoQixRQUFRLENBQUMxQztJQUNsQyxHQUFHLEVBQUU7SUFDTCxNQUFNZ2tCLG1CQUFtQjlpQyxxREFBT0EsQ0FBQyxJQUFNSCx5REFBa0JBLENBQUM7WUFDeEQrZjtZQUNBRTtZQUNBQztZQUNBQztZQUNBSDtRQUNGLEdBQUdnakIsZUFBZTtRQUFDQTtLQUFhO0lBQ2hDLE1BQU01WSxXQUFXME07SUFDakIsTUFBTS9NLG1CQUFtQjVwQixxREFBT0EsQ0FBQztRQUMvQixPQUFPd3JCLHVCQUF1QnZCLFVBQVU2WTtJQUMxQyxHQUFHO1FBQUM3WTtRQUFVNlk7S0FBaUI7SUFDL0IsTUFBTXhaLGVBQWV0cEIscURBQU9BLENBQUMsSUFBTW94QixtQkFBbUI7WUFDcERuRjtZQUNBcGlCLGlCQUFpQitmLGlCQUFpQi9mLGVBQWU7WUFDakRxakI7WUFDQSxHQUFHcnRCLHlEQUFrQkEsQ0FBQztnQkFDcEJvZ0I7WUFDRixHQUFHNGlCLGFBQWE7UUFDbEIsSUFBSTtRQUFDalosaUJBQWlCL2YsZUFBZTtRQUFFZzVCO1FBQWMzVjtLQUF1QjtJQUM1RSxNQUFNckQsZUFBZW9MLGdCQUFnQnREO0lBQ3JDLE1BQU1uTSxRQUFReGxCLHFEQUFPQSxDQUFDLElBQU1QLFlBQVk7WUFDdENrbUI7WUFDQTJEO1lBQ0FNO1lBQ0FDO1lBQ0F2QztZQUNBd0M7UUFDRixJQUFJO1FBQUNuRTtRQUFVMkQ7UUFBY007UUFBa0JDO1FBQWN2QztRQUFld0M7S0FBYTtJQUN6RixJQUFJanBCLElBQXlCLEVBQWM7UUFDekMsSUFBSTZoQyxhQUFhdDRCLE9BQU8sSUFBSXM0QixhQUFhdDRCLE9BQU8sS0FBS29iLE9BQU87WUFqNExoRSxLQWs0TDJDLEdBQUc1akIsUUFBUSw2QkFBNkIsQ0FBTTtRQUNyRjtJQUNGO0lBQ0E4Z0MsYUFBYXQ0QixPQUFPLEdBQUdvYjtJQUN2QixNQUFNdWQsZ0JBQWdCOWlDLHlEQUFXQSxDQUFDO1FBQ2hDLE1BQU1tSyxVQUFVazRCLFNBQVNJO1FBQ3pCLE1BQU1qcUIsUUFBUXJPLFFBQVFtWCxRQUFRO1FBQzlCLElBQUk5SSxNQUFNVSxLQUFLLEtBQUssUUFBUTtZQUMxQi9PLFFBQVFvWCxRQUFRLENBQUNoQjtRQUNuQjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU10YyxhQUFhakUseURBQVdBLENBQUM7UUFDN0IsTUFBTXdZLFFBQVE2cEIsU0FBU0ksY0FBY25oQixRQUFRO1FBQzdDLElBQUk5SSxNQUFNVSxLQUFLLEtBQUssa0JBQWtCO1lBQ3BDLE9BQU87UUFDVDtRQUNBLElBQUlWLE1BQU1VLEtBQUssS0FBSyxRQUFRO1lBQzFCLE9BQU87UUFDVDtRQUNBLE9BQU9WLE1BQU12VSxVQUFVO0lBQ3pCLEdBQUcsRUFBRTtJQUNMLE1BQU04K0IsZUFBZWhqQyxxREFBT0EsQ0FBQyxJQUFPO1lBQ2xDa0U7WUFDQUMsVUFBVTQrQjtRQUNaLElBQUk7UUFBQzcrQjtRQUFZNitCO0tBQWM7SUFDL0J6K0IsYUFBYTArQjtJQUNiLE1BQU1DLGFBQWFoakMseURBQVdBLENBQUMwRixDQUFBQSxLQUFNcW1CLGFBQWFzVyxTQUFTSSxjQUFjbmhCLFFBQVEsSUFBSTViLEtBQUssRUFBRTtJQUM1RixNQUFNdTlCLHVCQUF1QmpqQyx5REFBV0EsQ0FBQyxJQUFNaVosa0JBQWtCb3BCLFNBQVNJLGNBQWNuaEIsUUFBUSxLQUFLLEVBQUU7SUFDdkcsTUFBTTRoQixhQUFhbmpDLHFEQUFPQSxDQUFDLElBQU87WUFDaENzaEIsU0FBU3NJO1lBQ1RiLE9BQU9jO1lBQ1A4SDtZQUNBeVIsU0FBU0g7WUFDVC9wQixtQkFBbUJncUI7WUFDbkJOO1lBQ0EzWTtRQUNGLElBQUk7UUFBQzBIO1FBQVcvSDtRQUFrQmdaO1FBQStCL1k7UUFBY29aO1FBQVlDO1FBQXNCalo7S0FBUztJQUMxSHdYLGlCQUFpQjtRQUNmOVA7UUFDQW5NO1FBQ0F5RTtRQUNBeVgsZUFBZWUsV0FBVztRQUMxQmQsc0JBQXNCLzhCLE1BQU0rOEIsb0JBQW9CLEtBQUs7SUFDdkQ7SUFDQXhpQyxnREFBU0EsQ0FBQztRQUNSLE9BQU80akM7SUFDVCxHQUFHO1FBQUNBO0tBQWM7SUFDbEIscUJBQU85akMsMERBQW1CLENBQUNnNUIsV0FBV240QixRQUFRLEVBQUU7UUFDOUNtQixPQUFPa2lDO0lBQ1QsaUJBQUdsa0MsMERBQW1CLENBQUNhLGlEQUFRQSxFQUFFO1FBQy9CZ3lCLFNBQVMrRTtRQUNUclIsT0FBT0E7SUFDVCxHQUFHNWdCLE1BQU1DLFFBQVE7QUFDbkI7QUFFQSxTQUFTdytCO0lBQ1AsT0FBT3BrQyxrREFBVztBQUNwQjtBQUVBLFNBQVNxa0MsZ0JBQWdCMStCLEtBQUs7SUFDNUIsTUFBTStzQixZQUFZMFI7SUFDbEIsTUFBTXYrQiw4QkFBOEJGLE1BQU1FLDJCQUEyQixJQUFJd0IsT0FBT3hCLDJCQUEyQjtJQUMzRyxxQkFBTzdGLDBEQUFtQixDQUFDeUUsZUFBZSxNQUFNWSxDQUFBQSw2QkFBZ0JyRiwwREFBbUIsQ0FBQ3VqQyxLQUFLO1lBQ3ZGaFAsT0FBTzV1QixNQUFNNHVCLEtBQUs7WUFDbEI3QixXQUFXQTtZQUNYcnRCLGNBQWNBO1lBQ2RRLDZCQUE2QkE7WUFDN0I2OEIsc0JBQXNCLzhCLE1BQU0rOEIsb0JBQW9CO1lBQ2hEYyxTQUFTNzlCLE1BQU02OUIsT0FBTztZQUN0QmhiLGlCQUFpQjdpQixNQUFNNmlCLGVBQWU7WUFDdENFLG1CQUFtQi9pQixNQUFNK2lCLGlCQUFpQjtZQUMxQzFpQixhQUFhTCxNQUFNSyxXQUFXO1lBQzlCYyxjQUFjbkIsTUFBTW1CLFlBQVk7WUFDaENJLFdBQVd2QixNQUFNdUIsU0FBUztZQUMxQmduQixxQkFBcUJ2b0IsTUFBTXVvQixtQkFBbUI7UUFDaEQsR0FBR3ZvQixNQUFNQyxRQUFRO0FBQ25CO0FBRUEsTUFBTTArQixnQkFBZ0I7SUFDcEJ4aEIsVUFBVTtJQUNWNlEsZUFBZTtBQUNqQjtBQUNBLE1BQU00USx3QkFBd0IsQ0FBQ0MsMkJBQTJCemhCO0lBQ3hELElBQUlBLFVBQVU7UUFDWixPQUFPVyxZQUFZaEMsSUFBSSxDQUFDcUIsU0FBU2MsUUFBUTtJQUMzQztJQUNBLElBQUkyZ0IsMkJBQTJCO1FBQzdCLE9BQU85Z0IsWUFBWUUsSUFBSTtJQUN6QjtJQUNBLE9BQU9GLFlBQVlDLEtBQUs7QUFDMUI7QUFDQSxNQUFNOGdCLHFCQUFxQixDQUFDdmdCLGFBQWF3Z0I7SUFDdkMsSUFBSSxDQUFDeGdCLGFBQWE7UUFDaEIsT0FBT0Y7SUFDVDtJQUNBLE9BQU8wZ0Isa0JBQWtCLzlCLFFBQVF3YyxPQUFPLENBQUN6QixJQUFJLEdBQUcvYSxRQUFRd2MsT0FBTyxDQUFDQyxTQUFTO0FBQzNFO0FBQ0EsTUFBTXVoQiwyQkFBMkI3aEIsQ0FBQUE7SUFDL0IsSUFBSUEsU0FBU3BTLGtCQUFrQixJQUFJLE1BQU07UUFDdkMsT0FBT29TLFNBQVNwUyxrQkFBa0I7SUFDcEM7SUFDQSxPQUFPb1MsU0FBU2pMLElBQUksS0FBSztBQUMzQjtBQUNBLFNBQVMrc0IsaUJBQWlCOWhCLFFBQVE7SUFDaEMsTUFBTTVLLFlBQVk0SyxTQUFTNUssU0FBUztJQUNwQyxNQUFNN0UsTUFBTTZFLFVBQVV4QyxNQUFNO0lBQzVCLE1BQU0sRUFDSnZVLE1BQU0sRUFDTmtSLFdBQVcsRUFDWDBRLFFBQVEsRUFDVCxHQUFHRDtJQUNKLE1BQU1vQixjQUFjalMsUUFBUUk7SUFDNUIsTUFBTTFCLGdCQUFnQmcwQix5QkFBeUI3aEI7SUFDL0MsTUFBTTRoQixrQkFBa0J6eUIsUUFBUThRO0lBQ2hDLE1BQU04aEIsWUFBWUgsa0JBQWtCemdCLFdBQVd2QyxJQUFJLENBQUN2Z0IsUUFBUStpQixlQUFlRCxXQUFXRixNQUFNLENBQUM1aUI7SUFDN0YsTUFBTTBoQixRQUFRO1FBQ1ovYyxVQUFVO1FBQ1ZnRCxLQUFLdUssSUFBSTdJLFNBQVMsQ0FBQzFCLEdBQUc7UUFDdEJJLE1BQU1tSyxJQUFJN0ksU0FBUyxDQUFDdEIsSUFBSTtRQUN4QjQ3QixXQUFXO1FBQ1gzN0IsT0FBT2tLLElBQUlILFNBQVMsQ0FBQy9KLEtBQUs7UUFDMUJDLFFBQVFpSyxJQUFJSCxTQUFTLENBQUM5SixNQUFNO1FBQzVCeXFCLFlBQVkwUSxzQkFBc0I1ekIsZUFBZW9TO1FBQ2pEOGhCO1FBQ0ExaEIsU0FBU3NoQixtQkFBbUJ2Z0IsYUFBYXdnQjtRQUN6Q0ssUUFBUUwsa0JBQWtCSixjQUFjM1EsYUFBYSxHQUFHMlEsY0FBY3hoQixRQUFRO1FBQzlFa2lCLGVBQWU7SUFDakI7SUFDQSxPQUFPbmlCO0FBQ1Q7QUFDQSxTQUFTb2lCLGtCQUFrQkMsU0FBUztJQUNsQyxPQUFPO1FBQ0xMLFdBQVc1Z0IsV0FBV0YsTUFBTSxDQUFDbWhCLFVBQVUvakMsTUFBTTtRQUM3QzB5QixZQUFZcVIsVUFBVUMseUJBQXlCLEdBQUduaEIsWUFBWTtJQUNoRTtBQUNGO0FBQ0EsU0FBU29oQixXQUFXQyxNQUFNO0lBQ3hCLE9BQU9BLE9BQU83aUMsSUFBSSxLQUFLLGFBQWFvaUMsaUJBQWlCUyxVQUFVSixrQkFBa0JJO0FBQ25GO0FBRUEsU0FBU0MsZUFBZTk1QixVQUFVLEVBQUVySSxFQUFFLEVBQUVncEIsZUFBZTdrQixNQUFNO0lBQzNELE1BQU1pK0IsaUJBQWlCOWlDLE9BQU8raUMsZ0JBQWdCLENBQUNyaUM7SUFDL0MsTUFBTStQLFlBQVkvUCxHQUFHNDlCLHFCQUFxQjtJQUMxQyxNQUFNcnJCLFNBQVNyVSwyREFBWUEsQ0FBQzZSLFdBQVdxeUI7SUFDdkMsTUFBTWo3QixPQUFPbEoseURBQVVBLENBQUNzVSxRQUFReVc7SUFDaEMsTUFBTXBPLGNBQWM7UUFDbEJySTtRQUNBaXJCLFNBQVN4OUIsR0FBR3c5QixPQUFPLENBQUN4RyxXQUFXO1FBQy9CcEIsU0FBU3dNLGVBQWV4TSxPQUFPO0lBQ2pDO0lBQ0EsTUFBTTVsQixhQUFhO1FBQ2pCNUwsR0FBR21PLE9BQU9sTCxTQUFTLENBQUNyQixLQUFLO1FBQ3pCM0IsR0FBR2tPLE9BQU9sTCxTQUFTLENBQUNwQixNQUFNO0lBQzVCO0lBQ0EsTUFBTThPLFlBQVk7UUFDaEIxTTtRQUNBdVM7UUFDQTVLO1FBQ0F1QztRQUNBcEw7SUFDRjtJQUNBLE9BQU80TjtBQUNUO0FBRUEsU0FBU3V0QixzQkFBc0I3Z0MsSUFBSTtJQUNqQyxNQUFNeXlCLFdBQVdvQixZQUFZO0lBQzdCLE1BQU0sRUFDSmp0QixVQUFVLEVBQ1Z3ZixRQUFRLEVBQ1IwYSxlQUFlLEVBQ2Y1RCwwQkFBMEIsRUFDMUIzRSx1QkFBdUIsRUFDdkJobkIsU0FBUyxFQUNWLEdBQUd2UjtJQUNKLE1BQU1uQixVQUFVMUMscURBQU9BLENBQUMsSUFBTztZQUM3QitnQztZQUNBM0U7WUFDQWhuQjtRQUNGLElBQUk7UUFBQzJyQjtRQUE0QjNyQjtRQUFXZ25CO0tBQXdCO0lBQ3BFLE1BQU0vUixlQUFlcHFCLHlEQUFXQSxDQUFDbXJCLENBQUFBO1FBQy9CLE1BQU1ocEIsS0FBS3VpQztRQUNYLENBQUN2aUMsS0FBS3ZCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sNkNBQTZDQSxDQUFXQSxHQUFHLEtBQUs7UUFDL0gsT0FBTytnQyxlQUFlOTVCLFlBQVlySSxJQUFJZ3BCO0lBQ3hDLEdBQUc7UUFBQzNnQjtRQUFZazZCO0tBQWdCO0lBQ2hDLE1BQU10ZSxRQUFRcm1CLHFEQUFPQSxDQUFDLElBQU87WUFDM0JzMkI7WUFDQTdyQjtZQUNBL0g7WUFDQTJuQjtRQUNGLElBQUk7UUFBQzVmO1FBQVk0ZjtRQUFjM25CO1FBQVM0ekI7S0FBUztJQUNqRCxNQUFNc08sZUFBZXhsQyw2Q0FBTUEsQ0FBQ2luQjtJQUM1QixNQUFNd2Usb0JBQW9CemxDLDZDQUFNQSxDQUFDO0lBQ2pDOHpCLDBCQUEwQjtRQUN4QmpKLFNBQVMvZSxTQUFTLENBQUNvcUIsUUFBUSxDQUFDc1AsYUFBYXg2QixPQUFPO1FBQ2hELE9BQU8sSUFBTTZmLFNBQVMvZSxTQUFTLENBQUNxcUIsVUFBVSxDQUFDcVAsYUFBYXg2QixPQUFPO0lBQ2pFLEdBQUc7UUFBQzZmLFNBQVMvZSxTQUFTO0tBQUM7SUFDdkJnb0IsMEJBQTBCO1FBQ3hCLElBQUkyUixrQkFBa0J6NkIsT0FBTyxFQUFFO1lBQzdCeTZCLGtCQUFrQno2QixPQUFPLEdBQUc7WUFDNUI7UUFDRjtRQUNBLE1BQU1xQyxPQUFPbTRCLGFBQWF4NkIsT0FBTztRQUNqQ3c2QixhQUFheDZCLE9BQU8sR0FBR2ljO1FBQ3ZCNEQsU0FBUy9lLFNBQVMsQ0FBQ2xGLE1BQU0sQ0FBQ3FnQixPQUFPNVo7SUFDbkMsR0FBRztRQUFDNFo7UUFBTzRELFNBQVMvZSxTQUFTO0tBQUM7QUFDaEM7QUFFQSxJQUFJNDVCLGlDQUFtQjdsQywwREFBbUIsQ0FBQztBQUUzQyxTQUFTOGxDLHFCQUFxQjNpQyxFQUFFO0lBQzlCLENBQUVBLENBQUFBLE1BQU11eUIsY0FBY3Z5QixHQUFFLElBQUt2QixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUM7Ozs7O0VBS3ZGLENBQUMsSUFBSUEsQ0FBV0EsR0FBRyxLQUFLO0FBQzFCO0FBRUEsU0FBU3doQyxnQkFBZ0JwZ0MsS0FBSyxFQUFFK3NCLFNBQVMsRUFBRXNULE1BQU07SUFDL0N6TCxtQkFBbUI7UUFDakIsU0FBU2hJLE9BQU83ckIsRUFBRTtZQUNoQixPQUFPLENBQUMsY0FBYyxFQUFFQSxHQUFHLEdBQUcsQ0FBQztRQUNqQztRQUNBLE1BQU1BLEtBQUtmLE1BQU1rQixXQUFXO1FBQzVCLENBQUNILEtBQUs5RSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHNDQUFzQ0EsQ0FBZ0IsR0FBRyxLQUFLO1FBQzdILENBQUUsUUFBT21DLE9BQU8sUUFBTyxJQUFLOUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDO3VCQUNuRSxFQUFFLE9BQU9tQyxHQUFHLFVBQVUsRUFBRUEsR0FBRyxDQUFDLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUM1RSxDQUFDb2dCLE9BQU9zaEIsU0FBUyxDQUFDdGdDLE1BQU1JLEtBQUssSUFBSW5FLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sQ0FBQyxFQUFFZ3VCLE9BQU83ckIsSUFBSSwrQkFBK0IsQ0FBQyxJQUFJbkMsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3BLLElBQUlvQixNQUFNMC9CLE1BQU0sQ0FBQzdpQyxJQUFJLEtBQUssWUFBWTtZQUNwQztRQUNGO1FBQ0FzakMscUJBQXFCRTtRQUNyQixJQUFJcmdDLE1BQU13USxTQUFTLEVBQUU7WUFDbkIsQ0FBQ3lmLGVBQWVsRCxXQUFXaHNCLE1BQU05RSxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLENBQUMsRUFBRWd1QixPQUFPN3JCLElBQUksMkJBQTJCLENBQUMsSUFBSW5DLENBQWdCLEdBQUcsS0FBSztRQUNsSztJQUNGO0FBQ0Y7QUFDQSxTQUFTMmhDLHVCQUF1QkMsT0FBTztJQUNyQzlMLE9BQU87UUFDTCxNQUFNK0wsYUFBYWptQyw2Q0FBTUEsQ0FBQ2dtQztRQUMxQjVMLG1CQUFtQjtZQUNqQixDQUFFNEwsQ0FBQUEsWUFBWUMsV0FBV2o3QixPQUFPLElBQUl2SixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLGdFQUFnRUEsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZMLEdBQUc7WUFBQzRoQztTQUFRO0lBQ2Q7QUFDRjtBQUVBLFNBQVNFLG1CQUFtQkMsT0FBTztJQUNqQyxNQUFNbi9CLFNBQVM5RyxpREFBVUEsQ0FBQ2ltQztJQUMxQixDQUFDbi9CLFNBQVN2RixLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHFDQUFxQ0EsQ0FBV0EsR0FBRyxLQUFLO0lBQzNILE9BQU80QztBQUNUO0FBRUEsU0FBU28vQixnQkFBZ0J4aEMsS0FBSztJQUM1QkEsTUFBTUssY0FBYztBQUN0QjtBQUNBLE1BQU1vaEMsWUFBWTdnQyxDQUFBQTtJQUNoQixNQUFNc3ZCLE1BQU05MEIsNkNBQU1BLENBQUM7SUFDbkIsTUFBTXNtQyxTQUFTemxDLHlEQUFXQSxDQUFDLENBQUNtQyxLQUFLLElBQUk7UUFDbkM4eEIsSUFBSTlwQixPQUFPLEdBQUdoSTtJQUNoQixHQUFHLEVBQUU7SUFDTCxNQUFNNmlDLFNBQVNobEMseURBQVdBLENBQUMsSUFBTWkwQixJQUFJOXBCLE9BQU8sRUFBRSxFQUFFO0lBQ2hELE1BQU0sRUFDSnVuQixTQUFTLEVBQ1RpUiw2QkFBNkIsRUFDN0IzWSxRQUFRLEVBQ1QsR0FBR3FiLG1CQUFtQnJOO0lBQ3ZCLE1BQU0sRUFDSngyQixJQUFJLEVBQ0o4RCxXQUFXLEVBQ1osR0FBRysvQixtQkFBbUJSO0lBQ3ZCLE1BQU1yNkIsYUFBYXpLLHFEQUFPQSxDQUFDLElBQU87WUFDaEMyRixJQUFJZixNQUFNa0IsV0FBVztZQUNyQmQsT0FBT0osTUFBTUksS0FBSztZQUNsQnZEO1lBQ0E4RDtRQUNGLElBQUk7UUFBQ1gsTUFBTWtCLFdBQVc7UUFBRWxCLE1BQU1JLEtBQUs7UUFBRXZEO1FBQU04RDtLQUFZO0lBQ3ZELE1BQU0sRUFDSlYsUUFBUSxFQUNSaUIsV0FBVyxFQUNYc1AsU0FBUyxFQUNUZ25CLHVCQUF1QixFQUN2QjJFLDBCQUEwQixFQUMxQnFFLE9BQU8sRUFDUGQsTUFBTSxFQUNOMWpCLHVCQUF1QitrQiwyQkFBMkIsRUFDbkQsR0FBRy9nQztJQUNKb2dDLGdCQUFnQnBnQyxPQUFPK3NCLFdBQVdzVDtJQUNsQ0UsdUJBQXVCQztJQUN2QixJQUFJLENBQUNBLFNBQVM7UUFDWixNQUFNUSxlQUFlNWxDLHFEQUFPQSxDQUFDLElBQU87Z0JBQ2xDeUs7Z0JBQ0F3ZjtnQkFDQTBhLGlCQUFpQk07Z0JBQ2pCbEU7Z0JBQ0EzRTtnQkFDQWhuQjtZQUNGLElBQUk7WUFBQzNLO1lBQVl3ZjtZQUFVZ2I7WUFBUWxFO1lBQTRCM0U7WUFBeUJobkI7U0FBVTtRQUNsR3N2QixzQkFBc0JrQjtJQUN4QjtJQUNBLE1BQU1DLGtCQUFrQjdsQyxxREFBT0EsQ0FBQyxJQUFNb1YsWUFBWTtZQUNoRDB3QixVQUFVO1lBQ1ZDLE1BQU07WUFDTixvQkFBb0JuRDtZQUNwQixxQ0FBcUM5OEI7WUFDckMsbUNBQW1DNnJCO1lBQ25Dem1CLFdBQVc7WUFDWGpHLGFBQWF1Z0M7UUFDZixJQUFJLE1BQU07UUFBQzdUO1FBQVdpUjtRQUErQjk4QjtRQUFhc1A7S0FBVTtJQUM1RSxNQUFNNHdCLFlBQVkvbEMseURBQVdBLENBQUMrRCxDQUFBQTtRQUM1QixJQUFJc2dDLE9BQU83aUMsSUFBSSxLQUFLLFlBQVk7WUFDOUI7UUFDRjtRQUNBLElBQUksQ0FBQzZpQyxPQUFPdGlCLFFBQVEsRUFBRTtZQUNwQjtRQUNGO1FBQ0EsSUFBSWhlLE1BQU1paUMsWUFBWSxLQUFLLGFBQWE7WUFDdEM7UUFDRjtRQUNBem1DLG9EQUFTQSxDQUFDbW1DO0lBQ1osR0FBRztRQUFDQTtRQUE2QnJCO0tBQU87SUFDeEMsTUFBTWxkLFdBQVdwbkIscURBQU9BLENBQUM7UUFDdkIsTUFBTThoQixRQUFRdWlCLFdBQVdDO1FBQ3pCLE1BQU00QixrQkFBa0I1QixPQUFPN2lDLElBQUksS0FBSyxjQUFjNmlDLE9BQU90aUIsUUFBUSxHQUFHZ2tCLFlBQVkvaUI7UUFDcEYsTUFBTTdjLFNBQVM7WUFDYisvQixVQUFVVDtZQUNWVSxnQkFBZ0I7Z0JBQ2QsaUNBQWlDelU7Z0JBQ2pDLHlCQUF5QjdyQjtnQkFDekJnYztnQkFDQW9rQjtZQUNGO1lBQ0FMO1FBQ0Y7UUFDQSxPQUFPei9CO0lBQ1QsR0FBRztRQUFDdXJCO1FBQVdrVTtRQUFpQi8vQjtRQUFhdytCO1FBQVEwQjtRQUFXTjtLQUFPO0lBQ3ZFLE1BQU1XLFNBQVNybUMscURBQU9BLENBQUMsSUFBTztZQUM1QjhGLGFBQWEyRSxXQUFXOUUsRUFBRTtZQUMxQmxFLE1BQU1nSixXQUFXaEosSUFBSTtZQUNyQjBELFFBQVE7Z0JBQ05ILE9BQU95RixXQUFXekYsS0FBSztnQkFDdkJPLGFBQWFrRixXQUFXbEYsV0FBVztZQUNyQztRQUNGLElBQUk7UUFBQ2tGLFdBQVdsRixXQUFXO1FBQUVrRixXQUFXOUUsRUFBRTtRQUFFOEUsV0FBV3pGLEtBQUs7UUFBRXlGLFdBQVdoSixJQUFJO0tBQUM7SUFDOUUscUJBQU94QywwREFBbUIsQ0FBQ0EsdURBQWMsRUFBRSxNQUFNNEYsU0FBU3VpQixVQUFVa2QsT0FBT2lDLFFBQVEsRUFBRUY7QUFDdkY7QUFFQSxJQUFJRyxnQkFBZ0IsQ0FBQ3A3QixHQUFHQyxJQUFNRCxNQUFNQztBQUVwQyxJQUFJbzdCLDhCQUE4QnJnQyxDQUFBQTtJQUNoQyxNQUFNLEVBQ0pSLE9BQU8sRUFDUFAsV0FBVyxFQUNaLEdBQUdlO0lBQ0osSUFBSWYsYUFBYTtRQUNmLE9BQU9BLFlBQVlFLFdBQVc7SUFDaEM7SUFDQSxJQUFJSyxTQUFTO1FBQ1gsT0FBT0EsUUFBUUwsV0FBVztJQUM1QjtJQUNBLE9BQU87QUFDVDtBQUVBLE1BQU1taEMsMkJBQTJCdGdDLENBQUFBO0lBQy9CLE9BQU9BLE9BQU9SLE9BQU8sR0FBR1EsT0FBT1IsT0FBTyxDQUFDRSxXQUFXLEdBQUc7QUFDdkQ7QUFDQSxNQUFNNmdDLDJCQUEyQnA3QixDQUFBQTtJQUMvQixPQUFPQSxPQUFPQyxFQUFFLElBQUlELE9BQU9DLEVBQUUsQ0FBQy9KLElBQUksS0FBSyxZQUFZOEosT0FBT0MsRUFBRSxDQUFDNUYsT0FBTyxDQUFDRSxXQUFXLEdBQUc7QUFDckY7QUFDQSxTQUFTOGdDO0lBQ1AsTUFBTUMsaUJBQWlCcG1DLHVEQUFVQSxDQUFDLENBQUMrRixHQUFHQyxJQUFPO1lBQzNDRDtZQUNBQztRQUNGO0lBQ0EsTUFBTXFnQyxzQkFBc0JybUMsdURBQVVBLENBQUMsQ0FBQ3FXLE1BQU1zdUIsU0FBUzJCLGVBQWUsSUFBSSxFQUFFejFCLGNBQWMsSUFBSSxFQUFFMFEsV0FBVyxJQUFJLEdBQU07WUFDbkg5ZCxZQUFZO1lBQ1praEM7WUFDQXpCLGlCQUFpQnp5QixRQUFROFE7WUFDekJnbEIsZUFBZWhsQjtZQUNmbEw7WUFDQWl3QjtZQUNBejFCO1lBQ0EyMUIsa0JBQWtCO1FBQ3BCO0lBQ0EsTUFBTUMsbUJBQW1Cem1DLHVEQUFVQSxDQUFDLENBQUNMLFFBQVEwVyxNQUFNSyxXQUFXaXVCLFNBQVMyQixlQUFlLElBQUksRUFBRXoxQixjQUFjLElBQUksRUFBRTNCLHFCQUFxQixJQUFJLEdBQU07WUFDN0kyMEIsUUFBUTtnQkFDTjdpQyxNQUFNO2dCQUNOdWdCLFVBQVU7Z0JBQ1Yra0I7Z0JBQ0F6MUI7Z0JBQ0F3RjtnQkFDQTFXO2dCQUNBK1c7Z0JBQ0F4SDtnQkFDQTQyQixVQUFVTyxvQkFBb0Jod0IsTUFBTXN1QixTQUFTMkIsY0FBY3oxQixhQUFhO1lBQzFFO1FBQ0Y7SUFDQSxNQUFNK2dCLFdBQVcsQ0FBQzVaLE9BQU8wdUI7UUFDdkIsSUFBSWpqQyxXQUFXdVUsUUFBUTtZQUNyQixJQUFJQSxNQUFNSyxRQUFRLENBQUM1TixTQUFTLENBQUN2RixFQUFFLEtBQUt3aEMsU0FBU3JoQyxXQUFXLEVBQUU7Z0JBQ3hELE9BQU87WUFDVDtZQUNBLE1BQU0xRixTQUFTcVksTUFBTXJPLE9BQU8sQ0FBQ3VLLE1BQU0sQ0FBQ3ZVLE1BQU07WUFDMUMsTUFBTStXLFlBQVlzQixNQUFNRSxVQUFVLENBQUNoTyxVQUFVLENBQUN3OEIsU0FBU3JoQyxXQUFXLENBQUM7WUFDbkUsTUFBTWloQyxlQUFlenVCLGtCQUFrQkcsTUFBTWxOLE1BQU07WUFDbkQsTUFBTStGLGNBQWNxMUIseUJBQXlCbHVCLE1BQU1sTixNQUFNO1lBQ3pELE1BQU1vRSxxQkFBcUI4SSxNQUFNOUksa0JBQWtCO1lBQ25ELE9BQU91M0IsaUJBQWlCTCxlQUFlem1DLE9BQU9vRyxDQUFDLEVBQUVwRyxPQUFPcUcsQ0FBQyxHQUFHZ1MsTUFBTXlELFlBQVksRUFBRS9FLFdBQVdnd0IsU0FBUy9CLE9BQU8sRUFBRTJCLGNBQWN6MUIsYUFBYTNCO1FBQzFJO1FBQ0EsSUFBSThJLE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7WUFDcEMsTUFBTXdGLFlBQVlsRyxNQUFNa0csU0FBUztZQUNqQyxJQUFJQSxVQUFVdlksTUFBTSxDQUFDTixXQUFXLEtBQUtxaEMsU0FBU3JoQyxXQUFXLEVBQUU7Z0JBQ3pELE9BQU87WUFDVDtZQUNBLE1BQU1zL0IsVUFBVStCLFNBQVMvQixPQUFPO1lBQ2hDLE1BQU1qdUIsWUFBWXNCLE1BQU1FLFVBQVUsQ0FBQ2hPLFVBQVUsQ0FBQ3c4QixTQUFTcmhDLFdBQVcsQ0FBQztZQUNuRSxNQUFNTSxTQUFTdVksVUFBVXZZLE1BQU07WUFDL0IsTUFBTTBRLE9BQU8xUSxPQUFPMFEsSUFBSTtZQUN4QixNQUFNaXdCLGVBQWVOLDRCQUE0QnJnQztZQUNqRCxNQUFNa0wsY0FBY28xQix5QkFBeUJ0Z0M7WUFDN0MsTUFBTTBjLFdBQVdySyxNQUFNNEcsWUFBWTtZQUNuQyxNQUFNMkMsV0FBVztnQkFDZmM7Z0JBQ0Fza0IsT0FBT2xsQixPQUFPdkIsSUFBSTtnQkFDbEJxQyxRQUFRdkssTUFBTTZHLG1CQUFtQjtnQkFDakM4QyxTQUFTOVEsY0FBYzFMLFFBQVF3YyxPQUFPLENBQUN6QixJQUFJLEdBQUc7Z0JBQzlDMkIsT0FBT2hSLGNBQWMxTCxRQUFRMGMsS0FBSyxDQUFDM0IsSUFBSSxHQUFHO1lBQzVDO1lBQ0EsT0FBTztnQkFDTDJqQixRQUFRO29CQUNON2lDLE1BQU07b0JBQ05yQixRQUFRcVksTUFBTTZHLG1CQUFtQjtvQkFDakNuSTtvQkFDQTZLO29CQUNBK2tCO29CQUNBejFCO29CQUNBd0Y7b0JBQ0FuSCxvQkFBb0I7b0JBQ3BCNDJCLFVBQVVPLG9CQUFvQmh3QixNQUFNc3VCLFNBQVMyQixjQUFjejFCLGFBQWEwUTtnQkFDMUU7WUFDRjtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBT3FRO0FBQ1Q7QUFDQSxTQUFTZ1YscUJBQXFCSixtQkFBbUIsSUFBSTtJQUNuRCxPQUFPO1FBQ0wvaUMsWUFBWTtRQUNaeS9CLGlCQUFpQjtRQUNqQnlCLFNBQVM7UUFDVDRCLGVBQWU7UUFDZmx3QixNQUFNO1FBQ05pd0IsY0FBYztRQUNkRTtRQUNBMzFCLGFBQWE7SUFDZjtBQUNGO0FBQ0EsTUFBTWcyQixTQUFTO0lBQ2JoRCxRQUFRO1FBQ043aUMsTUFBTTtRQUNOckIsUUFBUW1HO1FBQ1IwZ0Msa0JBQWtCO1FBQ2xCN0MsMkJBQTJCO1FBQzNCbUMsVUFBVWMscUJBQXFCO0lBQ2pDO0FBQ0Y7QUFDQSxTQUFTRTtJQUNQLE1BQU1WLGlCQUFpQnBtQyx1REFBVUEsQ0FBQyxDQUFDK0YsR0FBR0MsSUFBTztZQUMzQ0Q7WUFDQUM7UUFDRjtJQUNBLE1BQU1xZ0Msc0JBQXNCcm1DLHVEQUFVQSxDQUFDNG1DO0lBQ3ZDLE1BQU1ILG1CQUFtQnptQyx1REFBVUEsQ0FBQyxDQUFDTCxRQUFRNm1DLG1CQUFtQixJQUFJLEVBQUU3Qyw0QkFBK0I7WUFDbkdFLFFBQVE7Z0JBQ043aUMsTUFBTTtnQkFDTnJCO2dCQUNBNm1DO2dCQUNBN0M7Z0JBQ0FtQyxVQUFVTyxvQkFBb0JHO1lBQ2hDO1FBQ0Y7SUFDQSxNQUFNTyxjQUFjUCxDQUFBQTtRQUNsQixPQUFPQSxtQkFBbUJDLGlCQUFpQjNnQyxRQUFRMGdDLGtCQUFrQixRQUFRO0lBQy9FO0lBQ0EsTUFBTVEsV0FBVyxDQUFDQyxPQUFPQyxZQUFZcDhCLFFBQVEwRjtRQUMzQyxNQUFNMjJCLHFCQUFxQnI4QixPQUFPYyxTQUFTLENBQUNjLE9BQU8sQ0FBQ3U2QixNQUFNO1FBQzFELE1BQU1HLCtCQUErQjMyQixRQUFRRCxjQUFjdUwsYUFBYSxJQUFJdkwsY0FBY0UsUUFBUSxDQUFDdTJCLE1BQU07UUFDekcsTUFBTTloQyxVQUFVNkYsY0FBY0Y7UUFDOUIsTUFBTTA3QixtQkFBbUJyaEMsV0FBV0EsUUFBUUUsV0FBVyxLQUFLNGhDLFFBQVFDLGFBQWE7UUFDakYsSUFBSSxDQUFDQyxvQkFBb0I7WUFDdkIsSUFBSSxDQUFDQyw4QkFBOEI7Z0JBQ2pDLE9BQU9MLFlBQVlQO1lBQ3JCO1lBQ0EsSUFBSTE3QixPQUFPYyxTQUFTLENBQUNhLFNBQVMsQ0FBQ3c2QixNQUFNLEVBQUU7Z0JBQ3JDLE9BQU87WUFDVDtZQUNBLE1BQU0vYixTQUFTNWtCLE9BQU9rSyxjQUFjNUQsV0FBVyxDQUFDckcsS0FBSztZQUNyRCxNQUFNNUcsU0FBU3ltQyxlQUFlbGIsT0FBT25sQixDQUFDLEVBQUVtbEIsT0FBT2xsQixDQUFDO1lBQ2hELE9BQU95Z0MsaUJBQWlCOW1DLFFBQVE2bUMsa0JBQWtCO1FBQ3BEO1FBQ0EsSUFBSVksOEJBQThCO1lBQ2hDLE9BQU9MLFlBQVlQO1FBQ3JCO1FBQ0EsTUFBTTcwQixhQUFhN0csT0FBTzhCLFdBQVcsQ0FBQ3JHLEtBQUs7UUFDM0MsTUFBTTVHLFNBQVN5bUMsZUFBZXowQixXQUFXNUwsQ0FBQyxFQUFFNEwsV0FBVzNMLENBQUM7UUFDeEQsT0FBT3lnQyxpQkFBaUI5bUMsUUFBUTZtQyxrQkFBa0JXLG1CQUFtQmg0QixhQUFhO0lBQ3BGO0lBQ0EsTUFBTXlpQixXQUFXLENBQUM1WixPQUFPMHVCO1FBQ3ZCLElBQUlqakMsV0FBV3VVLFFBQVE7WUFDckIsSUFBSUEsTUFBTUssUUFBUSxDQUFDNU4sU0FBUyxDQUFDdkYsRUFBRSxLQUFLd2hDLFNBQVNyaEMsV0FBVyxFQUFFO2dCQUN4RCxPQUFPO1lBQ1Q7WUFDQSxPQUFPMmhDLFNBQVNOLFNBQVNyaEMsV0FBVyxFQUFFMlMsTUFBTUssUUFBUSxDQUFDNU4sU0FBUyxDQUFDdkYsRUFBRSxFQUFFOFMsTUFBTWxOLE1BQU0sRUFBRWtOLE1BQU14SCxhQUFhO1FBQ3RHO1FBQ0EsSUFBSXdILE1BQU1VLEtBQUssS0FBSyxrQkFBa0I7WUFDcEMsTUFBTXdGLFlBQVlsRyxNQUFNa0csU0FBUztZQUNqQyxJQUFJQSxVQUFVdlksTUFBTSxDQUFDTixXQUFXLEtBQUtxaEMsU0FBU3JoQyxXQUFXLEVBQUU7Z0JBQ3pELE9BQU87WUFDVDtZQUNBLE9BQU8yaEMsU0FBU04sU0FBU3JoQyxXQUFXLEVBQUU2WSxVQUFVdlksTUFBTSxDQUFDTixXQUFXLEVBQUU2WSxVQUFVcFQsTUFBTSxFQUFFb1QsVUFBVTFOLGFBQWE7UUFDL0c7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPb2hCO0FBQ1Q7QUFDQSxNQUFNeVYsd0JBQXdCO0lBQzVCLE1BQU1DLG1CQUFtQm5CO0lBQ3pCLE1BQU1vQixvQkFBb0JUO0lBQzFCLE1BQU1sVixXQUFXLENBQUM1WixPQUFPMHVCLFdBQWFZLGlCQUFpQnR2QixPQUFPMHVCLGFBQWFhLGtCQUFrQnZ2QixPQUFPMHVCLGFBQWFHO0lBQ2pILE9BQU9qVjtBQUNUO0FBQ0EsTUFBTTRWLHVCQUF1QjtJQUMzQnJuQix1QkFBdUJBO0FBQ3pCO0FBQ0EsTUFBTXNuQixxQkFBcUJub0Msb0RBQU9BLENBQUMrbkMsdUJBQXVCRyxzQkFBc0IsTUFBTTtJQUNwRm5XLFNBQVMrRTtJQUNUc1Isb0JBQW9CM0I7QUFDdEIsR0FBR2Y7QUFFSCxTQUFTMkMsaUJBQWlCeGpDLEtBQUs7SUFDN0IsTUFBTXlqQyxtQkFBbUIvQyxtQkFBbUJSO0lBQzVDLE1BQU13RCxrQkFBa0JELGlCQUFpQkMsZUFBZTtJQUN4RCxJQUFJQSxvQkFBb0IxakMsTUFBTWtCLFdBQVcsSUFBSSxDQUFDbEIsTUFBTXdnQyxPQUFPLEVBQUU7UUFDM0QsT0FBTztJQUNUO0lBQ0EscUJBQU9ubUMsMERBQW1CLENBQUNpcEMsb0JBQW9CdGpDO0FBQ2pEO0FBQ0EsU0FBUzJqQyxnQkFBZ0IzakMsS0FBSztJQUM1QixNQUFNd1EsWUFBWSxPQUFPeFEsTUFBTTRqQyxjQUFjLEtBQUssWUFBWSxDQUFDNWpDLE1BQU00akMsY0FBYyxHQUFHO0lBQ3RGLE1BQU16SCw2QkFBNkI3dkIsUUFBUXRNLE1BQU02akMsaUNBQWlDO0lBQ2xGLE1BQU1yTSwwQkFBMEJsckIsUUFBUXRNLE1BQU13M0IsdUJBQXVCO0lBQ3JFLHFCQUFPbjlCLDBEQUFtQixDQUFDbXBDLGtCQUFrQnpuQyw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdpRSxPQUFPO1FBQy9Ed2dDLFNBQVM7UUFDVGh3QixXQUFXQTtRQUNYMnJCLDRCQUE0QkE7UUFDNUIzRSx5QkFBeUJBO0lBQzNCO0FBQ0Y7QUFFQSxNQUFNc00sVUFBVWhYLENBQUFBLE9BQVF6d0IsQ0FBQUEsUUFBU3l3QixTQUFTendCO0FBQzFDLE1BQU0wbkMsV0FBV0QsUUFBUTtBQUN6QixNQUFNRSxTQUFTRixRQUFRO0FBQ3ZCLE1BQU12NEIsWUFBWXU0QixRQUFRO0FBQzFCLE1BQU1HLFdBQVcsQ0FBQzFSLFVBQVV0MEIsS0FBT0EsR0FBR3MwQixTQUFTMlIsU0FBUyxLQUFLam1DLEdBQUdzMEIsU0FBUzRSLFNBQVM7QUFDbEYsTUFBTUMsU0FBUyxDQUFDN1IsVUFBVXQwQixLQUFPQSxHQUFHczBCLFNBQVMyUixTQUFTLEtBQUtqbUMsR0FBR3MwQixTQUFTNFIsU0FBUztBQUNoRixNQUFNRSxzQkFBc0I3bUMsQ0FBQUE7SUFDMUIsTUFBTTBmLFFBQVFwZ0IsT0FBTytpQyxnQkFBZ0IsQ0FBQ3JpQztJQUN0QyxNQUFNKzBCLFdBQVc7UUFDZjJSLFdBQVdobkIsTUFBTWduQixTQUFTO1FBQzFCQyxXQUFXam5CLE1BQU1pbkIsU0FBUztJQUM1QjtJQUNBLE9BQU9GLFNBQVMxUixVQUFVd1IsYUFBYUUsU0FBUzFSLFVBQVV5UjtBQUM1RDtBQUNBLE1BQU1NLG1CQUFtQjtJQUN2QixJQUFJcm9DLEtBQXlCLEVBQWMsRUFFMUM7SUFDRCxNQUFNb3lCLE9BQU84RDtJQUNiLE1BQU1vUyxPQUFPcmtCLFNBQVNnRyxlQUFlO0lBQ3JDLENBQUNxZSxPQUFPdG9DLEtBQXFDLEdBQUcyQyxjQUFjQSxDQUFXQSxHQUFHLEtBQUs7SUFDakYsSUFBSSxDQUFDeWxDLG9CQUFvQmhXLE9BQU87UUFDOUIsT0FBTztJQUNUO0lBQ0EsTUFBTW1XLFlBQVkxbkMsT0FBTytpQyxnQkFBZ0IsQ0FBQzBFO0lBQzFDLE1BQU1FLGVBQWU7UUFDbkJQLFdBQVdNLFVBQVVOLFNBQVM7UUFDOUJDLFdBQVdLLFVBQVVMLFNBQVM7SUFDaEM7SUFDQSxJQUFJQyxPQUFPSyxjQUFjbDVCLFlBQVk7UUFDbkMsT0FBTztJQUNUO0lBaDlNRixLQWk5TXVDLEdBQUd2TyxRQUFRLENBQUM7Ozs7Ozs7OztFQVNqRCxDQUFDLElBQUksQ0FBTTtJQUNYLE9BQU87QUFDVDtBQUNBLE1BQU0wbkMsdUJBQXVCbG5DLENBQUFBO0lBQzNCLElBQUlBLE1BQU0sTUFBTTtRQUNkLE9BQU87SUFDVDtJQUNBLElBQUlBLE9BQU8waUIsU0FBU21PLElBQUksRUFBRTtRQUN4QixPQUFPaVcscUJBQXFCOW1DLEtBQUs7SUFDbkM7SUFDQSxJQUFJQSxPQUFPMGlCLFNBQVNnRyxlQUFlLEVBQUU7UUFDbkMsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDbWUsb0JBQW9CN21DLEtBQUs7UUFDNUIsT0FBT2tuQyxxQkFBcUJsbkMsR0FBR3k5QixhQUFhO0lBQzlDO0lBQ0EsT0FBT3o5QjtBQUNUO0FBRUEsSUFBSW1uQyxpQ0FBaUN2L0IsQ0FBQUE7SUFDbkMsSUFBSSxDQUFDQSxZQUFZO1FBQ2Y7SUFDRjtJQUNBLE1BQU13L0Isc0JBQXNCRixxQkFBcUJ0L0IsV0FBVzYxQixhQUFhO0lBQ3pFLElBQUksQ0FBQzJKLHFCQUFxQjtRQUN4QjtJQUNGO0lBcC9NRixLQXEvTXVDLEdBQUc1bkMsUUFBUSxDQUFDOzs7Ozs7RUFNakQsQ0FBQyxJQUFJLENBQU07QUFDYjtBQUVBLElBQUk2bkMsWUFBWXJuQyxDQUFBQSxLQUFPO1FBQ3JCb0UsR0FBR3BFLEdBQUdzbkMsVUFBVTtRQUNoQmpqQyxHQUFHckUsR0FBR3VuQyxTQUFTO0lBQ2pCO0FBRUEsTUFBTUMsYUFBYXhuQyxDQUFBQTtJQUNqQixJQUFJLENBQUNBLElBQUk7UUFDUCxPQUFPO0lBQ1Q7SUFDQSxNQUFNMGYsUUFBUXBnQixPQUFPK2lDLGdCQUFnQixDQUFDcmlDO0lBQ3RDLElBQUkwZixNQUFNL2MsUUFBUSxLQUFLLFNBQVM7UUFDOUIsT0FBTztJQUNUO0lBQ0EsT0FBTzZrQyxXQUFXeG5DLEdBQUd5OUIsYUFBYTtBQUNwQztBQUNBLElBQUlnSyxTQUFTM2tDLENBQUFBO0lBQ1gsTUFBTTRrQyxvQkFBb0JSLHFCQUFxQnBrQztJQUMvQyxNQUFNZ2EsZ0JBQWdCMHFCLFdBQVcxa0M7SUFDakMsT0FBTztRQUNMNGtDO1FBQ0E1cUI7SUFDRjtBQUNGO0FBRUEsSUFBSTZxQix3QkFBd0IsQ0FBQyxFQUMzQnQvQixVQUFVLEVBQ1YySyxTQUFTLEVBQ1RsSixnQkFBZ0IsRUFDaEJnVCxhQUFhLEVBQ2I1USxTQUFTLEVBQ1RxRyxNQUFNLEVBQ05wTCxJQUFJLEVBQ0o2SixPQUFPLEVBQ1I7SUFDQyxNQUFNdkwsUUFBUSxDQUFDO1FBQ2IsSUFBSSxDQUFDdUwsU0FBUztZQUNaLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSjQyQixVQUFVLEVBQ1ZyMUIsUUFBUXMxQixXQUFXLEVBQ3BCLEdBQUc3MkI7UUFDSixNQUFNdUUsWUFBWTZTLGFBQWE7WUFDN0JDLGNBQWN1ZixXQUFXdmYsWUFBWTtZQUNyQ0MsYUFBYXNmLFdBQVd0ZixXQUFXO1lBQ25DcmlCLFFBQVE0aEMsWUFBWUMsVUFBVSxDQUFDN2hDLE1BQU07WUFDckNELE9BQU82aEMsWUFBWUMsVUFBVSxDQUFDOWhDLEtBQUs7UUFDckM7UUFDQSxPQUFPO1lBQ0xpQixlQUFlK0osUUFBUTdKLElBQUksQ0FBQ0UsU0FBUztZQUNyQ3dnQztZQUNBRDtZQUNBNWdDLG1CQUFtQmdLLFFBQVFoSyxpQkFBaUI7WUFDNUNULFFBQVE7Z0JBQ051QixTQUFTa0osUUFBUXpLLE1BQU07Z0JBQ3ZCeUIsU0FBU2dKLFFBQVF6SyxNQUFNO2dCQUN2QlgsS0FBSzJQO2dCQUNML08sTUFBTTtvQkFDSjNILE9BQU9zRjtvQkFDUHNDLGNBQWN0QztnQkFDaEI7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxNQUFNd0MsT0FBT3VGLGNBQWMsYUFBYUQsV0FBV087SUFDbkQsTUFBTTlHLFVBQVV3QixXQUFXO1FBQ3pCQztRQUNBUCxpQkFBaUI7UUFDakJEO1FBQ0FsQjtJQUNGO0lBQ0EsTUFBTXNQLFlBQVk7UUFDaEIxTTtRQUNBeUI7UUFDQWdUO1FBQ0FuVztRQUNBcU07UUFDQVQ7UUFDQXBMO1FBQ0ExQjtRQUNBQztJQUNGO0lBQ0EsT0FBT3FQO0FBQ1Q7QUFFQSxNQUFNZ3pCLFlBQVksQ0FBQ0MsV0FBV047SUFDNUIsTUFBTXBZLE9BQU9ueEIscURBQU1BLENBQUM2cEM7SUFDcEIsSUFBSSxDQUFDTixtQkFBbUI7UUFDdEIsT0FBT3BZO0lBQ1Q7SUFDQSxJQUFJMFksY0FBY04sbUJBQW1CO1FBQ25DLE9BQU9wWTtJQUNUO0lBQ0EsTUFBTTNwQixNQUFNMnBCLEtBQUt3WSxVQUFVLENBQUNuaUMsR0FBRyxHQUFHK2hDLGtCQUFrQkgsU0FBUztJQUM3RCxNQUFNeGhDLE9BQU91cEIsS0FBS3dZLFVBQVUsQ0FBQy9oQyxJQUFJLEdBQUcyaEMsa0JBQWtCSixVQUFVO0lBQ2hFLE1BQU14aEMsU0FBU0gsTUFBTStoQyxrQkFBa0JyZixZQUFZO0lBQ25ELE1BQU14aUIsUUFBUUUsT0FBTzJoQyxrQkFBa0JwZixXQUFXO0lBQ2xELE1BQU13ZixhQUFhO1FBQ2pCbmlDO1FBQ0FFO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFDQSxNQUFNZ0ssWUFBWWhTLHFEQUFNQSxDQUFDK3BDLFlBQVl4WSxLQUFLdUYsTUFBTTtJQUNoRCxNQUFNdGlCLFNBQVNuVSx3REFBU0EsQ0FBQztRQUN2QjJSO1FBQ0FJLFFBQVFtZixLQUFLbmYsTUFBTTtRQUNuQjBrQixRQUFRdkYsS0FBS3VGLE1BQU07UUFDbkJDLFNBQVN4RixLQUFLd0YsT0FBTztJQUN2QjtJQUNBLE9BQU92aUI7QUFDVDtBQUNBLElBQUkwVixlQUFlLENBQUMsRUFDbEI2SixHQUFHLEVBQ0h6cEIsVUFBVSxFQUNWNC9CLEdBQUcsRUFDSGpmLFlBQVksRUFDWjljLFNBQVMsRUFDVGc4QixjQUFjLEVBQ2RwK0IsZ0JBQWdCLEVBQ2hCOUMsaUJBQWlCLEVBQ2xCO0lBQ0MsTUFBTTBnQyxvQkFBb0JPLElBQUlQLGlCQUFpQjtJQUMvQyxNQUFNbjFCLFNBQVN3MUIsVUFBVWpXLEtBQUs0VjtJQUM5QixNQUFNdmdDLE9BQU9sSix5REFBVUEsQ0FBQ3NVLFFBQVF5VztJQUNoQyxNQUFNaFksVUFBVSxDQUFDO1FBQ2YsSUFBSSxDQUFDMDJCLG1CQUFtQjtZQUN0QixPQUFPO1FBQ1Q7UUFDQSxNQUFNRyxjQUFjMXBDLHFEQUFNQSxDQUFDdXBDO1FBQzNCLE1BQU1FLGFBQWE7WUFDakJ2ZixjQUFjcWYsa0JBQWtCcmYsWUFBWTtZQUM1Q0MsYUFBYW9mLGtCQUFrQnBmLFdBQVc7UUFDNUM7UUFDQSxPQUFPO1lBQ0wvVixRQUFRczFCO1lBQ1IxZ0MsTUFBTWxKLHlEQUFVQSxDQUFDNHBDLGFBQWE3ZTtZQUM5QnppQixRQUFROGdDLFVBQVVLO1lBQ2xCRTtZQUNBNWdDO1FBQ0Y7SUFDRjtJQUNBLE1BQU0rTixZQUFZNHlCLHNCQUFzQjtRQUN0Q3QvQjtRQUNBMkssV0FBVyxDQUFDazFCO1FBQ1pwK0I7UUFDQWdULGVBQWVtckIsSUFBSW5yQixhQUFhO1FBQ2hDNVE7UUFDQXFHO1FBQ0FwTDtRQUNBNko7SUFDRjtJQUNBLE9BQU8rRDtBQUNUO0FBRUEsTUFBTW96QixZQUFZO0lBQ2hCM2xCLFNBQVM7QUFDWDtBQUNBLE1BQU00bEIsVUFBVTtJQUNkNWxCLFNBQVM7QUFDWDtBQUNBLElBQUk2bEIscUJBQXFCL25DLENBQUFBLFVBQVdBLFFBQVFpZix3QkFBd0IsR0FBRzRvQixZQUFZQztBQUVuRixNQUFNRSwrQkFBK0Izb0IsQ0FBQUEsV0FBWUEsWUFBWUEsU0FBU3NvQixHQUFHLENBQUNQLGlCQUFpQixJQUFJO0FBQy9GLFNBQVNhLHNCQUFzQjltQyxJQUFJO0lBQ2pDLE1BQU0rbUMsbUJBQW1CeHJDLDZDQUFNQSxDQUFDO0lBQ2hDLE1BQU0rakMsYUFBYW1DLG1CQUFtQnJOO0lBQ3RDLE1BQU0zQixXQUFXb0IsWUFBWTtJQUM3QixNQUFNLEVBQ0p6TixRQUFRLEVBQ1IzSSxPQUFPLEVBQ1IsR0FBRzZoQjtJQUNKLE1BQU03RCxjQUFjekYsWUFBWWgyQjtJQUNoQyxNQUFNNEcsYUFBYXpLLHFEQUFPQSxDQUFDLElBQU87WUFDaEMyRixJQUFJOUIsS0FBSzBCLFdBQVc7WUFDcEI5RCxNQUFNb0MsS0FBS3BDLElBQUk7WUFDZnFWLE1BQU1qVCxLQUFLaVQsSUFBSTtRQUNqQixJQUFJO1FBQUNqVCxLQUFLMEIsV0FBVztRQUFFMUIsS0FBS2lULElBQUk7UUFBRWpULEtBQUtwQyxJQUFJO0tBQUM7SUFDNUMsTUFBTW9wQyx5QkFBeUJ6ckMsNkNBQU1BLENBQUNxTDtJQUN0QyxNQUFNcWdDLHVCQUF1QjlxQyxxREFBT0EsQ0FBQyxJQUFNUyx1REFBVUEsQ0FBQyxDQUFDK0YsR0FBR0M7WUFDeEQsQ0FBQ21rQyxpQkFBaUJ4Z0MsT0FBTyxHQUFHdkosS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywwQ0FBMENBLENBQVdBLEdBQUcsS0FBSztZQUNsSixNQUFNbUYsU0FBUztnQkFDYm5DO2dCQUNBQztZQUNGO1lBQ0E2YSxRQUFReEIscUJBQXFCLENBQUNyVixXQUFXOUUsRUFBRSxFQUFFZ0Q7UUFDL0MsSUFBSTtRQUFDOEIsV0FBVzlFLEVBQUU7UUFBRTJiO0tBQVE7SUFDNUIsTUFBTXlwQixtQkFBbUI5cUMseURBQVdBLENBQUM7UUFDbkMsTUFBTThoQixXQUFXNm9CLGlCQUFpQnhnQyxPQUFPO1FBQ3pDLElBQUksQ0FBQzJYLFlBQVksQ0FBQ0EsU0FBU3NvQixHQUFHLENBQUNQLGlCQUFpQixFQUFFO1lBQ2hELE9BQU92akM7UUFDVDtRQUNBLE9BQU9rakMsVUFBVTFuQixTQUFTc29CLEdBQUcsQ0FBQ1AsaUJBQWlCO0lBQ2pELEdBQUcsRUFBRTtJQUNMLE1BQU03a0IsZUFBZWhsQix5REFBV0EsQ0FBQztRQUMvQixNQUFNMEksU0FBU29pQztRQUNmRCxxQkFBcUJuaUMsT0FBT25DLENBQUMsRUFBRW1DLE9BQU9sQyxDQUFDO0lBQ3pDLEdBQUc7UUFBQ3NrQztRQUFrQkQ7S0FBcUI7SUFDM0MsTUFBTUUsdUJBQXVCaHJDLHFEQUFPQSxDQUFDLElBQU1VLG9EQUFPQSxDQUFDdWtCLGVBQWU7UUFBQ0E7S0FBYTtJQUNoRixNQUFNZ21CLGtCQUFrQmhyQyx5REFBV0EsQ0FBQztRQUNsQyxNQUFNOGhCLFdBQVc2b0IsaUJBQWlCeGdDLE9BQU87UUFDekMsTUFBTWdKLFVBQVVzM0IsNkJBQTZCM29CO1FBQzdDLENBQUVBLENBQUFBLFlBQVkzTyxPQUFNLElBQUt2UyxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLG1EQUFtREEsQ0FBV0EsR0FBRyxLQUFLO1FBQ3hKLE1BQU1kLFVBQVVxZixTQUFTTCxhQUFhO1FBQ3RDLElBQUloZixRQUFRaWYsd0JBQXdCLEVBQUU7WUFDcENzRDtZQUNBO1FBQ0Y7UUFDQStsQjtJQUNGLEdBQUc7UUFBQ0E7UUFBc0IvbEI7S0FBYTtJQUN2QyxNQUFNcUcsNkJBQTZCcnJCLHlEQUFXQSxDQUFDLENBQUNtckIsY0FBYzFvQjtRQUM1RCxDQUFDLENBQUNrb0MsaUJBQWlCeGdDLE9BQU8sR0FBR3ZKLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMERBQTBEQSxDQUFXQSxHQUFHLEtBQUs7UUFDbkssTUFBTWdILFdBQVc4MEIsWUFBWWwxQixPQUFPO1FBQ3BDLE1BQU04cEIsTUFBTTFwQixTQUFTMGdDLGVBQWU7UUFDcEMsQ0FBQ2hYLE1BQU1yekIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw0Q0FBNENBLENBQVdBLEdBQUcsS0FBSztRQUMvSCxNQUFNNm1DLE1BQU1SLE9BQU8zVjtRQUNuQixNQUFNblMsV0FBVztZQUNmbVM7WUFDQXpwQjtZQUNBNC9CO1lBQ0Ezb0IsZUFBZWhmO1FBQ2pCO1FBQ0Frb0MsaUJBQWlCeGdDLE9BQU8sR0FBRzJYO1FBQzNCLE1BQU01SyxZQUFZa1QsYUFBYTtZQUM3QjZKO1lBQ0F6cEI7WUFDQTQvQjtZQUNBamY7WUFDQTljLFdBQVc5RCxTQUFTOEQsU0FBUztZQUM3Qmc4QixnQkFBZ0I5L0IsU0FBUzgvQixjQUFjO1lBQ3ZDcCtCLGtCQUFrQjFCLFNBQVMwQixnQkFBZ0I7WUFDM0M5QyxtQkFBbUIsQ0FBQ29CLFNBQVMyZ0MsdUJBQXVCO1FBQ3REO1FBQ0EsTUFBTW5oQyxhQUFhcWdDLElBQUlQLGlCQUFpQjtRQUN4QyxJQUFJOS9CLFlBQVk7WUFDZEEsV0FBV3lwQixZQUFZLENBQUM3QixnQkFBZ0JELFNBQVMsRUFBRXdSLFdBQVd4UixTQUFTO1lBQ3ZFM25CLFdBQVdySCxnQkFBZ0IsQ0FBQyxVQUFVc29DLGlCQUFpQlIsbUJBQW1CMW9CLFNBQVNMLGFBQWE7WUFDaEcsSUFBSTdnQixJQUF5QixFQUFjO2dCQUN6QzBvQywrQkFBK0J2L0I7WUFDakM7UUFDRjtRQUNBLE9BQU9tTjtJQUNULEdBQUc7UUFBQ2dzQixXQUFXeFIsU0FBUztRQUFFbG5CO1FBQVl3Z0M7UUFBaUIzTDtLQUFZO0lBQ25FLE1BQU1oVix5QkFBeUJycUIseURBQVdBLENBQUM7UUFDekMsTUFBTThoQixXQUFXNm9CLGlCQUFpQnhnQyxPQUFPO1FBQ3pDLE1BQU1nSixVQUFVczNCLDZCQUE2QjNvQjtRQUM3QyxDQUFFQSxDQUFBQSxZQUFZM08sT0FBTSxJQUFLdlMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxxRkFBcUZBLENBQVdBLEdBQUcsS0FBSztRQUMxTCxPQUFPaW1DLFVBQVVyMkI7SUFDbkIsR0FBRyxFQUFFO0lBQ0wsTUFBTXdZLGNBQWMzckIseURBQVdBLENBQUM7UUFDOUIsTUFBTThoQixXQUFXNm9CLGlCQUFpQnhnQyxPQUFPO1FBQ3pDLENBQUMyWCxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sMENBQTBDQSxDQUFXQSxHQUFHLEtBQUs7UUFDbEksTUFBTTRQLFVBQVVzM0IsNkJBQTZCM29CO1FBQzdDNm9CLGlCQUFpQnhnQyxPQUFPLEdBQUc7UUFDM0IsSUFBSSxDQUFDZ0osU0FBUztZQUNaO1FBQ0Y7UUFDQTQzQixxQkFBcUIzbEIsTUFBTTtRQUMzQmpTLFFBQVFnNEIsZUFBZSxDQUFDeFosZ0JBQWdCRCxTQUFTO1FBQ2pEdmUsUUFBUXJRLG1CQUFtQixDQUFDLFVBQVVrb0MsaUJBQWlCUixtQkFBbUIxb0IsU0FBU0wsYUFBYTtJQUNsRyxHQUFHO1FBQUN1cEI7UUFBaUJEO0tBQXFCO0lBQzFDLE1BQU1yaUMsU0FBUzFJLHlEQUFXQSxDQUFDMHJCLENBQUFBO1FBQ3pCLE1BQU01SixXQUFXNm9CLGlCQUFpQnhnQyxPQUFPO1FBQ3pDLENBQUMyWCxXQUFXbGhCLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8seUNBQXlDQSxDQUFXQSxHQUFHLEtBQUs7UUFDakksTUFBTTRQLFVBQVVzM0IsNkJBQTZCM29CO1FBQzdDLENBQUMzTyxVQUFVdlMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywwREFBMERBLENBQVdBLEdBQUcsS0FBSztRQUNqSjRQLFFBQVF1MkIsU0FBUyxJQUFJaGUsT0FBT2xsQixDQUFDO1FBQzdCMk0sUUFBUXMyQixVQUFVLElBQUkvZCxPQUFPbmxCLENBQUM7SUFDaEMsR0FBRyxFQUFFO0lBQ0wsTUFBTTFDLFlBQVk5RCxxREFBT0EsQ0FBQztRQUN4QixPQUFPO1lBQ0xzckI7WUFDQWhCO1lBQ0FzQjtZQUNBampCO1FBQ0Y7SUFDRixHQUFHO1FBQUNpakI7UUFBYU47UUFBNEJoQjtRQUF3QjNoQjtLQUFPO0lBQzVFLE1BQU0wZCxRQUFRcm1CLHFEQUFPQSxDQUFDLElBQU87WUFDM0JzMkI7WUFDQTdyQjtZQUNBM0c7UUFDRixJQUFJO1FBQUNBO1FBQVcyRztRQUFZNnJCO0tBQVM7SUFDckNwRCwwQkFBMEI7UUFDeEIyWCx1QkFBdUJ6Z0MsT0FBTyxHQUFHaWMsTUFBTTViLFVBQVU7UUFDakR3ZixTQUFTbmdCLFNBQVMsQ0FBQ3dyQixRQUFRLENBQUNqUDtRQUM1QixPQUFPO1lBQ0wsSUFBSXVrQixpQkFBaUJ4Z0MsT0FBTyxFQUFFO2dCQTV4TnBDLEtBNnhONkMsR0FBR3hJLFFBQVEsZ0ZBQWdGLENBQU07Z0JBQ3RJZ3FCO1lBQ0Y7WUFDQTNCLFNBQVNuZ0IsU0FBUyxDQUFDeXJCLFVBQVUsQ0FBQ2xQO1FBQ2hDO0lBQ0YsR0FBRztRQUFDdmlCO1FBQVcyRztRQUFZbWhCO1FBQWF2RjtRQUFPL0U7UUFBUzJJLFNBQVNuZ0IsU0FBUztLQUFDO0lBQzNFb3BCLDBCQUEwQjtRQUN4QixJQUFJLENBQUMwWCxpQkFBaUJ4Z0MsT0FBTyxFQUFFO1lBQzdCO1FBQ0Y7UUFDQWtYLFFBQVF2Qix3QkFBd0IsQ0FBQzhxQix1QkFBdUJ6Z0MsT0FBTyxDQUFDekUsRUFBRSxFQUFFLENBQUM5QixLQUFLeW1DLGNBQWM7SUFDMUYsR0FBRztRQUFDem1DLEtBQUt5bUMsY0FBYztRQUFFaHBCO0tBQVE7SUFDakM0UiwwQkFBMEI7UUFDeEIsSUFBSSxDQUFDMFgsaUJBQWlCeGdDLE9BQU8sRUFBRTtZQUM3QjtRQUNGO1FBQ0FrWCxRQUFRdEIsK0JBQStCLENBQUM2cUIsdUJBQXVCemdDLE9BQU8sQ0FBQ3pFLEVBQUUsRUFBRTlCLEtBQUtxSSxnQkFBZ0I7SUFDbEcsR0FBRztRQUFDckksS0FBS3FJLGdCQUFnQjtRQUFFb1Y7S0FBUTtBQUNyQztBQUVBLFNBQVMrcEIsUUFBUTtBQUNqQixNQUFNQyxRQUFRO0lBQ1psakMsT0FBTztJQUNQQyxRQUFRO0lBQ1JrSyxRQUFROUo7QUFDVjtBQUNBLE1BQU04aUMsVUFBVSxDQUFDLEVBQ2ZDLHNCQUFzQixFQUN0Qnh1QixXQUFXLEVBQ1h5dUIsT0FBTyxFQUNSO0lBQ0MsSUFBSUQsd0JBQXdCO1FBQzFCLE9BQU9GO0lBQ1Q7SUFDQSxJQUFJRyxZQUFZLFNBQVM7UUFDdkIsT0FBT0g7SUFDVDtJQUNBLE9BQU87UUFDTGpqQyxRQUFRMlUsWUFBWXJJLE1BQU0sQ0FBQ3hDLFNBQVMsQ0FBQzlKLE1BQU07UUFDM0NELE9BQU80VSxZQUFZckksTUFBTSxDQUFDeEMsU0FBUyxDQUFDL0osS0FBSztRQUN6Q21LLFFBQVF5SyxZQUFZckksTUFBTSxDQUFDcEMsTUFBTTtJQUNuQztBQUNGO0FBQ0EsTUFBTW01QixXQUFXLENBQUMsRUFDaEJGLHNCQUFzQixFQUN0Qnh1QixXQUFXLEVBQ1h5dUIsT0FBTyxFQUNSO0lBQ0MsTUFBTWo5QixPQUFPKzhCLFFBQVE7UUFDbkJDO1FBQ0F4dUI7UUFDQXl1QjtJQUNGO0lBQ0EsT0FBTztRQUNMelQsU0FBU2hiLFlBQVlnYixPQUFPO1FBQzVCK0wsV0FBVztRQUNYMzdCLE9BQU9vRyxLQUFLcEcsS0FBSztRQUNqQkMsUUFBUW1HLEtBQUtuRyxNQUFNO1FBQ25Cc2pDLFdBQVduOUIsS0FBSytELE1BQU0sQ0FBQ3hLLEdBQUc7UUFDMUI2akMsYUFBYXA5QixLQUFLK0QsTUFBTSxDQUFDdEssS0FBSztRQUM5QjRqQyxjQUFjcjlCLEtBQUsrRCxNQUFNLENBQUNySyxNQUFNO1FBQ2hDNGpDLFlBQVl0OUIsS0FBSytELE1BQU0sQ0FBQ3BLLElBQUk7UUFDNUI0akMsWUFBWTtRQUNaQyxVQUFVO1FBQ1YvSCxlQUFlO1FBQ2ZuUixZQUFZMlksWUFBWSxTQUFTOW9CLFlBQVkzRixXQUFXLEdBQUc7SUFDN0Q7QUFDRjtBQUNBLE1BQU1pdkIsY0FBY3JuQyxDQUFBQTtJQUNsQixNQUFNc25DLHNCQUFzQjlzQyw2Q0FBTUEsQ0FBQztJQUNuQyxNQUFNK3NDLDJCQUEyQmxzQyx5REFBV0EsQ0FBQztRQUMzQyxJQUFJLENBQUNpc0Msb0JBQW9COWhDLE9BQU8sRUFBRTtZQUNoQztRQUNGO1FBQ0E0YixhQUFha21CLG9CQUFvQjloQyxPQUFPO1FBQ3hDOGhDLG9CQUFvQjloQyxPQUFPLEdBQUc7SUFDaEMsR0FBRyxFQUFFO0lBQ0wsTUFBTSxFQUNKcWhDLE9BQU8sRUFDUHZGLGVBQWUsRUFDZmtHLE9BQU8sRUFDUHphLFNBQVMsRUFDVixHQUFHL3NCO0lBQ0osTUFBTSxDQUFDNG1DLHdCQUF3QmEsMEJBQTBCLEdBQUdodEMsK0NBQVFBLENBQUN1RixNQUFNNm1DLE9BQU8sS0FBSztJQUN2RnRzQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ3FzQyx3QkFBd0I7WUFDM0IsT0FBT0g7UUFDVDtRQUNBLElBQUlJLFlBQVksUUFBUTtZQUN0QlU7WUFDQUUsMEJBQTBCO1lBQzFCLE9BQU9oQjtRQUNUO1FBQ0EsSUFBSWEsb0JBQW9COWhDLE9BQU8sRUFBRTtZQUMvQixPQUFPaWhDO1FBQ1Q7UUFDQWEsb0JBQW9COWhDLE9BQU8sR0FBRzJiLFdBQVc7WUFDdkNtbUIsb0JBQW9COWhDLE9BQU8sR0FBRztZQUM5QmlpQywwQkFBMEI7UUFDNUI7UUFDQSxPQUFPRjtJQUNULEdBQUc7UUFBQ1Y7UUFBU0Q7UUFBd0JXO0tBQXlCO0lBQzlELE1BQU1HLGtCQUFrQnJzQyx5REFBV0EsQ0FBQytELENBQUFBO1FBQ2xDLElBQUlBLE1BQU1paUMsWUFBWSxLQUFLLFVBQVU7WUFDbkM7UUFDRjtRQUNBQztRQUNBLElBQUl1RixZQUFZLFNBQVM7WUFDdkJXO1FBQ0Y7SUFDRixHQUFHO1FBQUNYO1FBQVNXO1FBQVNsRztLQUFnQjtJQUN0QyxNQUFNcGtCLFFBQVE0cEIsU0FBUztRQUNyQkY7UUFDQUMsU0FBUzdtQyxNQUFNNm1DLE9BQU87UUFDdEJ6dUIsYUFBYXBZLE1BQU1vWSxXQUFXO0lBQ2hDO0lBQ0EscUJBQU8vZCwwREFBbUIsQ0FBQzJGLE1BQU1vWSxXQUFXLENBQUM0aUIsT0FBTyxFQUFFO1FBQ3BEOWQ7UUFDQSxtQ0FBbUM2UDtRQUNuQ3VVLGlCQUFpQm9HO1FBQ2pCcFksS0FBS3R2QixNQUFNdWhDLFFBQVE7SUFDckI7QUFDRjtBQUNBLElBQUlvRyw4QkFBZ0J0dEMsaURBQVUsQ0FBQ2d0QztBQUUvQixTQUFTUSxVQUFVeHJDLEtBQUs7SUFDdEIsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBQ0EsU0FBU3lyQyxVQUFVN29DLElBQUksRUFBRThvQyxNQUFNO0lBQzdCQSxPQUFPMXBDLE9BQU8sQ0FBQzJwQyxDQUFBQSxRQUFTQSxNQUFNL29DO0FBQ2hDO0FBQ0EsTUFBTTVCLFNBQVM7SUFBQyxTQUFTa3RCLFNBQVMsRUFDaEN2cUIsS0FBSyxFQUNOO1FBQ0MsQ0FBQ0EsTUFBTVcsV0FBVyxHQUFHMUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyw2Q0FBNkNBLENBQVdBLEdBQUcsS0FBSztRQUM5SSxDQUFFLFFBQU9vQixNQUFNVyxXQUFXLEtBQUssUUFBTyxJQUFLMUUsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxDQUFDLHdEQUF3RCxFQUFFLE9BQU9vQixNQUFNVyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUkvQixDQUFXQSxHQUFHLEtBQUs7SUFDbk47SUFBRyxTQUFTcXBDLFFBQVEsRUFDbEJqb0MsS0FBSyxFQUNOO1FBQ0MsQ0FBQzZuQyxVQUFVN25DLE1BQU0wbEMsY0FBYyxJQUFJenBDLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sc0NBQXNDQSxDQUFXQSxHQUFHLEtBQUs7UUFDckosQ0FBQ2lwQyxVQUFVN25DLE1BQU1zSCxnQkFBZ0IsSUFBSXJMLEtBQXFDLEdBQUcyQyxVQUFVLE9BQU8sd0NBQXdDQSxDQUFXQSxHQUFHLEtBQUs7UUFDekosQ0FBQ2lwQyxVQUFVN25DLE1BQU11bUMsdUJBQXVCLElBQUl0cUMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywrQ0FBK0NBLENBQVdBLEdBQUcsS0FBSztJQUN6SztJQUFHLFNBQVMwd0IsSUFBSSxFQUNkZ1gsZUFBZSxFQUNoQjtRQUNDbkcscUJBQXFCbUc7SUFDdkI7Q0FBRTtBQUNGLE1BQU00QixXQUFXO0lBQUMsU0FBUzl2QixZQUFZLEVBQ3JDcFksS0FBSyxFQUNMbW9DLGlCQUFpQixFQUNsQjtRQUNDLElBQUksQ0FBQ25vQyxNQUFNb1ksV0FBVyxFQUFFO1lBQ3RCO1FBQ0Y7UUFDQSxNQUFNa1gsTUFBTTZZO1FBQ1osSUFBSTdZLEtBQUs7WUFDUDtRQUNGO1FBMTdORixLQTI3TnVDLEdBQUd0eUIsUUFBUSxDQUFDOzJDQUNSLEVBQUVnRCxNQUFNVyxXQUFXLENBQUM7Ozs7O0lBSzNELENBQUMsSUFBSSxDQUFNO0lBQ2Y7Q0FBRTtBQUNGLE1BQU15bkMsVUFBVTtJQUFDLFNBQVNDLFNBQVMsRUFDakNyb0MsS0FBSyxFQUNOO1FBQ0MsQ0FBQ0EsTUFBTXNvQyxXQUFXLEdBQUdyc0MsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTywwRUFBMEVBLENBQVdBLEdBQUcsS0FBSztJQUM3SztJQUFHLFNBQVMycEMsaUJBQWlCLEVBQzNCSixpQkFBaUIsRUFDbEI7UUFDQyxDQUFDLENBQUNBLHNCQUFzQmxzQyxLQUFxQyxHQUFHMkMsVUFBVSxPQUFPLHFEQUFxREEsQ0FBV0EsR0FBRyxLQUFLO0lBQzNKO0NBQUU7QUFDRixTQUFTNHBDLGNBQWN2cEMsSUFBSTtJQUN6QjIxQixtQkFBbUI7UUFDakJrVCxVQUFVN29DLE1BQU01QjtRQUNoQixJQUFJNEIsS0FBS2UsS0FBSyxDQUFDa1MsSUFBSSxLQUFLLFlBQVk7WUFDbEM0MUIsVUFBVTdvQyxNQUFNaXBDO1FBQ2xCO1FBQ0EsSUFBSWpwQyxLQUFLZSxLQUFLLENBQUNrUyxJQUFJLEtBQUssV0FBVztZQUNqQzQxQixVQUFVN29DLE1BQU1tcEM7UUFDbEI7SUFDRjtBQUNGO0FBRUEsTUFBTUsscUJBQXFCcHVDLDREQUFtQjtJQUM1QzJFLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ25CLEtBQUssSUFBSUE7UUFDVCxJQUFJLENBQUM0VSxLQUFLLEdBQUc7WUFDWHRJLFdBQVdlLFFBQVEsSUFBSSxDQUFDdE0sS0FBSyxDQUFDMm9DLEVBQUU7WUFDaEN0bUIsTUFBTSxJQUFJLENBQUNyaUIsS0FBSyxDQUFDMm9DLEVBQUU7WUFDbkI5QixTQUFTLElBQUksQ0FBQzdtQyxLQUFLLENBQUNnTCxhQUFhLElBQUksSUFBSSxDQUFDaEwsS0FBSyxDQUFDMm9DLEVBQUUsR0FBRyxTQUFTO1FBQ2hFO1FBQ0EsSUFBSSxDQUFDbkIsT0FBTyxHQUFHO1lBQ2IsSUFBSSxJQUFJLENBQUMzekIsS0FBSyxDQUFDZ3pCLE9BQU8sS0FBSyxTQUFTO2dCQUNsQztZQUNGO1lBQ0EsSUFBSSxDQUFDaG5DLFFBQVEsQ0FBQztnQkFDWjBMLFdBQVc7WUFDYjtRQUNGO0lBQ0Y7SUFDQSxPQUFPcTlCLHlCQUF5QjVvQyxLQUFLLEVBQUU2VCxLQUFLLEVBQUU7UUFDNUMsSUFBSSxDQUFDN1QsTUFBTWdMLGFBQWEsRUFBRTtZQUN4QixPQUFPO2dCQUNMTyxXQUFXZSxRQUFRdE0sTUFBTTJvQyxFQUFFO2dCQUMzQnRtQixNQUFNcmlCLE1BQU0yb0MsRUFBRTtnQkFDZDlCLFNBQVM7WUFDWDtRQUNGO1FBQ0EsSUFBSTdtQyxNQUFNMm9DLEVBQUUsRUFBRTtZQUNaLE9BQU87Z0JBQ0xwOUIsV0FBVztnQkFDWDhXLE1BQU1yaUIsTUFBTTJvQyxFQUFFO2dCQUNkOUIsU0FBUztZQUNYO1FBQ0Y7UUFDQSxJQUFJaHpCLE1BQU10SSxTQUFTLEVBQUU7WUFDbkIsT0FBTztnQkFDTEEsV0FBVztnQkFDWDhXLE1BQU14TyxNQUFNd08sSUFBSTtnQkFDaEJ3a0IsU0FBUztZQUNYO1FBQ0Y7UUFDQSxPQUFPO1lBQ0x0N0IsV0FBVztZQUNYczdCLFNBQVM7WUFDVHhrQixNQUFNO1FBQ1I7SUFDRjtJQUNBdGlCLFNBQVM7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDOFQsS0FBSyxDQUFDdEksU0FBUyxFQUFFO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE1BQU1pWCxXQUFXO1lBQ2ZnbEIsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJubEIsTUFBTSxJQUFJLENBQUN4TyxLQUFLLENBQUN3TyxJQUFJO1lBQ3JCd2tCLFNBQVMsSUFBSSxDQUFDaHpCLEtBQUssQ0FBQ2d6QixPQUFPO1FBQzdCO1FBQ0EsT0FBTyxJQUFJLENBQUM3bUMsS0FBSyxDQUFDQyxRQUFRLENBQUN1aUI7SUFDN0I7QUFDRjtBQUVBLE1BQU1xbUIsWUFBWTdvQyxDQUFBQTtJQUNoQixNQUFNdStCLGFBQWE3akMsaURBQVVBLENBQUMyNEI7SUFDOUIsQ0FBQ2tMLGFBQWF0aUMsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQVdBLEdBQUcsS0FBSztJQUMxSCxNQUFNLEVBQ0ptdUIsU0FBUyxFQUNUelksaUJBQWlCLEVBQ2xCLEdBQUdpcUI7SUFDSixNQUFNdUssZUFBZXR1Qyw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNdXVDLGlCQUFpQnZ1Qyw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNLEVBQ0p5RixRQUFRLEVBQ1JVLFdBQVcsRUFDWDlELElBQUksRUFDSnFWLElBQUksRUFDSnhJLFNBQVMsRUFDVDY4Qix1QkFBdUIsRUFDdkJiLGNBQWMsRUFDZHArQixnQkFBZ0IsRUFDaEJxNkIsUUFBUSxFQUNScUgsUUFBUSxFQUNSenRCLHVCQUF1QixFQUN2QjB0QixvQkFBb0IsRUFDckIsR0FBR2pwQztJQUNKLE1BQU1zbUMsa0JBQWtCanJDLHlEQUFXQSxDQUFDLElBQU15dEMsYUFBYXRqQyxPQUFPLEVBQUUsRUFBRTtJQUNsRSxNQUFNMGpDLGtCQUFrQjd0Qyx5REFBV0EsQ0FBQyxDQUFDZ0IsUUFBUSxJQUFJO1FBQy9DeXNDLGFBQWF0akMsT0FBTyxHQUFHbko7SUFDekIsR0FBRyxFQUFFO0lBQ0wsTUFBTThyQyxvQkFBb0I5c0MseURBQVdBLENBQUMsSUFBTTB0QyxlQUFldmpDLE9BQU8sRUFBRSxFQUFFO0lBQ3RFLE1BQU0yakMsb0JBQW9COXRDLHlEQUFXQSxDQUFDLENBQUNnQixRQUFRLElBQUk7UUFDakQwc0MsZUFBZXZqQyxPQUFPLEdBQUduSjtJQUMzQixHQUFHLEVBQUU7SUFDTG1zQyxjQUFjO1FBQ1p4b0M7UUFDQXNtQztRQUNBNkI7SUFDRjtJQUNBLE1BQU1pQiw2QkFBNkIvdEMseURBQVdBLENBQUM7UUFDN0MsSUFBSWlaLHFCQUFxQjtZQUN2QmlILHdCQUF3QjtnQkFDdEJ4SSxXQUFXb1Q7WUFDYjtRQUNGO0lBQ0YsR0FBRztRQUFDN1I7UUFBbUJpSDtLQUF3QjtJQUMvQ3dxQixzQkFBc0I7UUFDcEJwbEM7UUFDQTlEO1FBQ0FxVjtRQUNBeEk7UUFDQWc4QjtRQUNBcCtCO1FBQ0FpL0I7UUFDQUQ7SUFDRjtJQUNBLE1BQU1sdUIsY0FBY2hkLHFEQUFPQSxDQUFDLGtCQUFNZiwwREFBbUIsQ0FBQ291QyxjQUFjO1lBQ2xFRSxJQUFJM29DLE1BQU1vWSxXQUFXO1lBQ3JCcE4sZUFBZWhMLE1BQU1xcEMsd0JBQXdCO1FBQy9DLEdBQUcsQ0FBQyxFQUNGN0IsT0FBTyxFQUNQbmxCLElBQUksRUFDSndrQixPQUFPLEVBQ1IsaUJBQUt4c0MsMERBQW1CLENBQUNzdEMsZUFBZTtnQkFDdkN2dkIsYUFBYWlLO2dCQUNibWxCLFNBQVNBO2dCQUNUakcsVUFBVTRIO2dCQUNWdEMsU0FBU0E7Z0JBQ1Q5WixXQUFXQTtnQkFDWHVVLGlCQUFpQjhIO1lBQ25CLEtBQUs7UUFBQ3JjO1FBQVdxYztRQUE0QnBwQyxNQUFNb1ksV0FBVztRQUFFcFksTUFBTXFwQyx3QkFBd0I7UUFBRUY7S0FBa0I7SUFDbEgsTUFBTTNtQixXQUFXcG5CLHFEQUFPQSxDQUFDLElBQU87WUFDOUJtbUMsVUFBVTJIO1lBQ1Y5d0I7WUFDQWt4QixnQkFBZ0I7Z0JBQ2QseUJBQXlCM29DO2dCQUN6QixpQ0FBaUNvc0I7WUFDbkM7UUFDRixJQUFJO1FBQUNBO1FBQVdwc0I7UUFBYXlYO1FBQWE4d0I7S0FBZ0I7SUFDMUQsTUFBTXhGLGtCQUFrQnNGLFdBQVdBLFNBQVM3ckIsUUFBUSxDQUFDamMsV0FBVyxHQUFHO0lBQ25FLE1BQU11aUMsbUJBQW1Ccm9DLHFEQUFPQSxDQUFDLElBQU87WUFDdEN1RjtZQUNBOUQ7WUFDQTZtQztRQUNGLElBQUk7UUFBQy9pQztRQUFhK2lDO1FBQWlCN21DO0tBQUs7SUFDeEMsU0FBUzBzQztRQUNQLElBQUksQ0FBQ1AsVUFBVTtZQUNiLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSjdyQixRQUFRLEVBQ1JwZCxNQUFNLEVBQ1AsR0FBR2lwQztRQUNKLE1BQU1RLHFCQUFPbnZDLDBEQUFtQixDQUFDbXBDLGtCQUFrQjtZQUNqRHRpQyxhQUFhaWMsU0FBU2pjLFdBQVc7WUFDakNkLE9BQU8rYyxTQUFTNWMsTUFBTSxDQUFDSCxLQUFLO1lBQzVCb2dDLFNBQVM7WUFDVGh3QixXQUFXO1lBQ1hnbkIseUJBQXlCO1lBQ3pCMkUsNEJBQTRCO1FBQzlCLEdBQUcsQ0FBQ3NOLG1CQUFtQkMsb0JBQXNCM3BDLE9BQU8wcEMsbUJBQW1CQyxtQkFBbUJ2c0I7UUFDMUYscUJBQU94aUIsNkRBQXFCLENBQUM2dUMsTUFBTVA7SUFDckM7SUFDQSxxQkFBTzV1QywwREFBbUIsQ0FBQzZsQyxpQkFBaUJobEMsUUFBUSxFQUFFO1FBQ3BEbUIsT0FBT29uQztJQUNULEdBQUd4akMsU0FBU3VpQixVQUFVbWYsV0FBVzRIO0FBQ25DO0FBRUEsU0FBU0s7SUFDUCxDQUFDMXBCLFNBQVNtTyxJQUFJLEdBQUdweUIsS0FBcUMsR0FBRzJDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQVdBLEdBQUcsS0FBSztJQUM3SCxPQUFPc2hCLFNBQVNtTyxJQUFJO0FBQ3RCO0FBQ0EsTUFBTXdiLGVBQWU7SUFDbkIzM0IsTUFBTTtJQUNOclYsTUFBTTtJQUNONk0sV0FBVztJQUNYZzhCLGdCQUFnQjtJQUNoQnArQixrQkFBa0I7SUFDbEJpL0IseUJBQXlCO0lBQ3pCK0IsYUFBYTtJQUNiVyxzQkFBc0JXO0FBQ3hCO0FBQ0EsTUFBTUUsK0JBQStCdkgsQ0FBQUE7SUFDbkMsSUFBSXdILGNBQWM7UUFDaEIsR0FBR3hILFFBQVE7SUFDYjtJQUNBLElBQUl5SDtJQUNKLElBQUtBLGtCQUFrQkgsYUFBYztRQUNuQyxJQUFJdEgsUUFBUSxDQUFDeUgsZUFBZSxLQUFLM3JCLFdBQVc7WUFDMUMwckIsY0FBYztnQkFDWixHQUFHQSxXQUFXO2dCQUNkLENBQUNDLGVBQWUsRUFBRUgsWUFBWSxDQUFDRyxlQUFlO1lBQ2hEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxNQUFNRSxpQkFBaUIsQ0FBQ3B0QyxNQUFNcVgsV0FBYXJYLFNBQVNxWCxTQUFTaFAsU0FBUyxDQUFDckksSUFBSTtBQUMzRSxNQUFNcXRDLGVBQWUsQ0FBQ2gyQixVQUFVSCxhQUFlQSxXQUFXaE8sVUFBVSxDQUFDbU8sU0FBUzVOLFNBQVMsQ0FBQ3ZGLEVBQUUsQ0FBQztBQUMzRixNQUFNb3BDLHNCQUFzQjtJQUMxQixNQUFNQyxvQkFBb0I7UUFDeEJoeUIsYUFBYTtRQUNiaXhCLDBCQUEwQjtRQUMxQjFILFVBQVU7WUFDUjBJLGdCQUFnQjtZQUNoQkMsa0JBQWtCO1lBQ2xCQyxzQkFBc0I7WUFDdEJDLG9CQUFvQjtRQUN0QjtRQUNBeEIsVUFBVTtJQUNaO0lBQ0EsTUFBTXlCLHVCQUF1QjtRQUMzQixHQUFHTCxpQkFBaUI7UUFDcEJmLDBCQUEwQjtJQUM1QjtJQUNBLE1BQU1xQixxQkFBcUI3dUMsdURBQVVBLENBQUNnSyxDQUFBQSxhQUFlO1lBQ25EM0UsYUFBYTJFLFdBQVc5RSxFQUFFO1lBQzFCbEUsTUFBTWdKLFdBQVdoSixJQUFJO1lBQ3JCMEQsUUFBUTtnQkFDTkgsT0FBT3lGLFdBQVd6RixLQUFLO2dCQUN2Qk8sYUFBYWtGLFdBQVdsRixXQUFXO1lBQ3JDO1FBQ0Y7SUFDQSxNQUFNZ3FDLGNBQWM5dUMsdURBQVVBLENBQUMsQ0FBQ2tGLElBQUl5UCxXQUFXbzZCLDJCQUEyQkMseUJBQXlCMXRCLFVBQVVtckI7UUFDM0csTUFBTXBuQyxjQUFjaWMsU0FBU3RYLFVBQVUsQ0FBQzlFLEVBQUU7UUFDMUMsTUFBTStwQyxTQUFTM3RCLFNBQVN0WCxVQUFVLENBQUNsRixXQUFXLEtBQUtJO1FBQ25ELElBQUkrcEMsUUFBUTtZQUNWLE1BQU05QixXQUFXVixjQUFjO2dCQUM3QnZvQyxRQUFRdW9DO2dCQUNSbnJCLFVBQVV1dEIsbUJBQW1CdnRCLFNBQVN0WCxVQUFVO1lBQ2xELElBQUk7WUFDSixNQUFNODdCLFdBQVc7Z0JBQ2YwSSxnQkFBZ0JPO2dCQUNoQk4sa0JBQWtCTSw0QkFBNEIxcEMsY0FBYztnQkFDNURxcEMsc0JBQXNCcnBDO2dCQUN0QnNwQyxvQkFBb0I7WUFDdEI7WUFDQSxPQUFPO2dCQUNMcHlCLGFBQWErRSxTQUFTL0UsV0FBVztnQkFDakNpeEIsMEJBQTBCO2dCQUMxQjFIO2dCQUNBcUg7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDeDRCLFdBQVc7WUFDZCxPQUFPaTZCO1FBQ1Q7UUFDQSxJQUFJLENBQUNJLHlCQUF5QjtZQUM1QixPQUFPVDtRQUNUO1FBQ0EsTUFBTXpJLFdBQVc7WUFDZjBJLGdCQUFnQk87WUFDaEJOLGtCQUFrQnBwQztZQUNsQnFwQyxzQkFBc0I7WUFDdEJDLG9CQUFvQjtRQUN0QjtRQUNBLE9BQU87WUFDTHB5QixhQUFhK0UsU0FBUy9FLFdBQVc7WUFDakNpeEIsMEJBQTBCO1lBQzFCMUg7WUFDQXFILFVBQVU7UUFDWjtJQUNGO0lBQ0EsTUFBTXZiLFdBQVcsQ0FBQzVaLE9BQU8wdUI7UUFDdkIsTUFBTXdJLDJCQUEyQmpCLDZCQUE2QnZIO1FBQzlELE1BQU14aEMsS0FBS2dxQyx5QkFBeUJwcUMsV0FBVztRQUMvQyxNQUFNOUQsT0FBT2t1Qyx5QkFBeUJsdUMsSUFBSTtRQUMxQyxNQUFNMlQsWUFBWSxDQUFDdTZCLHlCQUF5QnJGLGNBQWM7UUFDMUQsTUFBTTRDLGNBQWN5Qyx5QkFBeUJ6QyxXQUFXO1FBQ3hELElBQUlocEMsV0FBV3VVLFFBQVE7WUFDckIsTUFBTUssV0FBV0wsTUFBTUssUUFBUTtZQUMvQixJQUFJLENBQUMrMUIsZUFBZXB0QyxNQUFNcVgsV0FBVztnQkFDbkMsT0FBT3UyQjtZQUNUO1lBQ0EsTUFBTXR0QixXQUFXK3NCLGFBQWFoMkIsVUFBVUwsTUFBTUUsVUFBVTtZQUN4RCxNQUFNczJCLGlCQUFpQjMyQixrQkFBa0JHLE1BQU1sTixNQUFNLE1BQU01RjtZQUMzRCxPQUFPNHBDLFlBQVk1cEMsSUFBSXlQLFdBQVc2NUIsZ0JBQWdCQSxnQkFBZ0JsdEIsVUFBVW1yQjtRQUM5RTtRQUNBLElBQUl6MEIsTUFBTVUsS0FBSyxLQUFLLGtCQUFrQjtZQUNwQyxNQUFNd0YsWUFBWWxHLE1BQU1rRyxTQUFTO1lBQ2pDLElBQUksQ0FBQ2t3QixlQUFlcHRDLE1BQU1rZCxVQUFVN0YsUUFBUSxHQUFHO2dCQUM3QyxPQUFPdTJCO1lBQ1Q7WUFDQSxNQUFNdHRCLFdBQVcrc0IsYUFBYW53QixVQUFVN0YsUUFBUSxFQUFFTCxNQUFNRSxVQUFVO1lBQ2xFLE9BQU80MkIsWUFBWTVwQyxJQUFJeVAsV0FBV3F4Qiw0QkFBNEI5bkIsVUFBVXZZLE1BQU0sTUFBTVQsSUFBSTJTLGtCQUFrQnFHLFVBQVVwVCxNQUFNLE1BQU01RixJQUFJb2MsVUFBVW1yQjtRQUNoSjtRQUNBLElBQUl6MEIsTUFBTVUsS0FBSyxLQUFLLFVBQVVWLE1BQU1rRyxTQUFTLElBQUksQ0FBQ2xHLE1BQU1tRyxXQUFXLEVBQUU7WUFDbkUsTUFBTUQsWUFBWWxHLE1BQU1rRyxTQUFTO1lBQ2pDLElBQUksQ0FBQ2t3QixlQUFlcHRDLE1BQU1rZCxVQUFVN0YsUUFBUSxHQUFHO2dCQUM3QyxPQUFPdTJCO1lBQ1Q7WUFDQSxNQUFNcHhCLFVBQVUzRixrQkFBa0JxRyxVQUFVcFQsTUFBTSxNQUFNNUY7WUFDeEQsTUFBTWlxQyxlQUFlMStCLFFBQVF5TixVQUFVcFQsTUFBTSxDQUFDQyxFQUFFLElBQUltVCxVQUFVcFQsTUFBTSxDQUFDQyxFQUFFLENBQUMvSixJQUFJLEtBQUs7WUFDakYsTUFBTWl1QyxTQUFTL3dCLFVBQVU3RixRQUFRLENBQUNoUCxTQUFTLENBQUNuRSxFQUFFLEtBQUtBO1lBQ25ELElBQUlzWSxTQUFTO2dCQUNYLE9BQU8yeEIsZUFBZVosb0JBQW9CSztZQUM1QztZQUNBLElBQUlLLFFBQVE7Z0JBQ1YsT0FBT1Y7WUFDVDtZQUNBLE9BQU9LO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsT0FBT2hkO0FBQ1Q7QUFDQSxNQUFNd2QscUJBQXFCO0lBQ3pCMXZCLHlCQUF5QkE7QUFDM0I7QUFDQSxNQUFNMnZCLHFCQUFxQi92QyxvREFBT0EsQ0FBQ2d2QyxxQkFBcUJjLG9CQUFvQixDQUFDRSxZQUFZQyxlQUFlN0k7SUFDdEcsT0FBTztRQUNMLEdBQUd1SCw2QkFBNkJ2SCxTQUFTO1FBQ3pDLEdBQUc0SSxVQUFVO1FBQ2IsR0FBR0MsYUFBYTtJQUNsQjtBQUNGLEdBQUc7SUFDRGxlLFNBQVMrRTtJQUNUc1Isb0JBQW9CM0I7QUFDdEIsR0FBR2lIO0FBQ0gsSUFBSXdDLHVCQUF1Qkg7QUFFb0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kb2t0b3ItZHJ1Y2svLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzP2M5OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NLCB7IGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZSQxLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UsIGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICd1c2UtbWVtby1vbmUnO1xuaW1wb3J0IHsgZ2V0UmVjdCwgZXhwYW5kLCBvZmZzZXQsIHdpdGhTY3JvbGwsIGNhbGN1bGF0ZUJveCwgZ2V0Qm94LCBjcmVhdGVCb3ggfSBmcm9tICdjc3MtYm94LW1vZGVsJztcbmltcG9ydCBtZW1vaXplT25lIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCByYWZTY2hkIGZyb20gJ3JhZi1zY2hkJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcblxuY29uc3QgaXNQcm9kdWN0aW9uJDEgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3Qgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG5jb25zdCBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuY29uc3QgY2xlYW4kMiA9IHZhbHVlID0+IHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG5jb25zdCBnZXREZXZNZXNzYWdlID0gbWVzc2FnZSA9PiBjbGVhbiQyKGBcbiAgJWNAaGVsbG8tcGFuZ2VhL2RuZFxuXG4gICVjJHtjbGVhbiQyKG1lc3NhZ2UpfVxuXG4gICVj8J+Rt+KAjSBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQgb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG5gKTtcbmNvbnN0IGdldEZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlID0+IFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4yZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsICdsaW5lLWhlaWdodDogMS41JywgJ2NvbG9yOiAjNzIzODc0OyddO1xuY29uc3QgaXNEaXNhYmxlZEZsYWcgPSAnX19AaGVsbG8tcGFuZ2VhL2RuZC1kaXNhYmxlLWRldi13YXJuaW5ncyc7XG5mdW5jdGlvbiBsb2codHlwZSwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uJDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1tpc0Rpc2FibGVkRmxhZ10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZVt0eXBlXSguLi5nZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbn1cbmNvbnN0IHdhcm5pbmcgPSBsb2cuYmluZChudWxsLCAnd2FybicpO1xuY29uc3QgZXJyb3IgPSBsb2cuYmluZChudWxsLCAnZXJyb3InKTtcblxuZnVuY3Rpb24gbm9vcCQyKCkge31cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhzaGFyZWQsIGZyb21CaW5kaW5nKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2hhcmVkLFxuICAgIC4uLmZyb21CaW5kaW5nXG4gIH07XG59XG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsLCBiaW5kaW5ncywgc2hhcmVkT3B0aW9ucykge1xuICBjb25zdCB1bmJpbmRpbmdzID0gYmluZGluZ3MubWFwKGJpbmRpbmcgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIGJpbmRpbmcub3B0aW9ucyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgIHVuYmluZGluZ3MuZm9yRWFjaCh1bmJpbmQgPT4ge1xuICAgICAgdW5iaW5kKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5jb25zdCBwcmVmaXgkMSA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmNsYXNzIFJiZEludmFyaWFudCBleHRlbmRzIEVycm9yIHt9XG5SYmRJbnZhcmlhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnVuYmluZCA9IG5vb3AkMjtcbiAgICB0aGlzLm9uV2luZG93RXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmdldENhbGxiYWNrcygpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2FsbGJhY2tzID0gY2FsbGJhY2tzID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH1cbn1cblxuY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gYFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcbmA7XG5jb25zdCBwb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICsgMTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gc3RhcnQgPT4gYFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiAke3Bvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgd2l0aExvY2F0aW9uID0gKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIGNvbnN0IGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgICAgdG8gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICB0byBsaXN0ICR7ZGVzdGluYXRpb24uZHJvcHBhYmxlSWR9XG4gICAgaW4gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgYDtcbn07XG5jb25zdCB3aXRoQ29tYmluZSA9IChpZCwgc291cmNlLCBjb21iaW5lKSA9PiB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1gO1xuICB9XG4gIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfVxuICAgICAgaW4gbGlzdCAke2NvbWJpbmUuZHJvcHBhYmxlSWR9XG4gICAgYDtcbn07XG5jb25zdCBvbkRyYWdVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cbiAgY29uc3QgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuY29uc3QgcmV0dXJuZWRUb1N0YXJ0ID0gc291cmNlID0+IGBcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxuICBvZiAke3Bvc2l0aW9uKHNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgb25EcmFnRW5kID0gcmVzdWx0ID0+IHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cbiAgICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIGNvbnN0IGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbil9XG4gICAgYDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxuICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICBgO1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmRcbn07XG5cbmNvbnN0IG9yaWdpbiA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbmNvbnN0IGFkZCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggKyBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgKyBwb2ludDIueVxufSk7XG5jb25zdCBzdWJ0cmFjdCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxufSk7XG5jb25zdCBpc0VxdWFsJDEgPSAocG9pbnQxLCBwb2ludDIpID0+IHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG5jb25zdCBuZWdhdGUgPSBwb2ludCA9PiAoe1xuICB4OiBwb2ludC54ICE9PSAwID8gLXBvaW50LnggOiAwLFxuICB5OiBwb2ludC55ICE9PSAwID8gLXBvaW50LnkgOiAwXG59KTtcbmNvbnN0IHBhdGNoID0gKGxpbmUsIHZhbHVlLCBvdGhlclZhbHVlID0gMCkgPT4ge1xuICBpZiAobGluZSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZhbHVlLFxuICAgICAgeTogb3RoZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBvdGhlclZhbHVlLFxuICAgIHk6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAocG9pbnQxLCBwb2ludDIpID0+IE1hdGguc3FydCgocG9pbnQyLnggLSBwb2ludDEueCkgKiogMiArIChwb2ludDIueSAtIHBvaW50MS55KSAqKiAyKTtcbmNvbnN0IGNsb3Nlc3QkMSA9ICh0YXJnZXQsIHBvaW50cykgPT4gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBkaXN0YW5jZSh0YXJnZXQsIHBvaW50KSkpO1xuY29uc3QgYXBwbHkgPSBmbiA9PiBwb2ludCA9PiAoe1xuICB4OiBmbihwb2ludC54KSxcbiAgeTogZm4ocG9pbnQueSlcbn0pO1xuXG52YXIgZXhlY3V0ZUNsaXAgPSAoZnJhbWUsIHN1YmplY3QpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBNYXRoLm1heChzdWJqZWN0LnRvcCwgZnJhbWUudG9wKSxcbiAgICByaWdodDogTWF0aC5taW4oc3ViamVjdC5yaWdodCwgZnJhbWUucmlnaHQpLFxuICAgIGJvdHRvbTogTWF0aC5taW4oc3ViamVjdC5ib3R0b20sIGZyYW1lLmJvdHRvbSksXG4gICAgbGVmdDogTWF0aC5tYXgoc3ViamVjdC5sZWZ0LCBmcmFtZS5sZWZ0KVxuICB9KTtcbiAgaWYgKHJlc3VsdC53aWR0aCA8PSAwIHx8IHJlc3VsdC5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBvZmZzZXRCeVBvc2l0aW9uID0gKHNwYWNpbmcsIHBvaW50KSA9PiAoe1xuICB0b3A6IHNwYWNpbmcudG9wICsgcG9pbnQueSxcbiAgbGVmdDogc3BhY2luZy5sZWZ0ICsgcG9pbnQueCxcbiAgYm90dG9tOiBzcGFjaW5nLmJvdHRvbSArIHBvaW50LnksXG4gIHJpZ2h0OiBzcGFjaW5nLnJpZ2h0ICsgcG9pbnQueFxufSk7XG5jb25zdCBnZXRDb3JuZXJzID0gc3BhY2luZyA9PiBbe1xuICB4OiBzcGFjaW5nLmxlZnQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcucmlnaHQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn1dO1xuY29uc3Qgbm9TcGFjaW5nID0ge1xuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDBcbn07XG5cbmNvbnN0IHNjcm9sbCQxID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcbmNvbnN0IGluY3JlYXNlID0gKHRhcmdldCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKSA9PiB7XG4gIGlmICh3aXRoUGxhY2Vob2xkZXIgJiYgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIFtheGlzLmVuZF06IHRhcmdldFtheGlzLmVuZF0gKyB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnlbYXhpcy5saW5lXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCBjbGlwID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKGZyYW1lICYmIGZyYW1lLnNob3VsZENsaXBTdWJqZWN0KSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVDbGlwKGZyYW1lLnBhZ2VNYXJnaW5Cb3gsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGdldFJlY3QodGFyZ2V0KTtcbn07XG52YXIgZ2V0U3ViamVjdCA9ICh7XG4gIHBhZ2UsXG4gIHdpdGhQbGFjZWhvbGRlcixcbiAgYXhpcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGwkMShwYWdlLm1hcmdpbkJveCwgZnJhbWUpO1xuICBjb25zdCBpbmNyZWFzZWQgPSBpbmNyZWFzZShzY3JvbGxlZCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKTtcbiAgY29uc3QgY2xpcHBlZCA9IGNsaXAoaW5jcmVhc2VkLCBmcmFtZSk7XG4gIHJldHVybiB7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXIsXG4gICAgYWN0aXZlOiBjbGlwcGVkXG4gIH07XG59O1xuXG52YXIgc2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgbmV3U2Nyb2xsKSA9PiB7XG4gICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBzY3JvbGxhYmxlID0gZHJvcHBhYmxlLmZyYW1lO1xuICBjb25zdCBzY3JvbGxEaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsKTtcbiAgY29uc3Qgc2Nyb2xsRGlzcGxhY2VtZW50ID0gbmVnYXRlKHNjcm9sbERpZmYpO1xuICBjb25zdCBmcmFtZSA9IHtcbiAgICAuLi5zY3JvbGxhYmxlLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IHNjcm9sbERpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogc2Nyb2xsRGlzcGxhY2VtZW50XG4gICAgICB9LFxuICAgICAgbWF4OiBzY3JvbGxhYmxlLnNjcm9sbC5tYXhcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvRHJvcHBhYmxlTWFwID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IGRyb3BwYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTWFwID0gbWVtb2l6ZU9uZShkcmFnZ2FibGVzID0+IGRyYWdnYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJvcHBhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyb3BwYWJsZXMpKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyYWdnYWJsZXMpKTtcblxudmFyIGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUgPSBtZW1vaXplT25lKChkcm9wcGFibGVJZCwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSB0b0RyYWdnYWJsZUxpc3QoZHJhZ2dhYmxlcykuZmlsdGVyKGRyYWdnYWJsZSA9PiBkcm9wcGFibGVJZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpLnNvcnQoKGEsIGIpID0+IGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuZGVzdGluYXRpb247XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cnlHZXRDb21iaW5lKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmNvbWJpbmU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCA9IG1lbW9pemVPbmUoKHJlbW92ZSwgbGlzdCkgPT4gbGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlc2NyaXB0b3IuaWQgIT09IHJlbW92ZS5kZXNjcmlwdG9yLmlkKSk7XG5cbnZhciBtb3ZlVG9OZXh0Q29tYmluZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIHByZXZpb3VzSW1wYWN0XG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24ocHJldmlvdXNJbXBhY3QpO1xuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW1wYWN0KHRhcmdldCkge1xuICAgIGNvbnN0IGF0ID0ge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogdGFyZ2V0LFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnByZXZpb3VzSW1wYWN0LFxuICAgICAgYXRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGFsbCA9IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZC5hbGw7XG4gIGNvbnN0IGNsb3Nlc3RJZCA9IGFsbC5sZW5ndGggPyBhbGxbMF0gOiBudWxsO1xuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3RJZCA/IGdldEltcGFjdChjbG9zZXN0SWQpIDogbnVsbDtcbiAgfVxuICBjb25zdCB3aXRob3V0RHJhZ2dhYmxlID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGlmICghY2xvc2VzdElkKSB7XG4gICAgaWYgKCF3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB3aXRob3V0RHJhZ2dhYmxlW3dpdGhvdXREcmFnZ2FibGUubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGdldEltcGFjdChsYXN0LmRlc2NyaXB0b3IuaWQpO1xuICB9XG4gIGNvbnN0IGluZGV4T2ZDbG9zZXN0ID0gd2l0aG91dERyYWdnYWJsZS5maW5kSW5kZXgoZCA9PiBkLmRlc2NyaXB0b3IuaWQgPT09IGNsb3Nlc3RJZCk7XG4gICEoaW5kZXhPZkNsb3Nlc3QgIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGRpc3BsYWNlZCBpdGVtIGluIHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSBpbmRleE9mQ2xvc2VzdCAtIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGJlZm9yZSA9IHdpdGhvdXREcmFnZ2FibGVbcHJvcG9zZWRJbmRleF07XG4gIHJldHVybiBnZXRJbXBhY3QoYmVmb3JlLmRlc2NyaXB0b3IuaWQpO1xufTtcblxudmFyIGlzSG9tZU9mID0gKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID0+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkO1xuXG5jb25zdCBub0Rpc3BsYWNlZEJ5ID0ge1xuICBwb2ludDogb3JpZ2luLFxuICB2YWx1ZTogMFxufTtcbmNvbnN0IGVtcHR5R3JvdXBzID0ge1xuICBpbnZpc2libGU6IHt9LFxuICB2aXNpYmxlOiB7fSxcbiAgYWxsOiBbXVxufTtcbmNvbnN0IG5vSW1wYWN0ID0ge1xuICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgYXQ6IG51bGxcbn07XG5cbnZhciBpc1dpdGhpbiA9IChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA9PiB2YWx1ZSA9PiBsb3dlckJvdW5kIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVwcGVyQm91bmQ7XG5cbnZhciBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIGlmIChpc0NvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSB8fCBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKTtcbiAgICBjb25zdCBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgPSBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSB8fCBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlDb250YWluZWQgPSBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseTtcbiAgICBpZiAoaXNQYXJ0aWFsbHlDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0JpZ2dlclZlcnRpY2FsbHkgPSBzdWJqZWN0LnRvcCA8IGZyYW1lLnRvcCAmJiBzdWJqZWN0LmJvdHRvbSA+IGZyYW1lLmJvdHRvbTtcbiAgICBjb25zdCBpc0JpZ2dlckhvcml6b250YWxseSA9IHN1YmplY3QubGVmdCA8IGZyYW1lLmxlZnQgJiYgc3ViamVjdC5yaWdodCA+IGZyYW1lLnJpZ2h0O1xuICAgIGNvbnN0IGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzQmlnZ2VySG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSB8fCBpc0JpZ2dlckhvcml6b250YWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5O1xuICAgIHJldHVybiBpc1RhcmdldEJpZ2dlck9uT25lQXhpcztcbiAgfTtcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICByZXR1cm4gaXNDb250YWluZWQ7XG4gIH07XG59O1xuXG5jb25zdCB2ZXJ0aWNhbCA9IHtcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBsaW5lOiAneScsXG4gIGNyb3NzQXhpc0xpbmU6ICd4JyxcbiAgc3RhcnQ6ICd0b3AnLFxuICBlbmQ6ICdib3R0b20nLFxuICBzaXplOiAnaGVpZ2h0JyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICdsZWZ0JyxcbiAgY3Jvc3NBeGlzRW5kOiAncmlnaHQnLFxuICBjcm9zc0F4aXNTaXplOiAnd2lkdGgnXG59O1xuY29uc3QgaG9yaXpvbnRhbCA9IHtcbiAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIGxpbmU6ICd4JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3knLFxuICBzdGFydDogJ2xlZnQnLFxuICBlbmQ6ICdyaWdodCcsXG4gIHNpemU6ICd3aWR0aCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAndG9wJyxcbiAgY3Jvc3NBeGlzRW5kOiAnYm90dG9tJyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ2hlaWdodCdcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzID0gYXhpcyA9PiBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGlmIChheGlzID09PSB2ZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICB9O1xufTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlRGlzcGxhY2VkID0gKHRhcmdldCwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGVzdGluYXRpb24uZnJhbWUgPyBkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQgOiBvcmlnaW47XG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZGlzcGxhY2VtZW50KTtcbn07XG5jb25zdCBpc1Zpc2libGVJbkRyb3BwYWJsZSA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbihkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkodGFyZ2V0KTtcbn07XG5jb25zdCBpc1Zpc2libGVJblZpZXdwb3J0ID0gKHRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSA9PiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbih2aWV3cG9ydCkodGFyZ2V0KTtcbmNvbnN0IGlzVmlzaWJsZSQxID0gKHtcbiAgdGFyZ2V0OiB0b0JlRGlzcGxhY2VkLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuXG59KSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlZFRhcmdldCA9IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPyBnZXREcm9wcGFibGVEaXNwbGFjZWQodG9CZURpc3BsYWNlZCwgZGVzdGluYXRpb24pIDogdG9CZURpc3BsYWNlZDtcbiAgcmV0dXJuIGlzVmlzaWJsZUluRHJvcHBhYmxlKGRpc3BsYWNlZFRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSAmJiBpc1Zpc2libGVJblZpZXdwb3J0KGRpc3BsYWNlZFRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKTtcbn07XG5jb25zdCBpc1BhcnRpYWxseVZpc2libGUgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG59KTtcbmNvbnN0IGlzVG90YWxseVZpc2libGVPbkF4aXMgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMoYXJncy5kZXN0aW5hdGlvbi5heGlzKVxufSk7XG5cbmNvbnN0IGdldFNob3VsZEFuaW1hdGUgPSAoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSkgPT4ge1xuICBpZiAodHlwZW9mIGZvcmNlU2hvdWxkQW5pbWF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW52aXNpYmxlLFxuICAgIHZpc2libGVcbiAgfSA9IGxhc3Q7XG4gIGlmIChpbnZpc2libGVbaWRdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzID0gdmlzaWJsZVtpZF07XG4gIHJldHVybiBwcmV2aW91cyA/IHByZXZpb3VzLnNob3VsZEFuaW1hdGUgOiB0cnVlO1xufTtcbmZ1bmN0aW9uIGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KSB7XG4gIGNvbnN0IG1hcmdpbkJveCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcbiAgY29uc3QgZXhwYW5kQnkgPSB7XG4gICAgdG9wOiBkaXNwbGFjZWRCeS5wb2ludC55LFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiBkaXNwbGFjZWRCeS5wb2ludC54XG4gIH07XG4gIHJldHVybiBnZXRSZWN0KGV4cGFuZChtYXJnaW5Cb3gsIGV4cGFuZEJ5KSk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICBhZnRlckRyYWdnaW5nLFxuICBkZXN0aW5hdGlvbixcbiAgZGlzcGxhY2VkQnksXG4gIHZpZXdwb3J0LFxuICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gIGxhc3Rcbn0pIHtcbiAgcmV0dXJuIGFmdGVyRHJhZ2dpbmcucmVkdWNlKGZ1bmN0aW9uIHByb2Nlc3MoZ3JvdXBzLCBkcmFnZ2FibGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSk7XG4gICAgY29uc3QgaWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZDtcbiAgICBncm91cHMuYWxsLnB1c2goaWQpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IGlzUGFydGlhbGx5VmlzaWJsZSh7XG4gICAgICB0YXJnZXQsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICBncm91cHMuaW52aXNpYmxlW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkQW5pbWF0ZShpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB7XG4gICAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgICBzaG91bGRBbmltYXRlXG4gICAgfTtcbiAgICBncm91cHMudmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfSwge1xuICAgIGFsbDogW10sXG4gICAgdmlzaWJsZToge30sXG4gICAgaW52aXNpYmxlOiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhPZkxhc3RJdGVtKGRyYWdnYWJsZXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFkcmFnZ2FibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGluZGV4T2ZMYXN0SXRlbSA9IGRyYWdnYWJsZXNbZHJhZ2dhYmxlcy5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICByZXR1cm4gb3B0aW9ucy5pbkhvbWVMaXN0ID8gaW5kZXhPZkxhc3RJdGVtIDogaW5kZXhPZkxhc3RJdGVtICsgMTtcbn1cbmZ1bmN0aW9uIGdvQXRFbmQoe1xuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgaW5Ib21lTGlzdCxcbiAgZGlzcGxhY2VkQnksXG4gIGRlc3RpbmF0aW9uXG59KSB7XG4gIGNvbnN0IG5ld0luZGV4ID0gZ2V0SW5kZXhPZkxhc3RJdGVtKGluc2lkZURlc3RpbmF0aW9uLCB7XG4gICAgaW5Ib21lTGlzdFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gIGRyYWdnYWJsZSxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGRlc3RpbmF0aW9uLFxuICB2aWV3cG9ydCxcbiAgZGlzcGxhY2VkQnksXG4gIGxhc3QsXG4gIGluZGV4LFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pIHtcbiAgY29uc3QgaW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbmQoaXRlbSA9PiBpdGVtLmRlc2NyaXB0b3IuaW5kZXggPT09IGluZGV4KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3Qgc2xpY2VGcm9tID0gaW5zaWRlRGVzdGluYXRpb24uaW5kZXhPZihtYXRjaCk7XG4gIGNvbnN0IGltcGFjdGVkID0gd2l0aG91dERyYWdnaW5nLnNsaWNlKHNsaWNlRnJvbSk7XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogaW1wYWN0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlSWQsIGFmdGVyQ3JpdGljYWwpIHtcbiAgcmV0dXJuIEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtkcmFnZ2FibGVJZF0pO1xufVxuXG52YXIgZnJvbUNvbWJpbmUgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGRlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGVzLFxuICBjb21iaW5lLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbWJpbmVJZCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gZHJhZ2dhYmxlc1tjb21iaW5lSWRdO1xuICBjb25zdCBjb21iaW5lV2l0aEluZGV4ID0gY29tYmluZVdpdGguZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZUlkLCBhZnRlckNyaXRpY2FsKTtcbiAgaWYgKGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsKSB7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4IC0gMTtcbiAgfVxuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggKyAxO1xuICB9XG4gIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xufTtcblxudmFyIGZyb21SZW9yZGVyID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBsb2NhdGlvblxufSkgPT4ge1xuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRJbmRleCA9IGxvY2F0aW9uLmluZGV4O1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaXNNb3ZpbmdGb3J3YXJkID8gY3VycmVudEluZGV4ICsgMSA6IGN1cnJlbnRJbmRleCAtIDE7XG4gIGNvbnN0IGZpcnN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvblswXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBsYXN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCB1cHBlckJvdW5kID0gaXNJbkhvbWVMaXN0ID8gbGFzdEluZGV4IDogbGFzdEluZGV4ICsgMTtcbiAgaWYgKHByb3Bvc2VkSW5kZXggPCBmaXJzdEluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHByb3Bvc2VkSW5kZXggPiB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHByb3Bvc2VkSW5kZXg7XG59O1xuXG52YXIgbW92ZVRvTmV4dEluZGV4ID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgd2FzQXQgPSBwcmV2aW91c0ltcGFjdC5hdDtcbiAgIXdhc0F0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IG1vdmUgaW4gZGlyZWN0aW9uIHdpdGhvdXQgcHJldmlvdXMgaW1wYWN0IGxvY2F0aW9uJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgaWYgKHdhc0F0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIGNvbnN0IG5ld0luZGV4ID0gZnJvbVJlb3JkZXIoe1xuICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0LFxuICAgICAgbG9jYXRpb246IHdhc0F0LmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb25cbiAgICB9KTtcbiAgICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG5ld0luZGV4ID0gZnJvbUNvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGNvbWJpbmU6IHdhc0F0LmNvbWJpbmUsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKG5ld0luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufTtcblxudmFyIGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCA9ICh7XG4gIGRpc3BsYWNlZCxcbiAgYWZ0ZXJDcml0aWNhbCxcbiAgY29tYmluZVdpdGgsXG4gIGRpc3BsYWNlZEJ5XG59KSA9PiB7XG4gIGNvbnN0IGlzRGlzcGxhY2VkID0gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtjb21iaW5lV2l0aF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtjb21iaW5lV2l0aF0pO1xuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVXaXRoLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIHJldHVybiBpc0Rpc3BsYWNlZCA/IG9yaWdpbiA6IG5lZ2F0ZShkaXNwbGFjZWRCeS5wb2ludCk7XG4gIH1cbiAgcmV0dXJuIGlzRGlzcGxhY2VkID8gZGlzcGxhY2VkQnkucG9pbnQgOiBvcmlnaW47XG59O1xuXG52YXIgd2hlbkNvbWJpbmluZyA9ICh7XG4gIGFmdGVyQ3JpdGljYWwsXG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlc1xufSkgPT4ge1xuICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAhY29tYmluZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY2VudGVyID0gZHJhZ2dhYmxlc1tjb21iaW5lV2l0aF0ucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBkaXNwbGFjZUJ5ID0gZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50KHtcbiAgICBkaXNwbGFjZWQ6IGltcGFjdC5kaXNwbGFjZWQsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBjb21iaW5lV2l0aCxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5XG4gIH0pO1xuICByZXR1cm4gYWRkKGNlbnRlciwgZGlzcGxhY2VCeSk7XG59O1xuXG5jb25zdCBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLnN0YXJ0XSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG5jb25zdCBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciA9IChheGlzLCBib3gpID0+IGJveC5tYXJnaW5bYXhpcy5lbmRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciA9IChheGlzLCB0YXJnZXQsIGlzTW92aW5nKSA9PiB0YXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5tYXJnaW5bYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5ib3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTaXplXSAvIDI7XG5jb25zdCBnb0FmdGVyID0gKHtcbiAgYXhpcyxcbiAgbW92ZVJlbGF0aXZlVG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLmVuZF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbmNvbnN0IGdvQmVmb3JlID0gKHtcbiAgYXhpcyxcbiAgbW92ZVJlbGF0aXZlVG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLnN0YXJ0XSAtIGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbmNvbnN0IGdvSW50b1N0YXJ0ID0gKHtcbiAgYXhpcyxcbiAgbW92ZUludG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVJbnRvLmNvbnRlbnRCb3hbYXhpcy5zdGFydF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVJbnRvLmNvbnRlbnRCb3gsIGlzTW92aW5nKSk7XG5cbnZhciB3aGVuUmVvcmRlcmluZyA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZHJhZ2dhYmxlUGFnZSA9IGRyYWdnYWJsZS5wYWdlO1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdvSW50b1N0YXJ0KHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlSW50bzogZHJvcHBhYmxlLnBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnlcbiAgfSA9IGltcGFjdDtcbiAgY29uc3QgY2xvc2VzdEFmdGVyID0gZGlzcGxhY2VkLmFsbFswXTtcbiAgaWYgKGNsb3Nlc3RBZnRlcikge1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBkcmFnZ2FibGVzW2Nsb3Nlc3RBZnRlcl07XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjbG9zZXN0QWZ0ZXIsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgICBheGlzLFxuICAgICAgICBtb3ZlUmVsYXRpdmVUbzogY2xvc2VzdC5wYWdlLFxuICAgICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBvZmZzZXQoY2xvc2VzdC5wYWdlLCBkaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogd2l0aERpc3BsYWNlbWVudCxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdC5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVQYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIH1cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChsYXN0LmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgY29uc3QgcGFnZSA9IG9mZnNldChsYXN0LnBhZ2UsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSk7XG4gICAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiBwYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZ29BZnRlcih7XG4gICAgYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbGFzdC5wYWdlLFxuICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gIH0pO1xufTtcblxudmFyIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSAoZHJvcHBhYmxlLCBwb2ludCkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICByZXR1cm4gYWRkKHBvaW50LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcblxuY29uc3QgZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHdoZW5SZW9yZGVyaW5nKHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHdoZW5Db21iaW5pbmcoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xudmFyIGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0ID0gYXJncyA9PiB7XG4gIGNvbnN0IHdpdGhvdXREaXNwbGFjZW1lbnQgPSBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50KGFyZ3MpO1xuICBjb25zdCBkcm9wcGFibGUgPSBhcmdzLmRyb3BwYWJsZTtcbiAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IGRyb3BwYWJsZSA/IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZHJvcHBhYmxlLCB3aXRob3V0RGlzcGxhY2VtZW50KSA6IHdpdGhvdXREaXNwbGFjZW1lbnQ7XG4gIHJldHVybiB3aXRoRGlzcGxhY2VtZW50O1xufTtcblxudmFyIHNjcm9sbFZpZXdwb3J0ID0gKHZpZXdwb3J0LCBuZXdTY3JvbGwpID0+IHtcbiAgY29uc3QgZGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBuZWdhdGUoZGlmZik7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBuZXdTY3JvbGwueSxcbiAgICBib3R0b206IG5ld1Njcm9sbC55ICsgdmlld3BvcnQuZnJhbWUuaGVpZ2h0LFxuICAgIGxlZnQ6IG5ld1Njcm9sbC54LFxuICAgIHJpZ2h0OiBuZXdTY3JvbGwueCArIHZpZXdwb3J0LmZyYW1lLndpZHRoXG4gIH0pO1xuICBjb25zdCB1cGRhdGVkID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBkaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVkO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyQxKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG5mdW5jdGlvbiB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSBncm91cHNbaV0udmlzaWJsZVtpZF07XG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgc3BlY3VsYXRpdmVseUluY3JlYXNlID0gKHtcbiAgaW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIG1heFNjcm9sbENoYW5nZVxufSkgPT4ge1xuICBjb25zdCBzY3JvbGxlZFZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQodmlld3BvcnQsIGFkZCh2aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSk7XG4gIGNvbnN0IHNjcm9sbGVkRHJvcHBhYmxlID0gZGVzdGluYXRpb24uZnJhbWUgPyBzY3JvbGxEcm9wcGFibGUoZGVzdGluYXRpb24sIGFkZChkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSkgOiBkZXN0aW5hdGlvbjtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IHdpdGhWaWV3cG9ydFNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyQxKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiBzY3JvbGxlZFZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgd2l0aERyb3BwYWJsZVNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyQxKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbjogc2Nyb2xsZWREcm9wcGFibGUsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbnZpc2libGUgPSB7fTtcbiAgY29uc3QgdmlzaWJsZSA9IHt9O1xuICBjb25zdCBncm91cHMgPSBbbGFzdCwgd2l0aFZpZXdwb3J0U2Nyb2xsLCB3aXRoRHJvcHBhYmxlU2Nyb2xsXTtcbiAgbGFzdC5hbGwuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKTtcbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICB2aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52aXNpYmxlW2lkXSA9IHRydWU7XG4gIH0pO1xuICBjb25zdCBuZXdJbXBhY3QgPSB7XG4gICAgLi4uaW1wYWN0LFxuICAgIGRpc3BsYWNlZDoge1xuICAgICAgYWxsOiBsYXN0LmFsbCxcbiAgICAgIGludmlzaWJsZSxcbiAgICAgIHZpc2libGVcbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXdJbXBhY3Q7XG59O1xuXG52YXIgd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50ID0gKHZpZXdwb3J0LCBwb2ludCkgPT4gYWRkKHZpZXdwb3J0LnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCwgcG9pbnQpO1xuXG52YXIgZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlID0gd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50KHZpZXdwb3J0LCBwYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3Qod2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gYWRkKGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlciwgb2Zmc2V0KTtcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbiA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHZpZXdwb3J0LFxuICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICBvbmx5T25NYWluQXhpcyA9IGZhbHNlXG59KSA9PiB7XG4gIGNvbnN0IGNoYW5nZU5lZWRlZCA9IHN1YnRyYWN0KG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICBjb25zdCBzaGlmdGVkID0gb2Zmc2V0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIGNoYW5nZU5lZWRlZCk7XG4gIGNvbnN0IGFyZ3MgPSB7XG4gICAgdGFyZ2V0OiBzaGlmdGVkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIG9ubHlPbk1haW5BeGlzID8gaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyhhcmdzKSA6IGlzVG90YWxseVZpc2libGUoYXJncyk7XG59O1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGlzSW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICBjb25zdCBpbXBhY3QgPSBtb3ZlVG9OZXh0Q29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdFxuICB9KSB8fCBtb3ZlVG9OZXh0SW5kZXgoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBpc0luSG9tZUxpc3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gIH0pO1xuICBpZiAoaXNWaXNpYmxlSW5OZXdMb2NhdGlvbikge1xuICAgIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3QsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgZGlzdGFuY2UgPSBzdWJ0cmFjdChwYWdlQm9yZGVyQm94Q2VudGVyLCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICBjb25zdCBjYXV0aW91cyA9IHNwZWN1bGF0aXZlbHlJbmNyZWFzZSh7XG4gICAgaW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbWF4U2Nyb2xsQ2hhbmdlOiBkaXN0YW5jZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb246IHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdDogY2F1dGlvdXMsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IGRpc3RhbmNlXG4gIH07XG59O1xuXG5jb25zdCBnZXRLbm93bkFjdGl2ZSA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IHJlY3QgPSBkcm9wcGFibGUuc3ViamVjdC5hY3RpdmU7XG4gICFyZWN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBjbGlwcGVkIGFyZWEgZnJvbSBkcm9wcGFibGUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gcmVjdDtcbn07XG52YXIgZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgc291cmNlLFxuICBkcm9wcGFibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCBhY3RpdmUgPSBzb3VyY2Uuc3ViamVjdC5hY3RpdmU7XG4gIGlmICghYWN0aXZlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYXhpcyA9IHNvdXJjZS5heGlzO1xuICBjb25zdCBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuc3RhcnRdLCBhY3RpdmVbYXhpcy5lbmRdKTtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZHJvcHBhYmxlID0+IGRyb3BwYWJsZSAhPT0gc291cmNlKS5maWx0ZXIoZHJvcHBhYmxlID0+IGRyb3BwYWJsZS5pc0VuYWJsZWQpLmZpbHRlcihkcm9wcGFibGUgPT4gQm9vbGVhbihkcm9wcGFibGUuc3ViamVjdC5hY3RpdmUpKS5maWx0ZXIoZHJvcHBhYmxlID0+IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSh2aWV3cG9ydC5mcmFtZSkoZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKSkpLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gYWN0aXZlW2F4aXMuY3Jvc3NBeGlzRW5kXSA8IGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzRW5kXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzU3RhcnRdIDwgYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICB9KS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG4gICAgY29uc3QgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0sIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuZW5kXSk7XG4gIH0pLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGdldEtub3duQWN0aXZlKGEpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IHNlY29uZCA9IGdldEtub3duQWN0aXZlKGIpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG4gICAgcmV0dXJuIHNlY29uZCAtIGZpcnN0O1xuICB9KS5maWx0ZXIoKGRyb3BwYWJsZSwgaW5kZXgsIGFycmF5KSA9PiBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdID09PSBnZXRLbm93bkFjdGl2ZShhcnJheVswXSlbYXhpcy5jcm9zc0F4aXNTdGFydF0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF07XG4gIH1cbiAgY29uc3QgY29udGFpbnMgPSBjYW5kaWRhdGVzLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGlzV2l0aGluRHJvcHBhYmxlID0gaXNXaXRoaW4oZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLnN0YXJ0XSwgZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc1dpdGhpbkRyb3BwYWJsZShwYWdlQm9yZGVyQm94Q2VudGVyW2F4aXMubGluZV0pO1xuICB9KTtcbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjb250YWluc1swXTtcbiAgfVxuICBpZiAoY29udGFpbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjb250YWlucy5zb3J0KChhLCBiKSA9PiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdKVswXTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBjbG9zZXN0JDEocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShhKSkpO1xuICAgIGNvbnN0IHNlY29uZCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGIpKSk7XG4gICAgaWYgKGZpcnN0ICE9PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF07XG4gIH0pWzBdO1xufTtcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBzdWJ0cmFjdChvcmlnaW5hbCwgYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkgOiBvcmlnaW5hbDtcbn07XG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveCA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3g7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gb2Zmc2V0QnlQb3NpdGlvbihvcmlnaW5hbCwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKSA6IG9yaWdpbmFsO1xufTtcblxudmFyIGdldENsb3Nlc3REcmFnZ2FibGUgPSAoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICB2aWV3cG9ydCxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHNvcnRlZCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbHRlcihkcmFnZ2FibGUgPT4gaXNUb3RhbGx5VmlzaWJsZSh7XG4gICAgdGFyZ2V0OiBnZXRDdXJyZW50UGFnZUJvcmRlckJveChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gIH0pKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZGlzdGFuY2VUb0EgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihhLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9CID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYiwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBpZiAoZGlzdGFuY2VUb0EgPCBkaXN0YW5jZVRvQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoZGlzdGFuY2VUb0IgPCBkaXN0YW5jZVRvQSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICByZXR1cm4gc29ydGVkWzBdIHx8IG51bGw7XG59O1xuXG52YXIgZ2V0RGlzcGxhY2VkQnkgPSBtZW1vaXplT25lKGZ1bmN0aW9uIGdldERpc3BsYWNlZEJ5KGF4aXMsIGRpc3BsYWNlQnkpIHtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VCeVtheGlzLmxpbmVdO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBkaXNwbGFjZW1lbnQsXG4gICAgcG9pbnQ6IHBhdGNoKGF4aXMubGluZSwgZGlzcGxhY2VtZW50KVxuICB9O1xufSk7XG5cbmNvbnN0IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIgPSAoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgYXhpcyA9IGRyb3BwYWJsZS5heGlzO1xuICBpZiAoZHJvcHBhYmxlLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV0pO1xuICB9XG4gIGNvbnN0IGF2YWlsYWJsZVNwYWNlID0gZHJvcHBhYmxlLnN1YmplY3QucGFnZS5jb250ZW50Qm94W2F4aXMuc2l6ZV07XG4gIGNvbnN0IGluc2lkZURyb3BwYWJsZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBzcGFjZVVzZWQgPSBpbnNpZGVEcm9wcGFibGUucmVkdWNlKChzdW0sIGRpbWVuc2lvbikgPT4gc3VtICsgZGltZW5zaW9uLmNsaWVudC5tYXJnaW5Cb3hbYXhpcy5zaXplXSwgMCk7XG4gIGNvbnN0IHJlcXVpcmVkU3BhY2UgPSBzcGFjZVVzZWQgKyBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXTtcbiAgY29uc3QgbmVlZHNUb0dyb3dCeSA9IHJlcXVpcmVkU3BhY2UgLSBhdmFpbGFibGVTcGFjZTtcbiAgaWYgKG5lZWRzVG9Hcm93QnkgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG5lZWRzVG9Hcm93QnkpO1xufTtcbmNvbnN0IHdpdGhNYXhTY3JvbGwgPSAoZnJhbWUsIG1heCkgPT4gKHtcbiAgLi4uZnJhbWUsXG4gIHNjcm9sbDoge1xuICAgIC4uLmZyYW1lLnNjcm9sbCxcbiAgICBtYXhcbiAgfVxufSk7XG5jb25zdCBhZGRQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgISFpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgbm90IGFkZCBwbGFjZWhvbGRlciBzcGFjZSB0byBob21lIGxpc3QnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhIWRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBhZGQgcGxhY2Vob2xkZXIgc2l6ZSB0byBhIHN1YmplY3Qgd2hlbiBpdCBhbHJlYWR5IGhhcyBvbmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBwbGFjZWhvbGRlclNpemUgPSBnZXREaXNwbGFjZWRCeShkcm9wcGFibGUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpLnBvaW50O1xuICBjb25zdCByZXF1aXJlZEdyb3d0aCA9IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBhZGRlZCA9IHtcbiAgICBwbGFjZWhvbGRlclNpemUsXG4gICAgaW5jcmVhc2VkQnk6IHJlcXVpcmVkR3Jvd3RoLFxuICAgIG9sZEZyYW1lTWF4U2Nyb2xsOiBkcm9wcGFibGUuZnJhbWUgPyBkcm9wcGFibGUuZnJhbWUuc2Nyb2xsLm1heCA6IG51bGxcbiAgfTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogZHJvcHBhYmxlLmZyYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1heFNjcm9sbCA9IHJlcXVpcmVkR3Jvd3RoID8gYWRkKGZyYW1lLnNjcm9sbC5tYXgsIHJlcXVpcmVkR3Jvd3RoKSA6IGZyYW1lLnNjcm9sbC5tYXg7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuY29uc3QgcmVtb3ZlUGxhY2Vob2xkZXIgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBhZGRlZCA9IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcjtcbiAgIWFkZGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbW92ZSBwbGFjZWhvbGRlciBmb3JtIHN1YmplY3Qgd2hlbiB0aGVyZSB3YXMgbm9uZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgICAgZnJhbWU6IG51bGwsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdFxuICAgIH07XG4gIH1cbiAgY29uc3Qgb2xkTWF4U2Nyb2xsID0gYWRkZWQub2xkRnJhbWVNYXhTY3JvbGw7XG4gICFvbGRNYXhTY3JvbGwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcm9wcGFibGUgd2l0aCBmcmFtZSB0byBoYXZlIG9sZCBtYXggZnJhbWUgc2Nyb2xsIHdoZW4gcmVtb3ZpbmcgcGxhY2Vob2xkZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG9sZE1heFNjcm9sbCk7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuXG52YXIgbW92ZVRvTmV3RHJvcHBhYmxlID0gKHtcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghbW92ZVJlbGF0aXZlVG8pIHtcbiAgICBpZiAoaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvcG9zZWQgPSB7XG4gICAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgICAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gICAgICBhdDoge1xuICAgICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgICAgaW1wYWN0OiBwcm9wb3NlZCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzLFxuICAgICAgYWZ0ZXJDcml0aWNhbFxuICAgIH0pO1xuICAgIGNvbnN0IHdpdGhQbGFjZWhvbGRlciA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID8gZGVzdGluYXRpb24gOiBhZGRQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgICBjb25zdCBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb246IHdpdGhQbGFjZWhvbGRlcixcbiAgICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA/IHByb3Bvc2VkIDogbnVsbDtcbiAgfVxuICBjb25zdCBpc0dvaW5nQmVmb3JlVGFyZ2V0ID0gQm9vbGVhbihwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSA8PSBtb3ZlUmVsYXRpdmVUby5wYWdlLmJvcmRlckJveC5jZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSk7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSAoKCkgPT4ge1xuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmluZGV4O1xuICAgIGlmIChtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuICAgIGlmIChpc0dvaW5nQmVmb3JlVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlVG8gKyAxO1xuICB9KSgpO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBlbXB0eUdyb3VwcyxcbiAgICBpbmRleDogcHJvcG9zZWRJbmRleFxuICB9KTtcbn07XG5cbnZhciBtb3ZlQ3Jvc3NBeGlzID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIGRyYWdnYWJsZSxcbiAgaXNPdmVyLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgc291cmNlOiBpc092ZXIsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgbW92ZVJlbGF0aXZlVG8gPSBnZXRDbG9zZXN0RHJhZ2dhYmxlKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV3RHJvcHBhYmxlKHtcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbW92ZVJlbGF0aXZlVG8sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gIH07XG59O1xuXG52YXIgd2hhdElzRHJhZ2dlZE92ZXIgPSBpbXBhY3QgPT4ge1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gYXQuZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIGF0LmNvbWJpbmUuZHJvcHBhYmxlSWQ7XG59O1xuXG5jb25zdCBnZXREcm9wcGFibGVPdmVyJDEgPSAoaW1wYWN0LCBkcm9wcGFibGVzKSA9PiB7XG4gIGNvbnN0IGlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgcmV0dXJuIGlkID8gZHJvcHBhYmxlc1tpZF0gOiBudWxsO1xufTtcbnZhciBtb3ZlSW5EaXJlY3Rpb24gPSAoe1xuICBzdGF0ZSxcbiAgdHlwZVxufSkgPT4ge1xuICBjb25zdCBpc0FjdHVhbGx5T3ZlciA9IGdldERyb3BwYWJsZU92ZXIkMShzdGF0ZS5pbXBhY3QsIHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyk7XG4gIGNvbnN0IGlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQgPSBCb29sZWFuKGlzQWN0dWFsbHlPdmVyKTtcbiAgY29uc3QgaG9tZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICBjb25zdCBpc092ZXIgPSBpc0FjdHVhbGx5T3ZlciB8fCBob21lO1xuICBjb25zdCBkaXJlY3Rpb24gPSBpc092ZXIuYXhpcy5kaXJlY3Rpb247XG4gIGNvbnN0IGlzTW92aW5nT25NYWluQXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiAodHlwZSA9PT0gJ01PVkVfVVAnIHx8IHR5cGUgPT09ICdNT1ZFX0RPV04nKSB8fCBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAodHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnKTtcbiAgaWYgKGlzTW92aW5nT25NYWluQXhpcyAmJiAhaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGlzTW92aW5nRm9yd2FyZCA9IHR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJztcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gIHJldHVybiBpc01vdmluZ09uTWFpbkF4aXMgPyBtb3ZlVG9OZXh0UGxhY2Uoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBpc092ZXIsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb246IHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSkgOiBtb3ZlQ3Jvc3NBeGlzKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICBpc092ZXIsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORyc7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJ1bihwb2ludCkge1xuICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHBvaW50LnkpICYmIGlzV2l0aGluSG9yaXpvbnRhbChwb2ludC54KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzT3ZlcmxhcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBmaXJzdC5sZWZ0IDwgc2Vjb25kLnJpZ2h0ICYmIGZpcnN0LnJpZ2h0ID4gc2Vjb25kLmxlZnQgJiYgZmlyc3QudG9wIDwgc2Vjb25kLmJvdHRvbSAmJiBmaXJzdC5ib3R0b20gPiBzZWNvbmQudG9wO1xufVxuZnVuY3Rpb24gZ2V0RnVydGhlc3RBd2F5KHtcbiAgcGFnZUJvcmRlckJveCxcbiAgZHJhZ2dhYmxlLFxuICBjYW5kaWRhdGVzXG59KSB7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IHtcbiAgICBjb25zdCBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZXNcbn0pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgY29uc3QgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICBjb25zdCBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIGNvbnN0IGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG5jb25zdCBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IChyZWN0LCBwb2ludCkgPT4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKGRyb3BwYWJsZSwgYXJlYSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBhcmVhO1xuICB9XG4gIHJldHVybiBvZmZzZXRSZWN0QnlQb3NpdGlvbihhcmVhLCBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXRJc0Rpc3BsYWNlZCh7XG4gIGRpc3BsYWNlZCxcbiAgaWRcbn0pIHtcbiAgcmV0dXJuIEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbaWRdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbaWRdKTtcbn1cblxuZnVuY3Rpb24gYXRJbmRleCh7XG4gIGRyYWdnYWJsZSxcbiAgY2xvc2VzdCxcbiAgaW5Ib21lTGlzdFxufSkge1xuICBpZiAoIWNsb3Nlc3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWluSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4O1xuICB9XG4gIGlmIChjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggPiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pbmRleCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggLSAxO1xuICB9XG4gIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG59XG52YXIgZ2V0UmVvcmRlckltcGFjdCA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbGFzdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pIHx8IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59O1xuXG5jb25zdCBjb21iaW5lVGhyZXNob2xkRGl2aXNvciA9IDQ7XG52YXIgZ2V0Q29tYmluZUltcGFjdCA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHRhcmdldFJlY3QsXG4gIHByZXZpb3VzSW1wYWN0LFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gd2l0aG91dERyYWdnaW5nLmZpbmQoY2hpbGQgPT4ge1xuICAgIGNvbnN0IGlkID0gY2hpbGQuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZC5wYWdlLmJvcmRlckJveDtcbiAgICBjb25zdCBjaGlsZFNpemUgPSBjaGlsZFJlY3RbYXhpcy5zaXplXTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBjaGlsZFNpemUgLyBjb21iaW5lVGhyZXNob2xkRGl2aXNvcjtcbiAgICBjb25zdCBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgY29uc3QgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxKSB7XG4gICAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdIC0gZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gKyBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gIH0pO1xuICBpZiAoIWNvbWJpbmVXaXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGltcGFjdDtcbn07XG5cbnZhciBnZXREcmFnSW1wYWN0ID0gKHtcbiAgcGFnZU9mZnNldCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgcGFnZUJvcmRlckJveCA9IG9mZnNldFJlY3RCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgcGFnZU9mZnNldCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uSWQgPSBnZXREcm9wcGFibGVPdmVyKHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGVzXG4gIH0pO1xuICBpZiAoIWRlc3RpbmF0aW9uSWQpIHtcbiAgICByZXR1cm4gbm9JbXBhY3Q7XG4gIH1cbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xuXG52YXIgcGF0Y2hEcm9wcGFibGVNYXAgPSAoZHJvcHBhYmxlcywgdXBkYXRlZCkgPT4gKHtcbiAgLi4uZHJvcHBhYmxlcyxcbiAgW3VwZGF0ZWQuZGVzY3JpcHRvci5pZF06IHVwZGF0ZWRcbn0pO1xuXG5jb25zdCBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gKHtcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdCxcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBjb25zdCBsYXN0ID0gd2hhdElzRHJhZ2dlZE92ZXIocHJldmlvdXNJbXBhY3QpO1xuICBjb25zdCBub3cgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBpZiAobGFzdCA9PT0gbm93KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgbGFzdERyb3BwYWJsZSA9IGRyb3BwYWJsZXNbbGFzdF07XG4gIGlmICghbGFzdERyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWQgPSByZW1vdmVQbGFjZWhvbGRlcihsYXN0RHJvcHBhYmxlKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMsIHVwZGF0ZWQpO1xufTtcbnZhciByZWNvbXB1dGVQbGFjZWhvbGRlcnMgPSAoe1xuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICBpbXBhY3Rcbn0pID0+IHtcbiAgY29uc3QgY2xlYW5lZCA9IGNsZWFyVW51c2VkUGxhY2Vob2xkZXIoe1xuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIGltcGFjdCxcbiAgICBkcm9wcGFibGVzXG4gIH0pO1xuICBjb25zdCBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWlzT3Zlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcbiAgaWYgKGlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSkge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGlmIChkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBjb25zdCBwYXRjaGVkID0gYWRkUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoY2xlYW5lZCwgcGF0Y2hlZCk7XG59O1xuXG52YXIgdXBkYXRlID0gKHtcbiAgc3RhdGUsXG4gIGNsaWVudFNlbGVjdGlvbjogZm9yY2VkQ2xpZW50U2VsZWN0aW9uLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnQsXG4gIGltcGFjdDogZm9yY2VkSW1wYWN0LFxuICBzY3JvbGxKdW1wUmVxdWVzdFxufSkgPT4ge1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGlkID0+IGRyYWdnYWJsZXNbaWRdKTtcbn1cbnZhciByZWNvbXB1dGUgPSAoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgZm9yY2VTaG91bGRBbmltYXRlXG59KSA9PiB7XG4gIGNvbnN0IGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICBjb25zdCBhZnRlckRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlcyhsYXN0LmFsbCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgbGFzdFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkXG4gIH07XG59O1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG59O1xuXG52YXIgcmVmcmVzaFNuYXAgPSAoe1xuICBzdGF0ZSxcbiAgZGltZW5zaW9uczogZm9yY2VkRGltZW5zaW9ucyxcbiAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0XG59KSA9PiB7XG4gICEoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgbmVlZHNWaXNpYmlsaXR5Q2hlY2sgPSBzdGF0ZS5pbXBhY3Q7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IGRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIobmVlZHNWaXNpYmlsaXR5Q2hlY2spO1xuICAhaXNPdmVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBvdmVyIGEgZGVzdGluYXRpb24gaW4gU05BUCBtb3ZlbWVudCBtb2RlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGNvbnN0IGltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgaW1wYWN0OiBuZWVkc1Zpc2liaWxpdHlDaGVjayxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiB1cGRhdGUoe1xuICAgIGltcGFjdCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn07XG5cbnZhciBnZXRIb21lTG9jYXRpb24gPSBkZXNjcmlwdG9yID0+ICh7XG4gIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxufSk7XG5cbnZhciBnZXRMaWZ0RWZmZWN0ID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBob21lLFxuICBkcmFnZ2FibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGhvbWUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBpbnNpZGVIb21lID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShob21lLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCByYXdJbmRleCA9IGluc2lkZUhvbWUuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAhKHJhd0luZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcmFnZ2FibGUgdG8gYmUgaW5zaWRlIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBpbnNpZGVIb21lLnNsaWNlKHJhd0luZGV4ICsgMSk7XG4gIGNvbnN0IGVmZmVjdGVkID0gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoKHByZXZpb3VzLCBpdGVtKSA9PiB7XG4gICAgcHJldmlvdXNbaXRlbS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG4gIGNvbnN0IGFmdGVyQ3JpdGljYWwgPSB7XG4gICAgaW5WaXJ0dWFsTGlzdDogaG9tZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBlZmZlY3RlZFxuICB9O1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbnVsbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IGdldEhvbWVMb2NhdGlvbihkcmFnZ2FibGUuZGVzY3JpcHRvcilcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfTtcbn07XG5cbnZhciBwYXRjaERpbWVuc2lvbk1hcCA9IChkaW1lbnNpb25zLCB1cGRhdGVkKSA9PiAoe1xuICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXM6IHBhdGNoRHJvcHBhYmxlTWFwKGRpbWVuc2lvbnMuZHJvcHBhYmxlcywgdXBkYXRlZClcbn0pO1xuXG5jb25zdCBzdGFydCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmlzaCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG9mZnNldERyYWdnYWJsZSA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgaW5pdGlhbFdpbmRvd1Njcm9sbFxufSkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBvZmZzZXQoZHJhZ2dhYmxlLmNsaWVudCwgb2Zmc2V0JDEpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIGluaXRpYWxXaW5kb3dTY3JvbGwpO1xuICBjb25zdCBtb3ZlZCA9IHtcbiAgICAuLi5kcmFnZ2FibGUsXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIC4uLmRyYWdnYWJsZS5wbGFjZWhvbGRlcixcbiAgICAgIGNsaWVudFxuICAgIH0sXG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgcmV0dXJuIG1vdmVkO1xufTtcblxudmFyIGdldEZyYW1lID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICFmcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIERyb3BwYWJsZSB0byBoYXZlIGEgZnJhbWUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gZnJhbWU7XG59O1xuXG52YXIgYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyA9ICh7XG4gIGFkZGl0aW9ucyxcbiAgdXBkYXRlZERyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENoYW5nZSA9IHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlO1xuICByZXR1cm4gYWRkaXRpb25zLm1hcChkcmFnZ2FibGUgPT4ge1xuICAgIGNvbnN0IGRyb3BwYWJsZUlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB1cGRhdGVkRHJvcHBhYmxlc1tkcm9wcGFibGVJZF07XG4gICAgY29uc3QgZnJhbWUgPSBnZXRGcmFtZShtb2RpZmllZCk7XG4gICAgY29uc3QgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWU7XG4gICAgY29uc3QgdG90YWxDaGFuZ2UgPSBhZGQod2luZG93U2Nyb2xsQ2hhbmdlLCBkcm9wcGFibGVTY3JvbGxDaGFuZ2UpO1xuICAgIGNvbnN0IG1vdmVkID0gb2Zmc2V0RHJhZ2dhYmxlKHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIG9mZnNldDogdG90YWxDaGFuZ2UsXG4gICAgICBpbml0aWFsV2luZG93U2Nyb2xsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbFxuICAgIH0pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfSk7XG59O1xuXG5jb25zdCB0aW1pbmdzS2V5ID0gJ1Byb2Nlc3NpbmcgZHluYW1pYyBjaGFuZ2VzJztcbnZhciBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCA9ICh7XG4gIHN0YXRlLFxuICBwdWJsaXNoZWRcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgd2l0aFNjcm9sbENoYW5nZSA9IHB1Ymxpc2hlZC5tb2RpZmllZC5tYXAodXBkYXRlID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1t1cGRhdGUuZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKGV4aXN0aW5nLCB1cGRhdGUuc2Nyb2xsKTtcbiAgICByZXR1cm4gc2Nyb2xsZWQ7XG4gIH0pO1xuICBjb25zdCBkcm9wcGFibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICAuLi50b0Ryb3BwYWJsZU1hcCh3aXRoU2Nyb2xsQ2hhbmdlKVxuICB9O1xuICBjb25zdCB1cGRhdGVkQWRkaXRpb25zID0gdG9EcmFnZ2FibGVNYXAoYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyh7XG4gICAgYWRkaXRpb25zOiBwdWJsaXNoZWQuYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSk7XG4gIGNvbnN0IGRyYWdnYWJsZXMgPSB7XG4gICAgLi4uc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIC4uLnVwZGF0ZWRBZGRpdGlvbnNcbiAgfTtcbiAgcHVibGlzaGVkLnJlbW92YWxzLmZvckVhY2goaWQgPT4ge1xuICAgIGRlbGV0ZSBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJvcHBhYmxlcyxcbiAgICBkcmFnZ2FibGVzXG4gIH07XG4gIGNvbnN0IHdhc092ZXJJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gIGNvbnN0IHdhc092ZXIgPSB3YXNPdmVySWQgPyBkaW1lbnNpb25zLmRyb3BwYWJsZXNbd2FzT3ZlcklkXSA6IG51bGw7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaG9tZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KTtcbiAgY29uc3QgcHJldmlvdXNJbXBhY3QgPSB3YXNPdmVyICYmIHdhc092ZXIuaXNDb21iaW5lRW5hYmxlZCA/IHN0YXRlLmltcGFjdCA6IG9uTGlmdEltcGFjdDtcbiAgY29uc3QgaW1wYWN0ID0gZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogc3RhdGUuY3VycmVudC5wYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGZpbmlzaCh0aW1pbmdzS2V5KTtcbiAgY29uc3QgZHJhZ2dpbmdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICBpbXBhY3QsXG4gICAgb25MaWZ0SW1wYWN0LFxuICAgIGRpbWVuc2lvbnMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH07XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU3RhdGU7XG4gIH1cbiAgY29uc3QgZHJvcFBlbmRpbmcgPSB7XG4gICAgLi4uZHJhZ2dpbmdTdGF0ZSxcbiAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgcmVhc29uOiBzdGF0ZS5yZWFzb24sXG4gICAgaXNXYWl0aW5nOiBmYWxzZVxuICB9O1xuICByZXR1cm4gZHJvcFBlbmRpbmc7XG59O1xuXG5jb25zdCBpc1NuYXBwaW5nID0gc3RhdGUgPT4gc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCc7XG5jb25zdCBwb3N0RHJvcHBhYmxlQ2hhbmdlID0gKHN0YXRlLCB1cGRhdGVkLCBpc0VuYWJsZWRDaGFuZ2luZykgPT4ge1xuICBjb25zdCBkaW1lbnNpb25zID0gcGF0Y2hEaW1lbnNpb25NYXAoc3RhdGUuZGltZW5zaW9ucywgdXBkYXRlZCk7XG4gIGlmICghaXNTbmFwcGluZyhzdGF0ZSkgfHwgaXNFbmFibGVkQ2hhbmdpbmcpIHtcbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgZGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9uc1xuICB9KTtcbn07XG5mdW5jdGlvbiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSkge1xuICBpZiAoc3RhdGUuaXNEcmFnZ2luZyAmJiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBpZGxlJDIgPSB7XG4gIHBoYXNlOiAnSURMRScsXG4gIGNvbXBsZXRlZDogbnVsbCxcbiAgc2hvdWxkRmx1c2g6IGZhbHNlXG59O1xudmFyIHJlZHVjZXIgPSAoc3RhdGUgPSBpZGxlJDIsIGFjdGlvbikgPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaWRsZSQyLFxuICAgICAgc2hvdWxkRmx1c2g6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSU5JVElBTF9QVUJMSVNIIG11c3QgY29tZSBhZnRlciBhIElETEUgcGhhc2UnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgbW92ZW1lbnRNb2RlXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICAgIGNvbnN0IGhvbWUgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXNbY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgICBjb25zdCBjbGllbnQgPSB7XG4gICAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGJvcmRlckJveENlbnRlcjogZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLFxuICAgICAgb2Zmc2V0OiBvcmlnaW5cbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICBjbGllbnQsXG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNlbGVjdGlvbjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBvZmZzZXQ6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzV2luZG93U2Nyb2xsQWxsb3dlZCA9IHRvRHJvcHBhYmxlTGlzdChkaW1lbnNpb25zLmRyb3BwYWJsZXMpLmV2ZXJ5KGl0ZW0gPT4gIWl0ZW0uaXNGaXhlZE9uUGFnZSk7XG4gICAgY29uc3Qge1xuICAgICAgaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbFxuICAgIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGhvbWUsXG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgbW92ZW1lbnRNb2RlLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIGluaXRpYWwsXG4gICAgICBjdXJyZW50OiBpbml0aWFsLFxuICAgICAgaXNXaW5kb3dTY3JvbGxBbGxvd2VkLFxuICAgICAgaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCxcbiAgICAgIG9uTGlmdEltcGFjdDogaW1wYWN0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdDT0xMRUNUSU9OX1NUQVJUSU5HJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IGZyb20gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5leHBlY3RlZCAke2FjdGlvbi50eXBlfSByZWNlaXZlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcHVibGlzaGVkOiBhY3Rpb24ucGF5bG9hZFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkUnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgY2xpZW50OiBjbGllbnRTZWxlY3Rpb25cbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgaWYgKGlzRXF1YWwkMShjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdDogaXNTbmFwcGluZyhzdGF0ZSkgPyBzdGF0ZS5pbXBhY3QgOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKHRhcmdldCwgbmV3U2Nyb2xsKTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgc2Nyb2xsZWQsIGZhbHNlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICEodGFyZ2V0LmlzRW5hYmxlZCAhPT0gaXNFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzRW5hYmxlZCB0byAke1N0cmluZyhpc0VuYWJsZWQpfVxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgJHtTdHJpbmcodGFyZ2V0LmlzRW5hYmxlZCl9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICAhdGFyZ2V0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiAke2lkfV0gdG8gdG9nZ2xlIGl0cyBpc0NvbWJpbmVFbmFibGVkIHN0YXRlYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAhKHRhcmdldC5pc0NvbWJpbmVFbmFibGVkICE9PSBpc0NvbWJpbmVFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzQ29tYmluZUVuYWJsZWQgdG8gJHtTdHJpbmcoaXNDb21iaW5lRW5hYmxlZCl9XG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSAke1N0cmluZyh0YXJnZXQuaXNDb21iaW5lRW5hYmxlZCl9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfQllfV0lORE9XX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbW92ZSBieSB3aW5kb3cgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICFzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdXaW5kb3cgc2Nyb2xsaW5nIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciBmaXhlZCBsaXN0cycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubmV3U2Nyb2xsO1xuICAgIGlmIChpc0VxdWFsJDEoc3RhdGUudmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIG5ld1Njcm9sbCkpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQoc3RhdGUudmlld3BvcnQsIG5ld1Njcm9sbCk7XG4gICAgaWYgKGlzU25hcHBpbmcoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcpIHtcbiAgICBpZiAoIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBtYXhTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5tYXhTY3JvbGw7XG4gICAgaWYgKGlzRXF1YWwkMShtYXhTY3JvbGwsIHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5tYXgpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhNYXhTY3JvbGwgPSB7XG4gICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgIHNjcm9sbDoge1xuICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5zY3JvbGwsXG4gICAgICAgIG1heDogbWF4U2Nyb2xsXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICB2aWV3cG9ydDogd2l0aE1heFNjcm9sbFxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9VUCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9MRUZUJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfUklHSFQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gcmVjZWl2ZWQgd2hpbGUgbm90IGluIERSQUdHSU5HIHBoYXNlYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSBtb3ZlSW5EaXJlY3Rpb24oe1xuICAgICAgc3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgIH0pO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBpbXBhY3Q6IHJlc3VsdC5pbXBhY3QsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IHJlc3VsdC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogcmVzdWx0LnNjcm9sbEp1bXBSZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgbW92ZSBpbnRvIHRoZSBEUk9QX1BFTkRJTkcgcGhhc2UgZnJvbSB0aGUgQ09MTEVDVElORyBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICAgIGlzV2FpdGluZzogdHJ1ZSxcbiAgICAgIHJlYXNvblxuICAgIH07XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0XG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBhbmltYXRlIGRyb3AgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUk9QX0FOSU1BVElORycsXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgZGltZW5zaW9uczogc3RhdGUuZGltZW5zaW9uc1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICByZXR1cm4ge1xuICAgICAgcGhhc2U6ICdJRExFJyxcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIHNob3VsZEZsdXNoOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuZnVuY3Rpb24gZ3VhcmQoYWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGFjdGlvbiBpbnN0YW5jZW9mIE9iamVjdCAmJiAndHlwZScgaW4gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBwcmVkaWNhdGU7XG59XG5jb25zdCBiZWZvcmVJbml0aWFsQ2FwdHVyZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGxpZnQkMSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0xJRlQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGluaXRpYWxQdWJsaXNoID0gYXJncyA9PiAoe1xuICB0eXBlOiAnSU5JVElBTF9QVUJMSVNIJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBwdWJsaXNoV2hpbGVEcmFnZ2luZyA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbGxlY3Rpb25TdGFydGluZyA9ICgpID0+ICh7XG4gIHR5cGU6ICdDT0xMRUNUSU9OX1NUQVJUSU5HJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlQnlXaW5kb3dTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVVcCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1VQJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlRG93biA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0RPV04nLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVSaWdodCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1JJR0hUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlTGVmdCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0xFRlQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGZsdXNoID0gKCkgPT4gKHtcbiAgdHlwZTogJ0ZMVVNIJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBhbmltYXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQU5JTUFURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29tcGxldGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9DT01QTEVURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1AnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BQZW5kaW5nID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9QRU5ESU5HJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wQW5pbWF0aW9uRmluaXNoZWQgPSAoKSA9PiAoe1xuICB0eXBlOiAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcblxuZnVuY3Rpb24gY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKSB7XG4gIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbmRleGVzID0gaW5zaWRlRGVzdGluYXRpb24ubWFwKGQgPT4gZC5kZXNjcmlwdG9yLmluZGV4KTtcbiAgY29uc3QgZXJyb3JzID0ge307XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBpbmRleGVzW2ldO1xuICAgIGNvbnN0IHByZXZpb3VzID0gaW5kZXhlc1tpIC0gMV07XG4gICAgaWYgKGN1cnJlbnQgIT09IHByZXZpb3VzICsgMSkge1xuICAgICAgZXJyb3JzW2N1cnJlbnRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZWQgPSBpbmRleGVzLm1hcChpbmRleCA9PiB7XG4gICAgY29uc3QgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yc1tpbmRleF0pO1xuICAgIHJldHVybiBoYXNFcnJvciA/IGBb8J+UpSR7aW5kZXh9XWAgOiBgJHtpbmRleH1gO1xuICB9KS5qb2luKCcsICcpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEZXRlY3RlZCBub24tY29uc2VjdXRpdmUgPERyYWdnYWJsZSAvPiBpbmRleGVzLlxuXG4gICAgKFRoaXMgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYnVncylcblxuICAgICR7Zm9ybWF0dGVkfVxuICBgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShjcml0aWNhbC5kcm9wcGFibGUuaWQsIGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyk7XG4gICAgY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG52YXIgbGlmdCA9IG1hcnNoYWwgPT4gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnTElGVCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIG1vdmVtZW50TW9kZVxuICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IGluaXRpYWwgPSBnZXRTdGF0ZSgpO1xuICBpZiAoaW5pdGlhbC5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWQ6IGluaXRpYWwuY29tcGxldGVkXG4gICAgfSkpO1xuICB9XG4gICEoZ2V0U3RhdGUoKS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UgdG8gc3RhcnQgYSBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgZGlzcGF0Y2goZmx1c2goKSk7XG4gIGRpc3BhdGNoKGJlZm9yZUluaXRpYWxDYXB0dXJlKHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgbW92ZW1lbnRNb2RlXG4gIH0pKTtcbiAgY29uc3Qgc2Nyb2xsT3B0aW9ucyA9IHtcbiAgICBzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHk6IG1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnXG4gIH07XG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgIHNjcm9sbE9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGNyaXRpY2FsLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnRcbiAgfSA9IG1hcnNoYWwuc3RhcnRQdWJsaXNoaW5nKHJlcXVlc3QpO1xuICB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpO1xuICBkaXNwYXRjaChpbml0aWFsUHVibGlzaCh7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgbW92ZW1lbnRNb2RlLFxuICAgIHZpZXdwb3J0XG4gIH0pKTtcbn07XG5cbnZhciBzdHlsZSA9IG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICBtYXJzaGFsLmRyYWdnaW5nKCk7XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgbWFyc2hhbC5kcm9wcGluZyhhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbik7XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpKSB7XG4gICAgbWFyc2hhbC5yZXN0aW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufTtcblxuY29uc3QgY3VydmVzID0ge1xuICBvdXRPZlRoZVdheTogJ2N1YmljLWJlemllcigwLjIsIDAsIDAsIDEpJyxcbiAgZHJvcDogJ2N1YmljLWJlemllciguMiwxLC4xLDEpJ1xufTtcbmNvbnN0IGNvbWJpbmUgPSB7XG4gIG9wYWNpdHk6IHtcbiAgICBkcm9wOiAwLFxuICAgIGNvbWJpbmluZzogMC43XG4gIH0sXG4gIHNjYWxlOiB7XG4gICAgZHJvcDogMC43NVxuICB9XG59O1xuY29uc3QgdGltaW5ncyA9IHtcbiAgb3V0T2ZUaGVXYXk6IDAuMixcbiAgbWluRHJvcFRpbWU6IDAuMzMsXG4gIG1heERyb3BUaW1lOiAwLjU1XG59O1xuY29uc3Qgb3V0T2ZUaGVXYXlUaW1pbmcgPSBgJHt0aW1pbmdzLm91dE9mVGhlV2F5fXMgJHtjdXJ2ZXMub3V0T2ZUaGVXYXl9YDtcbmNvbnN0IHRyYW5zaXRpb25zID0ge1xuICBmbHVpZDogYG9wYWNpdHkgJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBzbmFwOiBgdHJhbnNmb3JtICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgZHJvcDogZHVyYXRpb24gPT4ge1xuICAgIGNvbnN0IHRpbWluZyA9IGAke2R1cmF0aW9ufXMgJHtjdXJ2ZXMuZHJvcH1gO1xuICAgIHJldHVybiBgdHJhbnNmb3JtICR7dGltaW5nfSwgb3BhY2l0eSAke3RpbWluZ31gO1xuICB9LFxuICBvdXRPZlRoZVdheTogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIHBsYWNlaG9sZGVyOiBgaGVpZ2h0ICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCB3aWR0aCAke291dE9mVGhlV2F5VGltaW5nfSwgbWFyZ2luICR7b3V0T2ZUaGVXYXlUaW1pbmd9YFxufTtcbmNvbnN0IG1vdmVUbyA9IG9mZnNldCA9PiBpc0VxdWFsJDEob2Zmc2V0LCBvcmlnaW4pID8gdW5kZWZpbmVkIDogYHRyYW5zbGF0ZSgke29mZnNldC54fXB4LCAke29mZnNldC55fXB4KWA7XG5jb25zdCB0cmFuc2Zvcm1zID0ge1xuICBtb3ZlVG8sXG4gIGRyb3A6IChvZmZzZXQsIGlzQ29tYmluaW5nKSA9PiB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gbW92ZVRvKG9mZnNldCk7XG4gICAgaWYgKCF0cmFuc2xhdGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2xhdGV9IHNjYWxlKCR7Y29tYmluZS5zY2FsZS5kcm9wfSlgO1xuICB9XG59O1xuXG5jb25zdCB7XG4gIG1pbkRyb3BUaW1lLFxuICBtYXhEcm9wVGltZVxufSA9IHRpbWluZ3M7XG5jb25zdCBkcm9wVGltZVJhbmdlID0gbWF4RHJvcFRpbWUgLSBtaW5Ecm9wVGltZTtcbmNvbnN0IG1heERyb3BUaW1lQXREaXN0YW5jZSA9IDE1MDA7XG5jb25zdCBjYW5jZWxEcm9wTW9kaWZpZXIgPSAwLjY7XG52YXIgZ2V0RHJvcER1cmF0aW9uID0gKHtcbiAgY3VycmVudCxcbiAgZGVzdGluYXRpb24sXG4gIHJlYXNvblxufSkgPT4ge1xuICBjb25zdCBkaXN0YW5jZSQxID0gZGlzdGFuY2UoY3VycmVudCwgZGVzdGluYXRpb24pO1xuICBpZiAoZGlzdGFuY2UkMSA8PSAwKSB7XG4gICAgcmV0dXJuIG1pbkRyb3BUaW1lO1xuICB9XG4gIGlmIChkaXN0YW5jZSQxID49IG1heERyb3BUaW1lQXREaXN0YW5jZSkge1xuICAgIHJldHVybiBtYXhEcm9wVGltZTtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlID0gZGlzdGFuY2UkMSAvIG1heERyb3BUaW1lQXREaXN0YW5jZTtcbiAgY29uc3QgZHVyYXRpb24gPSBtaW5Ecm9wVGltZSArIGRyb3BUaW1lUmFuZ2UgKiBwZXJjZW50YWdlO1xuICBjb25zdCB3aXRoRHVyYXRpb24gPSByZWFzb24gPT09ICdDQU5DRUwnID8gZHVyYXRpb24gKiBjYW5jZWxEcm9wTW9kaWZpZXIgOiBkdXJhdGlvbjtcbiAgcmV0dXJuIE51bWJlcih3aXRoRHVyYXRpb24udG9GaXhlZCgyKSk7XG59O1xuXG52YXIgZ2V0TmV3SG9tZUNsaWVudE9mZnNldCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkaW1lbnNpb25zLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcm9wcGFibGVJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlSWQgPyBkcm9wcGFibGVzW2Ryb3BwYWJsZUlkXSA6IG51bGw7XG4gIGNvbnN0IGhvbWUgPSBkcm9wcGFibGVzW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXTtcbiAgY29uc3QgbmV3Q2xpZW50Q2VudGVyID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uIHx8IGhvbWUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KG5ld0NsaWVudENlbnRlciwgZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbnZhciBnZXREcm9wSW1wYWN0ID0gKHtcbiAgZHJhZ2dhYmxlcyxcbiAgcmVhc29uLFxuICBsYXN0SW1wYWN0LFxuICBob21lLFxuICB2aWV3cG9ydCxcbiAgb25MaWZ0SW1wYWN0XG59KSA9PiB7XG4gIGlmICghbGFzdEltcGFjdC5hdCB8fCByZWFzb24gIT09ICdEUk9QJykge1xuICAgIGNvbnN0IHJlY29tcHV0ZWRIb21lSW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiByZWNvbXB1dGVkSG9tZUltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBpZiAobGFzdEltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiBsYXN0SW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgd2l0aG91dE1vdmVtZW50ID0ge1xuICAgIC4uLmxhc3RJbXBhY3QsXG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3Vwc1xuICB9O1xuICByZXR1cm4ge1xuICAgIGltcGFjdDogd2l0aG91dE1vdmVtZW50LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgfTtcbn07XG5cbmNvbnN0IGRyb3BNaWRkbGV3YXJlID0gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICBkaXNwYXRjaChkcm9wUGVuZGluZyh7XG4gICAgICByZWFzb25cbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlzV2FpdGluZ0ZvckRyb3AgPSBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgJiYgc3RhdGUuaXNXYWl0aW5nO1xuICAhIWlzV2FpdGluZ0ZvckRyb3AgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERST1AgYWN0aW9uIG9jY3VycmVkIHdoaWxlIERST1BfUEVORElORyBhbmQgc3RpbGwgd2FpdGluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBkcm9wIGluIHBoYXNlOiAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3Qge1xuICAgIGltcGFjdCxcbiAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlXG4gIH0gPSBnZXREcm9wSW1wYWN0KHtcbiAgICByZWFzb24sXG4gICAgbGFzdEltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgb25MaWZ0SW1wYWN0OiBzdGF0ZS5vbkxpZnRJbXBhY3QsXG4gICAgaG9tZTogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF0sXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGRyYWdnYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1xuICB9KTtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSA6IG51bGw7XG4gIGNvbnN0IGNvbWJpbmUgPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0Q29tYmluZShpbXBhY3QpIDogbnVsbDtcbiAgY29uc3Qgc291cmNlID0ge1xuICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXgsXG4gICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZFxuICB9O1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlLFxuICAgIHJlYXNvbixcbiAgICBtb2RlOiBzdGF0ZS5tb3ZlbWVudE1vZGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgY29tYmluZVxuICB9O1xuICBjb25zdCBuZXdIb21lQ2xpZW50T2Zmc2V0ID0gZ2V0TmV3SG9tZUNsaWVudE9mZnNldCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBjb21wbGV0ZWQgPSB7XG4gICAgY3JpdGljYWw6IHN0YXRlLmNyaXRpY2FsLFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgcmVzdWx0LFxuICAgIGltcGFjdFxuICB9O1xuICBjb25zdCBpc0FuaW1hdGlvblJlcXVpcmVkID0gIWlzRXF1YWwkMShzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsIG5ld0hvbWVDbGllbnRPZmZzZXQpIHx8IEJvb2xlYW4ocmVzdWx0LmNvbWJpbmUpO1xuICBpZiAoIWlzQW5pbWF0aW9uUmVxdWlyZWQpIHtcbiAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgY29tcGxldGVkXG4gICAgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkcm9wRHVyYXRpb24gPSBnZXREcm9wRHVyYXRpb24oe1xuICAgIGN1cnJlbnQ6IHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCxcbiAgICBkZXN0aW5hdGlvbjogbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICByZWFzb25cbiAgfSk7XG4gIGNvbnN0IGFyZ3MgPSB7XG4gICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICBkcm9wRHVyYXRpb24sXG4gICAgY29tcGxldGVkXG4gIH07XG4gIGRpc3BhdGNoKGFuaW1hdGVEcm9wKGFyZ3MpKTtcbn07XG5cbnZhciBnZXRXaW5kb3dTY3JvbGwgPSAoKSA9PiAoe1xuICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJpbmRpbmcodXBkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cgJiYgZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICBvbldpbmRvd1Njcm9sbFxufSkge1xuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoKSB7XG4gICAgb25XaW5kb3dTY3JvbGwoZ2V0V2luZG93U2Nyb2xsKCkpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlZCA9IHJhZlNjaGQodXBkYXRlU2Nyb2xsKTtcbiAgY29uc3QgYmluZGluZyA9IGdldFdpbmRvd1Njcm9sbEJpbmRpbmcoc2NoZWR1bGVkKTtcbiAgbGV0IHVuYmluZCA9IG5vb3AkMjtcbiAgZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHVuYmluZCAhPT0gbm9vcCQyO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICEhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBhbHJlYWR5IGFjdGl2ZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIHNjcm9sbCBsaXN0ZW5lciB3aGVuIG5vdCBhY3RpdmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHNjaGVkdWxlZC5jYW5jZWwoKTtcbiAgICB1bmJpbmQoKTtcbiAgICB1bmJpbmQgPSBub29wJDI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGlzQWN0aXZlXG4gIH07XG59XG5cbmNvbnN0IHNob3VsZFN0b3AkMSA9IGFjdGlvbiA9PiBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKTtcbmNvbnN0IHNjcm9sbExpc3RlbmVyID0gc3RvcmUgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IGdldFNjcm9sbExpc3RlbmVyKHtcbiAgICBvbldpbmRvd1Njcm9sbDogbmV3U2Nyb2xsID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKG1vdmVCeVdpbmRvd1Njcm9sbCh7XG4gICAgICAgIG5ld1Njcm9sbFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKCFsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgICBsaXN0ZW5lci5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBzaG91bGRTdG9wJDEoYWN0aW9uKSkge1xuICAgICAgbGlzdGVuZXIuc3RvcCgpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gIH07XG59O1xuXG52YXIgZ2V0RXhwaXJpbmdBbm5vdW5jZSA9IGFubm91bmNlID0+IHtcbiAgbGV0IHdhc0NhbGxlZCA9IGZhbHNlO1xuICBsZXQgaXNFeHBpcmVkID0gZmFsc2U7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlzRXhwaXJlZCA9IHRydWU7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdBbm5vdW5jZW1lbnQgYWxyZWFkeSBtYWRlLiBOb3QgbWFraW5nIGEgc2Vjb25kIGFubm91bmNlbWVudCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW5ub3VuY2VtZW50cyBjYW5ub3QgYmUgbWFkZSBhc3luY2hyb25vdXNseS5cbiAgICAgICAgRGVmYXVsdCBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gYW5ub3VuY2VkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhc0NhbGxlZCA9IHRydWU7XG4gICAgYW5ub3VuY2UobWVzc2FnZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG4gIHJlc3VsdC53YXNDYWxsZWQgPSAoKSA9PiB3YXNDYWxsZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0QXN5bmNNYXJzaGFsID0gKCkgPT4ge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGNvbnN0IGV4ZWN1dGUgPSB0aW1lcklkID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGVudHJpZXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50aW1lcklkID09PSB0aW1lcklkKTtcbiAgICAhKGluZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCB0aW1lcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgW2VudHJ5XSA9IGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBlbnRyeS5jYWxsYmFjaygpO1xuICB9O1xuICBjb25zdCBhZGQgPSBmbiA9PiB7XG4gICAgY29uc3QgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4gZXhlY3V0ZSh0aW1lcklkKSk7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICB0aW1lcklkLFxuICAgICAgY2FsbGJhY2s6IGZuXG4gICAgfTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNoYWxsb3cgPSBbLi4uZW50cmllc107XG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHNoYWxsb3cuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGltZXJJZCk7XG4gICAgICBlbnRyeS5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBmbHVzaFxuICB9O1xufTtcblxuY29uc3QgYXJlTG9jYXRpb25zRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkICYmIGZpcnN0LmluZGV4ID09PSBzZWNvbmQuaW5kZXg7XG59O1xuY29uc3QgaXNDb21iaW5lRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmaXJzdC5kcmFnZ2FibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZUlkICYmIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQ7XG59O1xuY29uc3QgaXNDcml0aWNhbEVxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0RyYWdnYWJsZUVxdWFsID0gZmlyc3QuZHJhZ2dhYmxlLmlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmlkICYmIGZpcnN0LmRyYWdnYWJsZS5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5kcm9wcGFibGVJZCAmJiBmaXJzdC5kcmFnZ2FibGUudHlwZSA9PT0gc2Vjb25kLmRyYWdnYWJsZS50eXBlICYmIGZpcnN0LmRyYWdnYWJsZS5pbmRleCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pbmRleDtcbiAgY29uc3QgaXNEcm9wcGFibGVFcXVhbCA9IGZpcnN0LmRyb3BwYWJsZS5pZCA9PT0gc2Vjb25kLmRyb3BwYWJsZS5pZCAmJiBmaXJzdC5kcm9wcGFibGUudHlwZSA9PT0gc2Vjb25kLmRyb3BwYWJsZS50eXBlO1xuICByZXR1cm4gaXNEcmFnZ2FibGVFcXVhbCAmJiBpc0Ryb3BwYWJsZUVxdWFsO1xufTtcblxuY29uc3Qgd2l0aFRpbWluZ3MgPSAoa2V5LCBmbikgPT4ge1xuICBzdGFydCgpO1xuICBmbigpO1xuICBmaW5pc2goKTtcbn07XG5jb25zdCBnZXREcmFnU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+ICh7XG4gIGRyYWdnYWJsZUlkOiBjcml0aWNhbC5kcmFnZ2FibGUuaWQsXG4gIHR5cGU6IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlLFxuICBzb3VyY2U6IHtcbiAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkLFxuICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXhcbiAgfSxcbiAgbW9kZVxufSk7XG5mdW5jdGlvbiBleGVjdXRlKHJlc3BvbmRlciwgZGF0YSwgYW5ub3VuY2UsIGdldERlZmF1bHRNZXNzYWdlKSB7XG4gIGlmICghcmVzcG9uZGVyKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWxsRXhwaXJlID0gZ2V0RXhwaXJpbmdBbm5vdW5jZShhbm5vdW5jZSk7XG4gIGNvbnN0IHByb3ZpZGVkID0ge1xuICAgIGFubm91bmNlOiB3aWxsRXhwaXJlXG4gIH07XG4gIHJlc3BvbmRlcihkYXRhLCBwcm92aWRlZCk7XG4gIGlmICghd2lsbEV4cGlyZS53YXNDYWxsZWQoKSkge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgfVxufVxudmFyIGdldFB1Ymxpc2hlciA9IChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBhc3luY01hcnNoYWwgPSBnZXRBc3luY01hcnNoYWwoKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgYmVmb3JlQ2FwdHVyZSA9IChkcmFnZ2FibGVJZCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZUNhcHR1cmUgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVDYXB0dXJlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVDYXB0dXJlO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHtcbiAgICAgICAgICBkcmFnZ2FibGVJZCxcbiAgICAgICAgICBtb2RlXG4gICAgICAgIH07XG4gICAgICAgIGZuKGJlZm9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGJlZm9yZVN0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlRHJhZ1N0YXJ0JywgKCkgPT4ge1xuICAgICAgY29uc3QgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVEcmFnU3RhcnQ7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZGF0YSA9IGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFzdENyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIGxhc3RMb2NhdGlvbjogZGF0YS5zb3VyY2UsXG4gICAgICBsYXN0Q29tYmluZTogbnVsbFxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnU3RhcnQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdTdGFydCwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdTdGFydCkpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGUgPSAoY3JpdGljYWwsIGltcGFjdCkgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KTtcbiAgICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ01vdmUgd2hlbiBvbkRyYWdTdGFydCBoYXMgbm90IGJlZW4gY2FsbGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNDcml0aWNhbENoYW5nZWQgPSAhaXNDcml0aWNhbEVxdWFsKGNyaXRpY2FsLCBkcmFnZ2luZy5sYXN0Q3JpdGljYWwpO1xuICAgIGlmIChoYXNDcml0aWNhbENoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDcml0aWNhbCA9IGNyaXRpY2FsO1xuICAgIH1cbiAgICBjb25zdCBoYXNMb2NhdGlvbkNoYW5nZWQgPSAhYXJlTG9jYXRpb25zRXF1YWwoZHJhZ2dpbmcubGFzdExvY2F0aW9uLCBsb2NhdGlvbik7XG4gICAgaWYgKGhhc0xvY2F0aW9uQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGhhc0dyb3VwaW5nQ2hhbmdlZCA9ICFpc0NvbWJpbmVFcXVhbChkcmFnZ2luZy5sYXN0Q29tYmluZSwgY29tYmluZSk7XG4gICAgaWYgKGhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cbiAgICBpZiAoIWhhc0NyaXRpY2FsQ2hhbmdlZCAmJiAhaGFzTG9jYXRpb25DaGFuZ2VkICYmICFoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChjcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksXG4gICAgICBjb21iaW5lLFxuICAgICAgZGVzdGluYXRpb246IGxvY2F0aW9uXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdVcGRhdGUnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdVcGRhdGUsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQub25EcmFnVXBkYXRlKSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IGZsdXNoIHJlc3BvbmRlcnMgd2hpbGUgZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGFzeW5jTWFyc2hhbC5mbHVzaCgpO1xuICB9O1xuICBjb25zdCBkcm9wID0gcmVzdWx0ID0+IHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdFbmQgd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBvbkRyYWdTdGFydCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdFbmQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdFbmQsIHJlc3VsdCwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdFbmQpKTtcbiAgfTtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoZHJhZ2dpbmcubGFzdENyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmU6IG51bGwsXG4gICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgIHJlYXNvbjogJ0NBTkNFTCdcbiAgICB9O1xuICAgIGRyb3AocmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVDYXB0dXJlLFxuICAgIGJlZm9yZVN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIHVwZGF0ZSxcbiAgICBmbHVzaCxcbiAgICBkcm9wLFxuICAgIGFib3J0XG4gIH07XG59O1xuXG52YXIgcmVzcG9uZGVycyA9IChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBwdWJsaXNoZXIgPSBnZXRQdWJsaXNoZXIoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpO1xuICByZXR1cm4gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChndWFyZChhY3Rpb24sICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJykpIHtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVDYXB0dXJlKGFjdGlvbi5wYXlsb2FkLmRyYWdnYWJsZUlkLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gYWN0aW9uLnBheWxvYWQuY3JpdGljYWw7XG4gICAgICBwdWJsaXNoZXIuYmVmb3JlU3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBwdWJsaXNoZXIuc3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBwdWJsaXNoZXIuZmx1c2goKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIHB1Ymxpc2hlci5kcm9wKHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSkge1xuICAgICAgcHVibGlzaGVyLmFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHB1Ymxpc2hlci51cGRhdGUoc3RhdGUuY3JpdGljYWwsIHN0YXRlLmltcGFjdCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZpbmlzaE1pZGRsZXdhcmUgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSkge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAhKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5pc2ggYSBkcm9wIGFuaW1hdGluZyB3aGVuIG5vIGRyb3AgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgc3RvcmUuZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICBjb21wbGV0ZWQ6IHN0YXRlLmNvbXBsZXRlZFxuICB9KSk7XG59O1xuXG5jb25zdCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUgPSBzdG9yZSA9PiB7XG4gIGxldCB1bmJpbmQgPSBudWxsO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodW5iaW5kKSB7XG4gICAgICB1bmJpbmQoKTtcbiAgICAgIHVuYmluZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykpIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoIWd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbHVzaERyb3BBbmltYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcEFuaW1hdGlvbkZpbmlzaGVkKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gICAgfSk7XG4gIH07XG59O1xuXG52YXIgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIgPSBtYXJzaGFsID0+ICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdGTFVTSCcpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgbWFyc2hhbC5zdG9wUHVibGlzaGluZygpO1xuICB9XG4gIG5leHQoYWN0aW9uKTtcbn07XG5cbnZhciBmb2N1cyA9IG1hcnNoYWwgPT4ge1xuICBsZXQgaXNXYXRjaGluZyA9IGZhbHNlO1xuICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IHRydWU7XG4gICAgICBtYXJzaGFsLnRyeVJlY29yZEZvY3VzKGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoIWlzV2F0Y2hpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGlmIChyZXN1bHQuY29tYmluZSkge1xuICAgICAgICBtYXJzaGFsLnRyeVNoaWZ0UmVjb3JkKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQpO1xuICAgICAgfVxuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IHNob3VsZFN0b3AgPSBhY3Rpb24gPT4gZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJyk7XG52YXIgYXV0b1Njcm9sbCA9IGF1dG9TY3JvbGxlciA9PiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChzaG91bGRTdG9wKGFjdGlvbikpIHtcbiAgICBhdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHBoYXNlIHRvIGJlIERSQUdHSU5HIGFmdGVyIElOSVRJQUxfUFVCTElTSCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgYXV0b1Njcm9sbGVyLnN0YXJ0KHN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xuICBhdXRvU2Nyb2xsZXIuc2Nyb2xsKHN0b3JlLmdldFN0YXRlKCkpO1xufTtcblxuY29uc3QgcGVuZGluZ0Ryb3AgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIG5leHQoYWN0aW9uKTtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcG9zdEFjdGlvblN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5waGFzZSAhPT0gJ0RST1BfUEVORElORycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5pc1dhaXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcmUuZGlzcGF0Y2goZHJvcCh7XG4gICAgcmVhc29uOiBwb3N0QWN0aW9uU3RhdGUucmVhc29uXG4gIH0pKTtcbn07XG5cbmNvbnN0IGNvbXBvc2VFbmhhbmNlcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fKHtcbiAgbmFtZTogJ0BoZWxsby1wYW5nZWEvZG5kJ1xufSkgOiBjb21wb3NlO1xudmFyIGNyZWF0ZVN0b3JlID0gKHtcbiAgZGltZW5zaW9uTWFyc2hhbCxcbiAgZm9jdXNNYXJzaGFsLFxuICBzdHlsZU1hcnNoYWwsXG4gIGdldFJlc3BvbmRlcnMsXG4gIGFubm91bmNlLFxuICBhdXRvU2Nyb2xsZXJcbn0pID0+IGNyZWF0ZVN0b3JlJDEocmVkdWNlciwgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoc3R5bGUoc3R5bGVNYXJzaGFsKSwgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIoZGltZW5zaW9uTWFyc2hhbCksIGxpZnQoZGltZW5zaW9uTWFyc2hhbCksIGRyb3BNaWRkbGV3YXJlLCBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSwgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlLCBwZW5kaW5nRHJvcCwgYXV0b1Njcm9sbChhdXRvU2Nyb2xsZXIpLCBzY3JvbGxMaXN0ZW5lciwgZm9jdXMoZm9jdXNNYXJzaGFsKSwgcmVzcG9uZGVycyhnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkpKSk7XG5cbmNvbnN0IGNsZWFuJDEgPSAoKSA9PiAoe1xuICBhZGRpdGlvbnM6IHt9LFxuICByZW1vdmFsczoge30sXG4gIG1vZGlmaWVkOiB7fVxufSk7XG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoZXIoe1xuICByZWdpc3RyeSxcbiAgY2FsbGJhY2tzXG59KSB7XG4gIGxldCBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGNvbnN0IGNvbGxlY3QgPSAoKSA9PiB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZygpO1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICBzdGFydCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZGRpdGlvbnMsXG4gICAgICAgIHJlbW92YWxzLFxuICAgICAgICBtb2RpZmllZFxuICAgICAgfSA9IHN0YWdpbmc7XG4gICAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGlkID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGlkKS5nZXREaW1lbnNpb24ob3JpZ2luKSkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhtb2RpZmllZCkubWFwKGlkID0+IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5yZW1vdmFsc1tpZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLnJlbW92YWxzW2lkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgc3RhZ2luZy5yZW1vdmFsc1tkZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgZnJhbWVJZCA9IG51bGw7XG4gICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgcmVtb3ZlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxudmFyIGdldE1heFNjcm9sbCA9ICh7XG4gIHNjcm9sbEhlaWdodCxcbiAgc2Nyb2xsV2lkdGgsXG4gIGhlaWdodCxcbiAgd2lkdGhcbn0pID0+IHtcbiAgY29uc3QgbWF4U2Nyb2xsID0gc3VidHJhY3Qoe1xuICAgIHg6IHNjcm9sbFdpZHRoLFxuICAgIHk6IHNjcm9sbEhlaWdodFxuICB9LCB7XG4gICAgeDogd2lkdGgsXG4gICAgeTogaGVpZ2h0XG4gIH0pO1xuICBjb25zdCBhZGp1c3RlZE1heFNjcm9sbCA9IHtcbiAgICB4OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueCksXG4gICAgeTogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLnkpXG4gIH07XG4gIHJldHVybiBhZGp1c3RlZE1heFNjcm9sbDtcbn07XG5cbnZhciBnZXREb2N1bWVudEVsZW1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWRvYyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59O1xuXG52YXIgZ2V0TWF4V2luZG93U2Nyb2xsID0gKCkgPT4ge1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICBzY3JvbGxIZWlnaHQ6IGRvYy5zY3JvbGxIZWlnaHQsXG4gICAgc2Nyb2xsV2lkdGg6IGRvYy5zY3JvbGxXaWR0aCxcbiAgICB3aWR0aDogZG9jLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZG9jLmNsaWVudEhlaWdodFxuICB9KTtcbiAgcmV0dXJuIG1heFNjcm9sbDtcbn07XG5cbnZhciBnZXRWaWV3cG9ydCA9ICgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKCk7XG4gIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCB0b3AgPSBzY3JvbGwueTtcbiAgY29uc3QgbGVmdCA9IHNjcm9sbC54O1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgY29uc3Qgd2lkdGggPSBkb2MuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGRvYy5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tXG4gIH0pO1xuICBjb25zdCB2aWV3cG9ydCA9IHtcbiAgICBmcmFtZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHNjcm9sbCxcbiAgICAgIGN1cnJlbnQ6IHNjcm9sbCxcbiAgICAgIG1heDogbWF4U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IG9yaWdpblxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufTtcblxudmFyIGdldEluaXRpYWxQdWJsaXNoID0gKHtcbiAgY3JpdGljYWwsXG4gIHNjcm9sbE9wdGlvbnMsXG4gIHJlZ2lzdHJ5XG59KSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQoKTtcbiAgY29uc3Qgd2luZG93U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIGNvbnN0IGhvbWUgPSBjcml0aWNhbC5kcm9wcGFibGU7XG4gIGNvbnN0IGRyb3BwYWJsZXMgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmNhbGxiYWNrcy5nZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCh3aW5kb3dTY3JvbGwsIHNjcm9sbE9wdGlvbnMpKTtcbiAgY29uc3QgZHJhZ2dhYmxlcyA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRBbGxCeVR5cGUoY3JpdGljYWwuZHJhZ2dhYmxlLnR5cGUpLm1hcChlbnRyeSA9PiBlbnRyeS5nZXREaW1lbnNpb24od2luZG93U2Nyb2xsKSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJhZ2dhYmxlczogdG9EcmFnZ2FibGVNYXAoZHJhZ2dhYmxlcyksXG4gICAgZHJvcHBhYmxlczogdG9Ecm9wcGFibGVNYXAoZHJvcHBhYmxlcylcbiAgfTtcbiAgZmluaXNoKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkaW1lbnNpb25zLFxuICAgIGNyaXRpY2FsLFxuICAgIHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZW50cnkpIHtcbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnaW5nLmlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICBpZiAoaG9tZS5kZXNjcmlwdG9yLm1vZGUgIT09ICd2aXJ0dWFsJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgWW91IGFyZSBhdHRlbXB0aW5nIHRvIGFkZCBvciByZW1vdmUgYSBEcmFnZ2FibGUgW2lkOiAke2VudHJ5LmRlc2NyaXB0b3IuaWR9XVxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cblxuICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL3BhdHRlcm5zL3ZpcnR1YWwtbGlzdHMubWRcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgY3JlYXRlRGltZW5zaW9uTWFyc2hhbCA9IChyZWdpc3RyeSwgY2FsbGJhY2tzKSA9PiB7XG4gIGxldCBjb2xsZWN0aW9uID0gbnVsbDtcbiAgY29uc3QgcHVibGlzaGVyID0gY3JlYXRlUHVibGlzaGVyKHtcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIHB1Ymxpc2g6IGNhbGxiYWNrcy5wdWJsaXNoV2hpbGVEcmFnZ2luZyxcbiAgICAgIGNvbGxlY3Rpb25TdGFydGluZzogY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZ1xuICAgIH0sXG4gICAgcmVnaXN0cnlcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCA9IChpZCwgaXNFbmFibGVkKSA9PiB7XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSBpcyBlbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlICR7aWR9IGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gKGlkLCBpc0NvbWJpbmVFbmFibGVkKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoe1xuICAgICAgaWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IChpZCwgbmV3U2Nyb2xsKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgdGhlIHNjcm9sbCBvbiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVTY3JvbGwoe1xuICAgICAgaWQsXG4gICAgICBuZXdTY3JvbGxcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsRHJvcHBhYmxlID0gKGlkLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoaWQpLmNhbGxiYWNrcy5zY3JvbGwoY2hhbmdlKTtcbiAgfTtcbiAgY29uc3Qgc3RvcFB1Ymxpc2hpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHB1Ymxpc2hlci5zdG9wKCk7XG4gICAgY29uc3QgaG9tZSA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJvcHBhYmxlO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5mb3JFYWNoKGVudHJ5ID0+IGVudHJ5LmNhbGxiYWNrcy5kcmFnU3RvcHBlZCgpKTtcbiAgICBjb2xsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgY29sbGVjdGlvbiA9IG51bGw7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZXIgPSBldmVudCA9PiB7XG4gICAgIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgb25seSBiZSBzdWJzY3JpYmVkIHdoZW4gYSBjb2xsZWN0aW9uIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ0FERElUSU9OJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLmFkZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAnUkVNT1ZBTCcpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5yZW1vdmUoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRQdWJsaXNoaW5nID0gcmVxdWVzdCA9PiB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKHJlcXVlc3QuZHJhZ2dhYmxlSWQpO1xuICAgIGNvbnN0IGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgICBjb25zdCBjcml0aWNhbCA9IHtcbiAgICAgIGRyYWdnYWJsZTogZW50cnkuZGVzY3JpcHRvcixcbiAgICAgIGRyb3BwYWJsZTogaG9tZS5kZXNjcmlwdG9yXG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJlZ2lzdHJ5LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgY3JpdGljYWwsXG4gICAgICB1bnN1YnNjcmliZVxuICAgIH07XG4gICAgcmV0dXJuIGdldEluaXRpYWxQdWJsaXNoKHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBzY3JvbGxPcHRpb25zOiByZXF1ZXN0LnNjcm9sbE9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgbWFyc2hhbCA9IHtcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHN0YXJ0UHVibGlzaGluZyxcbiAgICBzdG9wUHVibGlzaGluZ1xuICB9O1xuICByZXR1cm4gbWFyc2hhbDtcbn07XG5cbnZhciBjYW5TdGFydERyYWcgPSAoc3RhdGUsIGlkKSA9PiB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHN0YXRlLnBoYXNlICE9PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUuY29tcGxldGVkLnJlc3VsdC5yZWFzb24gPT09ICdEUk9QJztcbn07XG5cbnZhciBzY3JvbGxXaW5kb3cgPSBjaGFuZ2UgPT4ge1xuICB3aW5kb3cuc2Nyb2xsQnkoY2hhbmdlLngsIGNoYW5nZS55KTtcbn07XG5cbmNvbnN0IGdldFNjcm9sbGFibGVEcm9wcGFibGVzID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgaWYgKCFkcm9wcGFibGUuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZHJvcHBhYmxlLmZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSkpO1xuY29uc3QgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIgPSAodGFyZ2V0LCBkcm9wcGFibGVzKSA9PiB7XG4gIGNvbnN0IG1heWJlID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMoZHJvcHBhYmxlcykuZmluZChkcm9wcGFibGUgPT4ge1xuICAgICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHJlc3VsdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KSB8fCBudWxsO1xuICByZXR1cm4gbWF5YmU7XG59O1xudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKHtcbiAgY2VudGVyLFxuICBkZXN0aW5hdGlvbixcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uXTtcbiAgICBpZiAoIWRpbWVuc2lvbi5mcmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH1cbiAgY29uc3QgZGltZW5zaW9uID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIoY2VudGVyLCBkcm9wcGFibGVzKTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmNvbnN0IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zID0ge1xuICBzdGFydEZyb21QZXJjZW50YWdlOiAwLjI1LFxuICBtYXhTY3JvbGxBdFBlcmNlbnRhZ2U6IDAuMDUsXG4gIG1heFBpeGVsU2Nyb2xsOiAyOCxcbiAgZWFzZTogcGVyY2VudGFnZSA9PiBwZXJjZW50YWdlICoqIDIsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgc3RvcERhbXBlbmluZ0F0OiAxMjAwLFxuICAgIGFjY2VsZXJhdGVBdDogMzYwXG4gIH0sXG4gIGRpc2FibGVkOiBmYWxzZVxufTtcblxudmFyIGdldERpc3RhbmNlVGhyZXNob2xkcyA9IChjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBzdGFydFNjcm9sbGluZ0Zyb20gPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGF1dG9TY3JvbGxlck9wdGlvbnMuc3RhcnRGcm9tUGVyY2VudGFnZTtcbiAgY29uc3QgbWF4U2Nyb2xsVmFsdWVBdCA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhTY3JvbGxBdFBlcmNlbnRhZ2U7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSB7XG4gICAgc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIG1heFNjcm9sbFZhbHVlQXRcbiAgfTtcbiAgcmV0dXJuIHRocmVzaG9sZHM7XG59O1xuXG52YXIgZ2V0UGVyY2VudGFnZSA9ICh7XG4gIHN0YXJ0T2ZSYW5nZSxcbiAgZW5kT2ZSYW5nZSxcbiAgY3VycmVudFxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IGVuZE9mUmFuZ2UgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRGV0ZWN0ZWQgZGlzdGFuY2UgcmFuZ2Ugb2YgMCBpbiB0aGUgZmx1aWQgYXV0byBzY3JvbGxlclxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxuICAgICAgTm90IGFsbG93aW5nIGFuIGF1dG8gc2Nyb2xsXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICBjb25zdCBwZXJjZW50YWdlID0gY3VycmVudEluUmFuZ2UgLyByYW5nZTtcbiAgcmV0dXJuIHBlcmNlbnRhZ2U7XG59O1xuXG52YXIgbWluU2Nyb2xsID0gMTtcblxudmFyIGdldFZhbHVlRnJvbURpc3RhbmNlID0gKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgaWYgKGRpc3RhbmNlVG9FZGdlID4gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPD0gdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0KSB7XG4gICAgcmV0dXJuIGF1dG9TY3JvbGxlck9wdGlvbnMubWF4UGl4ZWxTY3JvbGw7XG4gIH1cbiAgaWYgKGRpc3RhbmNlVG9FZGdlID09PSB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cbiAgY29uc3QgcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0ID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQsXG4gICAgZW5kT2ZSYW5nZTogdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgY3VycmVudDogZGlzdGFuY2VUb0VkZ2VcbiAgfSk7XG4gIGNvbnN0IHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tID0gMSAtIHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdDtcbiAgY29uc3Qgc2Nyb2xsID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbCAqIGF1dG9TY3JvbGxlck9wdGlvbnMuZWFzZShwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn07XG5cbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9IChwcm9wb3NlZFNjcm9sbCwgZHJhZ1N0YXJ0VGltZSwgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBhY2NlbGVyYXRlQXQgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLmFjY2VsZXJhdGVBdDtcbiAgY29uc3Qgc3RvcEF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5zdG9wRGFtcGVuaW5nQXQ7XG4gIGNvbnN0IHN0YXJ0T2ZSYW5nZSA9IGRyYWdTdGFydFRpbWU7XG4gIGNvbnN0IGVuZE9mUmFuZ2UgPSBzdG9wQXQ7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJ1blRpbWUgPSBub3cgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChydW5UaW1lID49IHN0b3BBdCkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAocnVuVGltZSA8IGFjY2VsZXJhdGVBdCkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cbiAgY29uc3QgYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IGFjY2VsZXJhdGVBdCxcbiAgICBlbmRPZlJhbmdlLFxuICAgIGN1cnJlbnQ6IHJ1blRpbWVcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbCA9IHByb3Bvc2VkU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufTtcblxudmFyIGdldFZhbHVlID0gKHtcbiAgZGlzdGFuY2VUb0VkZ2UsXG4gIHRocmVzaG9sZHMsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0VmFsdWVGcm9tRGlzdGFuY2UoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFzaG91bGRVc2VUaW1lRGFtcGVuaW5nKSB7XG4gICAgcmV0dXJuIHNjcm9sbDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoZGFtcGVuVmFsdWVCeVRpbWUoc2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSwgbWluU2Nyb2xsKTtcbn07XG5cbnZhciBnZXRTY3JvbGxPbkF4aXMgPSAoe1xuICBjb250YWluZXIsXG4gIGRpc3RhbmNlVG9FZGdlcyxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgYXhpcyxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCB0aHJlc2hvbGRzID0gZ2V0RGlzdGFuY2VUaHJlc2hvbGRzKGNvbnRhaW5lciwgYXhpcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyk7XG4gIGNvbnN0IGlzQ2xvc2VyVG9FbmQgPSBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdIDwgZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdO1xuICBpZiAoaXNDbG9zZXJUb0VuZCkge1xuICAgIHJldHVybiBnZXRWYWx1ZSh7XG4gICAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuZW5kXSxcbiAgICAgIHRocmVzaG9sZHMsXG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLTEgKiBnZXRWYWx1ZSh7XG4gICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XSxcbiAgICB0aHJlc2hvbGRzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xufTtcblxudmFyIGFkanVzdEZvclNpemVMaW1pdHMgPSAoe1xuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIHByb3Bvc2VkU2Nyb2xsXG59KSA9PiB7XG4gIGNvbnN0IGlzVG9vQmlnVmVydGljYWxseSA9IHN1YmplY3QuaGVpZ2h0ID4gY29udGFpbmVyLmhlaWdodDtcbiAgY29uc3QgaXNUb29CaWdIb3Jpem9udGFsbHkgPSBzdWJqZWN0LndpZHRoID4gY29udGFpbmVyLndpZHRoO1xuICBpZiAoIWlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmICFpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKGlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmIGlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogaXNUb29CaWdIb3Jpem9udGFsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueCxcbiAgICB5OiBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueVxuICB9O1xufTtcblxuY29uc3QgY2xlYW4gPSBhcHBseSh2YWx1ZSA9PiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG52YXIgZ2V0U2Nyb2xsJDEgPSAoe1xuICBkcmFnU3RhcnRUaW1lLFxuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBkaXN0YW5jZVRvRWRnZXMgPSB7XG4gICAgdG9wOiBjZW50ZXIueSAtIGNvbnRhaW5lci50b3AsXG4gICAgcmlnaHQ6IGNvbnRhaW5lci5yaWdodCAtIGNlbnRlci54LFxuICAgIGJvdHRvbTogY29udGFpbmVyLmJvdHRvbSAtIGNlbnRlci55LFxuICAgIGxlZnQ6IGNlbnRlci54IC0gY29udGFpbmVyLmxlZnRcbiAgfTtcbiAgY29uc3QgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IHZlcnRpY2FsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IGhvcml6b250YWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCByZXF1aXJlZCA9IGNsZWFuKHtcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIGlmIChpc0VxdWFsJDEocmVxdWlyZWQsIG9yaWdpbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaW1pdGVkID0gYWRqdXN0Rm9yU2l6ZUxpbWl0cyh7XG4gICAgY29udGFpbmVyLFxuICAgIHN1YmplY3QsXG4gICAgcHJvcG9zZWRTY3JvbGw6IHJlcXVpcmVkXG4gIH0pO1xuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaXNFcXVhbCQxKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn07XG5cbmNvbnN0IHNtYWxsZXN0U2lnbmVkID0gYXBwbHkodmFsdWUgPT4ge1xuICBpZiAodmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufSk7XG5jb25zdCBnZXRPdmVybGFwID0gKCgpID0+IHtcbiAgY29uc3QgZ2V0UmVtYWluZGVyID0gKHRhcmdldCwgbWF4KSA9PiB7XG4gICAgaWYgKHRhcmdldCA8IDApIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgLSBtYXg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICByZXR1cm4gKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbCA9IGFkZChjdXJyZW50LCBjaGFuZ2UpO1xuICAgIGNvbnN0IG92ZXJsYXAgPSB7XG4gICAgICB4OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLngsIG1heC54KSxcbiAgICAgIHk6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueSwgbWF4LnkpXG4gICAgfTtcbiAgICBpZiAoaXNFcXVhbCQxKG92ZXJsYXAsIG9yaWdpbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxhcDtcbiAgfTtcbn0pKCk7XG5jb25zdCBjYW5QYXJ0aWFsbHlTY3JvbGwgPSAoe1xuICBtYXg6IHJhd01heCxcbiAgY3VycmVudCxcbiAgY2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IG1heCA9IHtcbiAgICB4OiBNYXRoLm1heChjdXJyZW50LngsIHJhd01heC54KSxcbiAgICB5OiBNYXRoLm1heChjdXJyZW50LnksIHJhd01heC55KVxuICB9O1xuICBjb25zdCBzbWFsbGVzdENoYW5nZSA9IHNtYWxsZXN0U2lnbmVkKGNoYW5nZSk7XG4gIGNvbnN0IG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXgsXG4gICAgY3VycmVudCxcbiAgICBjaGFuZ2U6IHNtYWxsZXN0Q2hhbmdlXG4gIH0pO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueSAhPT0gMCAmJiBvdmVybGFwLnkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY2FuU2Nyb2xsV2luZG93ID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IGNhblBhcnRpYWxseVNjcm9sbCh7XG4gIGN1cnJlbnQ6IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LFxuICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gIGNoYW5nZVxufSk7XG5jb25zdCBnZXRXaW5kb3dPdmVybGFwID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICBjb25zdCBjdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgY2FuU2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlcmxhcCA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9ICh7XG4gIHZpZXdwb3J0LFxuICBzdWJqZWN0LFxuICBjZW50ZXIsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsJDEoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiB2aWV3cG9ydC5mcmFtZSxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn07XG5cbnZhciBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSAoe1xuICBkcm9wcGFibGUsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNjcm9sbCA9IGdldFNjcm9sbCQxKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogZnJhbWUucGFnZU1hcmdpbkJveCxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59O1xuXG52YXIgc2Nyb2xsID0gKHtcbiAgc3RhdGUsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBzdWJqZWN0ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICBpZiAoc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCBjaGFuZ2UgPSBnZXRXaW5kb3dTY3JvbGxDaGFuZ2Uoe1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc3ViamVjdCxcbiAgICAgIGNlbnRlcixcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlKHtcbiAgICBjZW50ZXIsXG4gICAgZGVzdGluYXRpb246IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCksXG4gICAgZHJvcHBhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGFuZ2UgPSBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2Uoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgaWYgKGNoYW5nZSkge1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUZsdWlkU2Nyb2xsZXIgPSAoe1xuICBzY3JvbGxXaW5kb3csXG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHNjaGVkdWxlV2luZG93U2Nyb2xsID0gcmFmU2NoZChzY3JvbGxXaW5kb3cpO1xuICBjb25zdCBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCA9IHJhZlNjaGQoc2Nyb2xsRHJvcHBhYmxlKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgdHJ5U2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmbHVpZCBzY3JvbGwgaWYgbm90IGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZHJhZ1N0YXJ0VGltZVxuICAgIH0gPSBkcmFnZ2luZztcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBzY3JvbGxXaW5kb3c6IHNjaGVkdWxlV2luZG93U2Nyb2xsLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCQxID0gc3RhdGUgPT4ge1xuICAgIHN0YXJ0KCk7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBhdXRvIHNjcm9sbGluZyB3aGVuIGFscmVhZHkgc3RhcnRlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHdhc1Njcm9sbE5lZWRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGZha2VTY3JvbGxDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdhc1Njcm9sbE5lZWRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBkcmFnU3RhcnRUaW1lOiAwLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogZmFsc2UsXG4gICAgICBzY3JvbGxXaW5kb3c6IGZha2VTY3JvbGxDYWxsYmFjayxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHdhc1Njcm9sbE5lZWRlZFxuICAgIH07XG4gICAgZmluaXNoKCk7XG4gICAgaWYgKHdhc1Njcm9sbE5lZWRlZCkge1xuICAgICAgdHJ5U2Nyb2xsKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVdpbmRvd1Njcm9sbC5jYW5jZWwoKTtcbiAgICBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbC5jYW5jZWwoKTtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0JDEsXG4gICAgc3RvcCxcbiAgICBzY3JvbGw6IHRyeVNjcm9sbFxuICB9O1xufTtcblxudmFyIGNyZWF0ZUp1bXBTY3JvbGxlciA9ICh7XG4gIG1vdmUsXG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgc2Nyb2xsV2luZG93XG59KSA9PiB7XG4gIGNvbnN0IG1vdmVCeU9mZnNldCA9IChzdGF0ZSwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYWRkKHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbiwgb2Zmc2V0KTtcbiAgICBtb3ZlKHtcbiAgICAgIGNsaWVudFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwID0gZ2V0RHJvcHBhYmxlT3ZlcmxhcChkcm9wcGFibGUsIGNoYW5nZSk7XG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG4gIGNvbnN0IHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4gPSAoaXNXaW5kb3dTY3JvbGxBbGxvd2VkLCB2aWV3cG9ydCwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFpc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGlmICghY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwID0gZ2V0V2luZG93T3ZlcmxhcCh2aWV3cG9ydCwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbFdpbmRvdyh3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG4gIGNvbnN0IGp1bXBTY3JvbGxlciA9IHN0YXRlID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3Q7XG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAhZGVzdGluYXRpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcGVyZm9ybSBhIGp1bXAgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZGVzdGluYXRpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyb3BwYWJsZVJlbWFpbmRlciA9IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4oc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2Rlc3RpbmF0aW9uXSwgcmVxdWVzdCk7XG4gICAgaWYgKCFkcm9wcGFibGVSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCB3aW5kb3dSZW1haW5kZXIgPSBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGRyb3BwYWJsZVJlbWFpbmRlcik7XG4gICAgaWYgKCF3aW5kb3dSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW92ZUJ5T2Zmc2V0KHN0YXRlLCB3aW5kb3dSZW1haW5kZXIpO1xuICB9O1xuICByZXR1cm4ganVtcFNjcm9sbGVyO1xufTtcblxudmFyIGNyZWF0ZUF1dG9TY3JvbGxlciA9ICh7XG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgc2Nyb2xsV2luZG93LFxuICBtb3ZlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGZsdWlkU2Nyb2xsZXIgPSBjcmVhdGVGbHVpZFNjcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGp1bXBTY3JvbGwgPSBjcmVhdGVKdW1wU2Nyb2xsZXIoe1xuICAgIG1vdmUsXG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZVxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gICAgaWYgKGF1dG9TY3JvbGxlck9wdGlvbnMuZGlzYWJsZWQgfHwgc3RhdGUucGhhc2UgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ0ZMVUlEJykge1xuICAgICAgZmx1aWRTY3JvbGxlci5zY3JvbGwoc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGp1bXBTY3JvbGwoc3RhdGUpO1xuICB9O1xuICBjb25zdCBzY3JvbGxlciA9IHtcbiAgICBzY3JvbGwsXG4gICAgc3RhcnQ6IGZsdWlkU2Nyb2xsZXIuc3RhcnQsXG4gICAgc3RvcDogZmx1aWRTY3JvbGxlci5zdG9wXG4gIH07XG4gIHJldHVybiBzY3JvbGxlcjtcbn07XG5cbmNvbnN0IHByZWZpeCA9ICdkYXRhLXJmZCc7XG5jb25zdCBkcmFnSGFuZGxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZy1oYW5kbGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgZHJhZ2dhYmxlSWQ6IGAke2Jhc2V9LWRyYWdnYWJsZS1pZGAsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyYWdnYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyYWdnYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBkcm9wcGFibGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcm9wcGFibGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYCxcbiAgICBpZDogYCR7YmFzZX0taWRgXG4gIH07XG59KSgpO1xuY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0ge1xuICBjb250ZXh0SWQ6IGAke3ByZWZpeH0tc2Nyb2xsLWNvbnRhaW5lci1jb250ZXh0LWlkYFxufTtcblxuY29uc3QgbWFrZUdldFNlbGVjdG9yID0gY29udGV4dCA9PiBhdHRyaWJ1dGUgPT4gYFske2F0dHJpYnV0ZX09XCIke2NvbnRleHR9XCJdYDtcbmNvbnN0IGdldFN0eWxlcyA9IChydWxlcywgcHJvcGVydHkpID0+IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgY29uc3QgdmFsdWUgPSBydWxlLnN0eWxlc1twcm9wZXJ0eV07XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGAke3J1bGUuc2VsZWN0b3J9IHsgJHt2YWx1ZX0gfWA7XG59KS5qb2luKCcgJyk7XG5jb25zdCBub1BvaW50ZXJFdmVudHMgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbnZhciBnZXRTdHlsZXMkMSA9IGNvbnRleHRJZCA9PiB7XG4gIGNvbnN0IGdldFNlbGVjdG9yID0gbWFrZUdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIGNvbnN0IGRyYWdIYW5kbGUkMSA9ICgoKSA9PiB7XG4gICAgY29uc3QgZ3JhYkN1cnNvciA9IGBcbiAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xuICAgICAgY3Vyc29yOiBncmFiO1xuICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnSGFuZGxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgYWx3YXlzOiBgXG4gICAgICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgYCxcbiAgICAgICAgcmVzdGluZzogZ3JhYkN1cnNvcixcbiAgICAgICAgZHJhZ2dpbmc6IG5vUG9pbnRlckV2ZW50cyxcbiAgICAgICAgZHJvcEFuaW1hdGluZzogZ3JhYkN1cnNvclxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gYFxuICAgICAgdHJhbnNpdGlvbjogJHt0cmFuc2l0aW9ucy5vdXRPZlRoZVdheX07XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdnYWJsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGRyYWdnaW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICB1c2VyQ2FuY2VsOiB0cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJvcHBhYmxlJDEgPSB7XG4gICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyb3BwYWJsZS5jb250ZXh0SWQpLFxuICAgIHN0eWxlczoge1xuICAgICAgYWx3YXlzOiBgb3ZlcmZsb3ctYW5jaG9yOiBub25lO2BcbiAgICB9XG4gIH07XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGRyYWdnaW5nOiBgXG4gICAgICAgIGN1cnNvcjogZ3JhYmJpbmc7XG4gICAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgb3ZlcmZsb3ctYW5jaG9yOiBub25lO1xuICAgICAgYFxuICAgIH1cbiAgfTtcbiAgY29uc3QgcnVsZXMgPSBbZHJhZ2dhYmxlJDEsIGRyYWdIYW5kbGUkMSwgZHJvcHBhYmxlJDEsIGJvZHldO1xuICByZXR1cm4ge1xuICAgIGFsd2F5czogZ2V0U3R5bGVzKHJ1bGVzLCAnYWx3YXlzJyksXG4gICAgcmVzdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAncmVzdGluZycpLFxuICAgIGRyYWdnaW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcmFnZ2luZycpLFxuICAgIGRyb3BBbmltYXRpbmc6IGdldFN0eWxlcyhydWxlcywgJ2Ryb3BBbmltYXRpbmcnKSxcbiAgICB1c2VyQ2FuY2VsOiBnZXRTdHlsZXMocnVsZXMsICd1c2VyQ2FuY2VsJylcbiAgfTtcbn07XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5jb25zdCBnZXRIZWFkID0gKCkgPT4ge1xuICBjb25zdCBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAhaGVhZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIHRoZSBoZWFkIHRvIGFwcGVuZCBhIHN0eWxlIHRvJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGhlYWQ7XG59O1xuY29uc3QgY3JlYXRlU3R5bGVFbCA9IG5vbmNlID0+IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBpZiAobm9uY2UpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICByZXR1cm4gZWw7XG59O1xuZnVuY3Rpb24gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlTWVtbygoKSA9PiBnZXRTdHlsZXMkMShjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IGFsd2F5c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZHluYW1pY1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0RHluYW1pY1N0eWxlID0gdXNlQ2FsbGJhY2sobWVtb2l6ZU9uZShwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBkeW5hbWljUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSksIFtdKTtcbiAgY29uc3Qgc2V0QWx3YXlzU3R5bGUgPSB1c2VDYWxsYmFjayhwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBhbHdheXNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICEoIWFsd2F5c1JlZi5jdXJyZW50ICYmICFkeW5hbWljUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnc3R5bGUgZWxlbWVudHMgYWxyZWFkeSBtb3VudGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbHdheXMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBjb25zdCBkeW5hbWljID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgYWx3YXlzUmVmLmN1cnJlbnQgPSBhbHdheXM7XG4gICAgZHluYW1pY1JlZi5jdXJyZW50ID0gZHluYW1pYztcbiAgICBhbHdheXMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tYWx3YXlzYCwgY29udGV4dElkKTtcbiAgICBkeW5hbWljLnNldEF0dHJpYnV0ZShgJHtwcmVmaXh9LWR5bmFtaWNgLCBjb250ZXh0SWQpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChhbHdheXMpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChkeW5hbWljKTtcbiAgICBzZXRBbHdheXNTdHlsZShzdHlsZXMuYWx3YXlzKTtcbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByZW1vdmUgPSByZWYgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICFjdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHVubW91bnQgcmVmIGFzIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICByZW1vdmUoYWx3YXlzUmVmKTtcbiAgICAgIHJlbW92ZShkeW5hbWljUmVmKTtcbiAgICB9O1xuICB9LCBbbm9uY2UsIHNldEFsd2F5c1N0eWxlLCBzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5hbHdheXMsIHN0eWxlcy5yZXN0aW5nLCBjb250ZXh0SWRdKTtcbiAgY29uc3QgZHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyYWdnaW5nKSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyYWdnaW5nXSk7XG4gIGNvbnN0IGRyb3BwaW5nID0gdXNlQ2FsbGJhY2socmVhc29uID0+IHtcbiAgICBpZiAocmVhc29uID09PSAnRFJPUCcpIHtcbiAgICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJvcEFuaW1hdGluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMudXNlckNhbmNlbCk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcm9wQW5pbWF0aW5nLCBzdHlsZXMudXNlckNhbmNlbF0pO1xuICBjb25zdCByZXN0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZHluYW1pY1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5yZXN0aW5nXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dpbmcsXG4gICAgZHJvcHBpbmcsXG4gICAgcmVzdGluZ1xuICB9KSwgW2RyYWdnaW5nLCBkcm9wcGluZywgcmVzdGluZ10pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChwYXJlbnROb2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxudmFyIGdldFdpbmRvd0Zyb21FbCA9IGVsID0+IHtcbiAgaWYgKGVsICYmIGVsLm93bmVyRG9jdW1lbnQgJiYgZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9XG4gIHJldHVybiB3aW5kb3c7XG59O1xuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGlmICghcG9zc2libGUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgYW55IGRyYWcgaGFuZGxlcyBpbiB0aGUgY29udGV4dCBcIiR7Y29udGV4dElkfVwiYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlIHdpdGggaWQgXCIke2RyYWdnYWJsZUlkfVwiIGFzIG5vIGhhbmRsZSB3aXRoIGEgbWF0Y2hpbmcgaWQgd2FzIGZvdW5kYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBuZWVkcyB0byBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICBjb25zdCBlbnRyaWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcmVjb3JkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9jdXMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGlkLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIGVudHJpZXNSZWYuY3VycmVudFtpZF0gPSBlbnRyeTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllc1tpZF07XG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgdHJ5R2l2ZUZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5R2l2ZUZvY3VzKHRyeUdpdmVGb2N1c1RvKSB7XG4gICAgY29uc3QgaGFuZGxlID0gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCB0cnlHaXZlRm9jdXNUbyk7XG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGhhbmRsZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCB0cnlTaGlmdFJlY29yZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVNoaWZ0UmVjb3JkKHByZXZpb3VzLCByZWRpcmVjdFRvKSB7XG4gICAgaWYgKHJlY29yZFJlZi5jdXJyZW50ID09PSBwcmV2aW91cykge1xuICAgICAgcmVjb3JkUmVmLmN1cnJlbnQgPSByZWRpcmVjdFRvO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZFJlZi5jdXJyZW50O1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICB0cnlHaXZlRm9jdXMocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3RyeUdpdmVGb2N1c10pO1xuICBjb25zdCB0cnlSZWNvcmRGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlY29yZEZvY3VzKGlkKSB7XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9jdXNlZC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgIT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhckZyYW1lT25Vbm1vdW50KCkge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGZyYW1lSWQgPSByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZ2lzdGVyLFxuICAgIHRyeVJlY29yZEZvY3VzLFxuICAgIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLFxuICAgIHRyeVNoaWZ0UmVjb3JkXG4gIH0pLCBbcmVnaXN0ZXIsIHRyeVJlY29yZEZvY3VzLCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCwgdHJ5U2hpZnRSZWNvcmRdKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdHJ5KCkge1xuICBjb25zdCBlbnRyaWVzID0ge1xuICAgIGRyYWdnYWJsZXM6IHt9LFxuICAgIGRyb3BwYWJsZXM6IHt9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gW107XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYikge1xuICAgIHN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYik7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoKSB7XG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGNiID0+IGNiKGV2ZW50KSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGVudHJpZXMuZHJhZ2dhYmxlc1tpZF0gfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kRHJhZ2dhYmxlQnlJZChpZCk7XG4gICAgIWVudHJ5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgZHJhZ2dhYmxlIGVudHJ5IHdpdGggaWQgWyR7aWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnQURESVRJT04nLFxuICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoZW50cnksIGxhc3QpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC51bmlxdWVJZCAhPT0gZW50cnkudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyYWdnYWJsZUJ5SWQoZHJhZ2dhYmxlSWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2RyYWdnYWJsZUlkXTtcbiAgICAgIGlmIChlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0pIHtcbiAgICAgICAgbm90aWZ5KHtcbiAgICAgICAgICB0eXBlOiAnUkVNT1ZBTCcsXG4gICAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJhZ2dhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyYWdnYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcmFnZ2FibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcmFnZ2FibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBmaW5kRHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyb3BwYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJvcHBhYmxlQnlJZChpZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZERyb3BwYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIGRyb3BwYWJsZSBlbnRyeSB3aXRoIGlkIFske2lkfV1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcm9wcGFibGVCeUlkKGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdO1xuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJvcHBhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyb3BwYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcm9wcGFibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBlbnRyaWVzLmRyYWdnYWJsZXMgPSB7fTtcbiAgICBlbnRyaWVzLmRyb3BwYWJsZXMgPSB7fTtcbiAgICBzdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlLFxuICAgIGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICBjb25zdCByZWdpc3RyeSA9IHVzZU1lbW8oY3JlYXRlUmVnaXN0cnksIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHJlZ2lzdHJ5LmNsZWFuKCk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5XSk7XG4gIHJldHVybiByZWdpc3RyeTtcbn1cblxudmFyIFN0b3JlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBnZXRCb2R5RWxlbWVudCA9ICgpID0+IHtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICFib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuYm9keScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBib2R5O1xufTtcblxuY29uc3QgdmlzdWFsbHlIaWRkZW4gPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB3aWR0aDogJzFweCcsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBib3JkZXI6ICcwJyxcbiAgcGFkZGluZzogJzAnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgJ2NsaXAtcGF0aCc6ICdpbnNldCgxMDAlKSdcbn07XG5cbmNvbnN0IGdldElkID0gY29udGV4dElkID0+IGByZmQtYW5ub3VuY2VtZW50LSR7Y29udGV4dElkfWA7XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRJZChjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIF9leHRlbmRzKGVsLnN0eWxlLCB2aXN1YWxseUhpZGRlbik7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gICAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbCA9PT0gcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtpZF0pO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUNhbGxiYWNrKG1lc3NhZ2UgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgQSBzY3JlZW4gcmVhZGVyIG1lc3NhZ2Ugd2FzIHRyeWluZyB0byBiZSBhbm5vdW5jZWQgYnV0IGl0IHdhcyB1bmFibGUgdG8gZG8gc28uXG4gICAgICBUaGlzIGNhbiBvY2N1ciBpZiB5b3UgdW5tb3VudCB5b3VyIDxEcmFnRHJvcENvbnRleHQgLz4gaW4geW91ciBvbkRyYWdFbmQuXG4gICAgICBDb25zaWRlciBjYWxsaW5nIHByb3ZpZGVkLmFubm91bmNlKCkgYmVmb3JlIHRoZSB1bm1vdW50IHNvIHRoYXQgdGhlIGluc3RydWN0aW9uIHdpbGxcbiAgICAgIG5vdCBiZSBsb3N0IGZvciB1c2VycyByZWx5aW5nIG9uIGEgc2NyZWVuIHJlYWRlci5cblxuICAgICAgTWVzc2FnZSBub3QgcGFzc2VkIHRvIHNjcmVlbiByZWFkZXI6XG5cbiAgICAgIFwiJHttZXNzYWdlfVwiXG4gICAgYCkgOiB2b2lkIDA7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGFubm91bmNlO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgc2VwYXJhdG9yOiAnOjonXG59O1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQocHJlZml4LCBvcHRpb25zID0gZGVmYXVsdHMpIHtcbiAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBgJHtwcmVmaXh9JHtvcHRpb25zLnNlcGFyYXRvcn0ke2lkfWAsIFtvcHRpb25zLnNlcGFyYXRvciwgcHJlZml4LCBpZF0pO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50SWQoe1xuICBjb250ZXh0SWQsXG4gIHVuaXF1ZUlkXG59KSB7XG4gIHJldHVybiBgcmZkLWhpZGRlbi10ZXh0LSR7Y29udGV4dElkfS0ke3VuaXF1ZUlkfWA7XG59XG5mdW5jdGlvbiB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gIGNvbnRleHRJZCxcbiAgdGV4dFxufSkge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdoaWRkZW4tdGV4dCcsIHtcbiAgICBzZXBhcmF0b3I6ICctJ1xuICB9KTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGdldEVsZW1lbnRJZCh7XG4gICAgY29udGV4dElkLFxuICAgIHVuaXF1ZUlkXG4gIH0pLCBbdW5pcXVlSWQsIGNvbnRleHRJZF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGdldEJvZHlFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gICAgICBpZiAoYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lkLCB0ZXh0XSk7XG4gIHJldHVybiBpZDtcbn1cblxudmFyIEFwcENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgcGVlckRlcGVuZGVuY2llcyA9IHtcblx0cmVhY3Q6IFwiXjE4LjAuMFwiLFxuXHRcInJlYWN0LWRvbVwiOiBcIl4xOC4wLjBcIlxufTtcblxuY29uc3Qgc2VtdmVyID0gLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS87XG5jb25zdCBnZXRWZXJzaW9uID0gdmFsdWUgPT4ge1xuICBjb25zdCByZXN1bHQgPSBzZW12ZXIuZXhlYyh2YWx1ZSk7XG4gICEocmVzdWx0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5hYmxlIHRvIHBhcnNlIFJlYWN0IHZlcnNpb24gJHt2YWx1ZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBtYWpvciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICBjb25zdCBtaW5vciA9IE51bWJlcihyZXN1bHRbMl0pO1xuICBjb25zdCBwYXRjaCA9IE51bWJlcihyZXN1bHRbM10pO1xuICByZXR1cm4ge1xuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHBhdGNoLFxuICAgIHJhdzogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBpc1NhdGlzZmllZCA9IChleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gIGlmIChhY3R1YWwubWFqb3IgPiBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWFqb3IgPCBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yID4gZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1pbm9yIDwgZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFjdHVhbC5wYXRjaCA+PSBleHBlY3RlZC5wYXRjaDtcbn07XG52YXIgY2hlY2tSZWFjdFZlcnNpb24gPSAocGVlckRlcFZhbHVlLCBhY3R1YWxWYWx1ZSkgPT4ge1xuICBjb25zdCBwZWVyRGVwID0gZ2V0VmVyc2lvbihwZWVyRGVwVmFsdWUpO1xuICBjb25zdCBhY3R1YWwgPSBnZXRWZXJzaW9uKGFjdHVhbFZhbHVlKTtcbiAgaWYgKGlzU2F0aXNmaWVkKHBlZXJEZXAsIGFjdHVhbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgUmVhY3QgdmVyc2lvbjogWyR7YWN0dWFsLnJhd31dXG4gICAgZG9lcyBub3Qgc2F0aXNmeSBleHBlY3RlZCBwZWVyIGRlcGVuZGVuY3kgdmVyc2lvbjogWyR7cGVlckRlcC5yYXd9XVxuXG4gICAgVGhpcyBjYW4gcmVzdWx0IGluIHJ1biB0aW1lIGJ1Z3MsIGFuZCBldmVuIGZhdGFsIGNyYXNoZXNcbiAgYCkgOiB2b2lkIDA7XG59O1xuXG5jb25zdCBzdWZmaXggPSBgXG4gIFdlIGV4cGVjdCBhIGh0bWw1IGRvY3R5cGU6IDwhZG9jdHlwZSBodG1sPlxuICBUaGlzIGlzIHRvIGVuc3VyZSBjb25zaXN0ZW50IGJyb3dzZXIgbGF5b3V0IGFuZCBtZWFzdXJlbWVudFxuXG4gIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy9kb2N0eXBlLm1kXG5gO1xudmFyIGNoZWNrRG9jdHlwZSA9IGRvYyA9PiB7XG4gIGNvbnN0IGRvY3R5cGUgPSBkb2MuZG9jdHlwZTtcbiAgaWYgKCFkb2N0eXBlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBObyA8IWRvY3R5cGUgaHRtbD4gZm91bmQuXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZG9jdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IGZvdW5kOiAoJHtkb2N0eXBlLm5hbWV9KVxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZG9jdHlwZS5wdWJsaWNJZCAhPT0gJycpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBwdWJsaWNJZCBmb3VuZDogKCR7ZG9jdHlwZS5wdWJsaWNJZH0pXG4gICAgICBBIGh0bWw1IGRvY3R5cGUgZG9lcyBub3QgaGF2ZSBhIHB1YmxpY0lkXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1c2VEZXYodXNlSG9vaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVzZUhvb2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VEZXZTZXR1cFdhcm5pbmcoZm4sIGlucHV0cykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihgXG4gICAgICAgICAgQSBzZXR1cCBwcm9ibGVtIHdhcyBlbmNvdW50ZXJlZC5cblxuICAgICAgICAgID4gJHtlLm1lc3NhZ2V9XG4gICAgICAgIGApO1xuICAgICAgfVxuICAgIH0sIGlucHV0cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTdGFydHVwVmFsaWRhdGlvbigpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBjaGVja1JlYWN0VmVyc2lvbihwZWVyRGVwZW5kZW5jaWVzLnJlYWN0LCBSZWFjdC52ZXJzaW9uKTtcbiAgICBjaGVja0RvY3R5cGUoZG9jdW1lbnQpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKGN1cnJlbnQpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGN1cnJlbnQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGxvY2sgPSBudWxsO1xuICBmdW5jdGlvbiBpc0NsYWltZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBY3RpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxvY2s7XG4gIH1cbiAgZnVuY3Rpb24gY2xhaW0oYWJhbmRvbikge1xuICAgICEhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjbGFpbSBsb2NrIGFzIGl0IGlzIGFscmVhZHkgY2xhaW1lZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3TG9jayA9IHtcbiAgICAgIGFiYW5kb25cbiAgICB9O1xuICAgIGxvY2sgPSBuZXdMb2NrO1xuICAgIHJldHVybiBuZXdMb2NrO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVsZWFzZSBsb2NrIHdoZW4gdGhlcmUgaXMgbm8gbG9jaycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgbG9jayA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5QWJhbmRvbigpIHtcbiAgICBpZiAobG9jaykge1xuICAgICAgbG9jay5hYmFuZG9uKCk7XG4gICAgICByZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaXNDbGFpbWVkLFxuICAgIGlzQWN0aXZlLFxuICAgIGNsYWltLFxuICAgIHJlbGVhc2UsXG4gICAgdHJ5QWJhbmRvblxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0RyYWdnaW5nKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nO1xufVxuXG5jb25zdCB0YWIgPSA5O1xuY29uc3QgZW50ZXIgPSAxMztcbmNvbnN0IGVzY2FwZSA9IDI3O1xuY29uc3Qgc3BhY2UgPSAzMjtcbmNvbnN0IHBhZ2VVcCA9IDMzO1xuY29uc3QgcGFnZURvd24gPSAzNDtcbmNvbnN0IGVuZCA9IDM1O1xuY29uc3QgaG9tZSA9IDM2O1xuY29uc3QgYXJyb3dMZWZ0ID0gMzc7XG5jb25zdCBhcnJvd1VwID0gMzg7XG5jb25zdCBhcnJvd1JpZ2h0ID0gMzk7XG5jb25zdCBhcnJvd0Rvd24gPSA0MDtcblxuY29uc3QgcHJldmVudGVkS2V5cyA9IHtcbiAgW2VudGVyXTogdHJ1ZSxcbiAgW3RhYl06IHRydWVcbn07XG52YXIgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzID0gZXZlbnQgPT4ge1xuICBpZiAocHJldmVudGVkS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmNvbnN0IHN1cHBvcnRlZEV2ZW50TmFtZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtiYXNlLCBgbXMke2Jhc2V9YCwgYHdlYmtpdCR7YmFzZX1gLCBgbW96JHtiYXNlfWAsIGBvJHtiYXNlfWBdO1xuICBjb25zdCBzdXBwb3J0ZWQgPSBjYW5kaWRhdGVzLmZpbmQoZXZlbnROYW1lID0+IGBvbiR7ZXZlbnROYW1lfWAgaW4gZG9jdW1lbnQpO1xuICByZXR1cm4gc3VwcG9ydGVkIHx8IGJhc2U7XG59KSgpO1xuXG5jb25zdCBwcmltYXJ5QnV0dG9uID0gMDtcbmNvbnN0IHNsb3BweUNsaWNrVGhyZXNob2xkID0gNTtcbmZ1bmN0aW9uIGlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChvcmlnaW5hbCwgY3VycmVudCkge1xuICByZXR1cm4gTWF0aC5hYnMoY3VycmVudC54IC0gb3JpZ2luYWwueCkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQgfHwgTWF0aC5hYnMoY3VycmVudC55IC0gb3JpZ2luYWwueSkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQ7XG59XG5jb25zdCBpZGxlJDEgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmZ1bmN0aW9uIGdldENhcHR1cmVCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgY29tcGxldGVkLFxuICBnZXRQaGFzZSxcbiAgc2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vtb3ZlJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBidXR0b24sXG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGlmIChidXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYmUgSURMRScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBwZW5kaW5nID0gcGhhc2UucG9pbnQ7XG4gICAgICBpZiAoIWlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChwZW5kaW5nLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwb2ludCk7XG4gICAgICBzZXRQaGFzZSh7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGFjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiAoKSA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZU1vdXNlU2Vuc29yKGFwaSkge1xuICBjb25zdCBwaGFzZVJlZiA9IHVzZVJlZihpZGxlJDEpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGFwaS5maW5kT3B0aW9uc0ZvckRyYWdnYWJsZShpZCk7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhcGkuY2FuR2V0TG9jayhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gaWRsZSQxO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xuICBjb25zdCBjYW5jZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgcGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIHN0b3AoKTtcbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIGNvbnN0IGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0Q2FwdHVyZUJpbmRpbmdzKHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiAoKSA9PiBwaGFzZVJlZi5jdXJyZW50LFxuICAgICAgc2V0UGhhc2U6IHBoYXNlID0+IHtcbiAgICAgICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGJpbmRpbmdzLCBvcHRpb25zKTtcbiAgfSwgW2NhbmNlbCwgc3RvcF0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEocGhhc2VSZWYuY3VycmVudC50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0ge1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zXG4gICAgfTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuY29uc3Qgc2Nyb2xsSnVtcEtleXMgPSB7XG4gIFtwYWdlRG93bl06IHRydWUsXG4gIFtwYWdlVXBdOiB0cnVlLFxuICBbaG9tZV06IHRydWUsXG4gIFtlbmRdOiB0cnVlXG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSB7XG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5jYW5jZWwoKTtcbiAgfVxuICBmdW5jdGlvbiBkcm9wKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmRyb3AoKTtcbiAgfVxuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IHNwYWNlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRyb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93RG93bikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVEb3duKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1VwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1JpZ2h0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVJpZ2h0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0xlZnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlTGVmdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsSnVtcEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3doZWVsJyxcbiAgICBmbjogY2FuY2VsLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlS2V5Ym9hcmRTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDEpO1xuICBjb25zdCBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSBzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlRHJhZyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIXByZURyYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBpc0NhcHR1cmluZyA9IHRydWU7XG4gICAgICBjb25zdCBhY3Rpb25zID0gcHJlRHJhZy5zbmFwTGlmdCgpO1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICFpc0NhcHR1cmluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGNhcHR1cmluZyBhIGtleWJvYXJkIGRyYWcgd2hlbiBub3QgY2FwdHVyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgICAgaXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgICAgfVxuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U3RhcnRDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICB9O1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xufVxuXG5jb25zdCBpZGxlID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5jb25zdCB0aW1lRm9yTG9uZ1ByZXNzID0gMTIwO1xuY29uc3QgZm9yY2VQcmVzc1RocmVzaG9sZCA9IDAuMTU7XG5mdW5jdGlvbiBnZXRXaW5kb3dCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgZ2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnb3JpZW50YXRpb25jaGFuZ2UnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY29udGV4dG1lbnUnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwaGFzZS5oYXNNb3ZlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGVuZCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hjYW5jZWwnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hmb3JjZWNoYW5nZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBpZiAoIXRvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRm9yY2VQcmVzcyA9IHRvdWNoLmZvcmNlID49IGZvcmNlUHJlc3NUaHJlc2hvbGQ7XG4gICAgICBpZiAoIWlzRm9yY2VQcmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGRSZXNwZWN0ID0gcGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgIGlmIChwaGFzZS5oYXNNb3ZlZCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VUb3VjaFNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSk7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDIpO1xuICBjb25zdCBnZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGdldFBoYXNlKCkge1xuICAgIHJldHVybiBwaGFzZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gdG91Y2g7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnQubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgfVxuICAgIHNldFBoYXNlKGlkbGUpO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2VcbiAgICB9O1xuICAgIGNvbnN0IHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5iaW5kV2luZG93ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldFdpbmRvd0JpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoKSB7XG4gICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlICR7cGhhc2UudHlwZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwaGFzZS5wb2ludCk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBoYXNNb3ZlZDogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2dldFBoYXNlLCBzZXRQaGFzZV0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEoZ2V0UGhhc2UoKS50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsb25nUHJlc3NUaW1lcklkID0gc2V0VGltZW91dChzdGFydERyYWdnaW5nLCB0aW1lRm9yTG9uZ1ByZXNzKTtcbiAgICBzZXRQaGFzZSh7XG4gICAgICB0eXBlOiAnUEVORElORycsXG4gICAgICBwb2ludCxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBsb25nUHJlc3NUaW1lcklkXG4gICAgfSk7XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50cywgZ2V0UGhhc2UsIHNldFBoYXNlLCBzdGFydERyYWdnaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZ2V0UGhhc2UsIGxpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gd2Via2l0SGFjaygpIHtcbiAgICBjb25zdCB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgICBmbjogKCkgPT4ge30sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gdW5iaW5kO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRlU2Vuc29ySG9va3Moc2Vuc29ySG9va3MpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKHNlbnNvckhvb2tzKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShwcmV2aW91c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gc2Vuc29ySG9va3MubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjaGFuZ2UgdGhlIGFtb3VudCBvZiBzZW5zb3IgaG9va3MgYWZ0ZXIgbW91bnRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBpbnRlcmFjdGl2ZVRhZ05hbWVzID0gWydpbnB1dCcsICdidXR0b24nLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ29wdGlvbicsICdvcHRncm91cCcsICd2aWRlbycsICdhdWRpbyddO1xuZnVuY3Rpb24gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQpIHtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNBbkludGVyYWN0aXZlVGFnID0gaW50ZXJhY3RpdmVUYWdOYW1lcy5pbmNsdWRlcyhjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGlmIChoYXNBbkludGVyYWN0aXZlVGFnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICBpZiAoYXR0cmlidXRlID09PSAndHJ1ZScgfHwgYXR0cmlidXRlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50ID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xufVxuZnVuY3Rpb24gaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChkcmFnZ2FibGUsIHRhcmdldCk7XG59XG5cbnZhciBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiA9IGVsID0+IGdldFJlY3QoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLmNlbnRlcjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuRWxlbWVudDtcbn1cblxuY29uc3Qgc3VwcG9ydGVkTWF0Y2hlc05hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ21hdGNoZXMnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvciddO1xuICBjb25zdCB2YWx1ZSA9IGNhbmRpZGF0ZXMuZmluZChuYW1lID0+IG5hbWUgaW4gRWxlbWVudC5wcm90b3R5cGUpO1xuICByZXR1cm4gdmFsdWUgfHwgYmFzZTtcbn0pKCk7XG5mdW5jdGlvbiBjbG9zZXN0UG9ueWZpbGwoZWwsIHNlbGVjdG9yKSB7XG4gIGlmIChlbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsW3N1cHBvcnRlZE1hdGNoZXNOYW1lXShzZWxlY3RvcikpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbC5wYXJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBjbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwuY2xvc2VzdCkge1xuICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgfVxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbnRleHRJZCkge1xuICByZXR1cm4gYFske2RyYWdIYW5kbGUuY29udGV4dElkfT1cIiR7Y29udGV4dElkfVwiXWA7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdldmVudC50YXJnZXQgbXVzdCBiZSBhIEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIGNvbnN0IGhhbmRsZSA9IGNsb3Nlc3QodGFyZ2V0LCBzZWxlY3Rvcik7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBtdXN0IGJlIGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgaGFuZGxlID0gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYW5kbGUuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpO1xufVxuXG5mdW5jdGlvbiBmaW5kRHJhZ2dhYmxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ2dhYmxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xuICBjb25zdCBwb3NzaWJsZSA9IHF1ZXJ5U2VsZWN0b3JBbGwoZG9jdW1lbnQsIHNlbGVjdG9yKTtcbiAgY29uc3QgZHJhZ2dhYmxlJDEgPSBwb3NzaWJsZS5maW5kKGVsID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZS5pZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcbiAgaWYgKCFkcmFnZ2FibGUkMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChkcmFnZ2FibGUkMSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdEcmFnZ2FibGUgZWxlbWVudCBpcyBub3QgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBkcmFnZ2FibGUkMTtcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIGlzQWN0aXZlKHtcbiAgZXhwZWN0ZWQsXG4gIHBoYXNlLFxuICBpc0xvY2tBY3RpdmUsXG4gIHNob3VsZFdhcm5cbn0pIHtcbiAgaWYgKCFpc0xvY2tBY3RpdmUoKSkge1xuICAgIGlmIChzaG91bGRXYXJuKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxuICAgICAgICBUaGUgc2Vuc29yIG5vIGxvbmdlciBoYXMgYW4gYWN0aW9uIGxvY2suXG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIFRocm93IGF3YXkgeW91ciBhY3Rpb24gaGFuZGxlcnMgd2hlbiBmb3JjZVN0b3AoKSBpcyBjYWxsZWRcbiAgICAgICAgLSBDaGVjayBhY3Rpb25zLmlzQWN0aXZlKCkgaWYgeW91IHJlYWxseSBuZWVkIHRvXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChleHBlY3RlZCAhPT0gcGhhc2UpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIGFjdGlvbnMgeW91IHVzZWQgYmVsb25nIHRvIGFuIG91dGRhdGVkIHBoYXNlXG5cbiAgICAgICAgQ3VycmVudCBwaGFzZTogJHtleHBlY3RlZH1cbiAgICAgICAgWW91IGNhbGxlZCBhbiBhY3Rpb24gZnJvbSBvdXRkYXRlZCBwaGFzZTogJHtwaGFzZX1cblxuICAgICAgICBUaXBzOlxuXG4gICAgICAgIC0gRG8gbm90IHVzZSBwcmVEcmFnQWN0aW9ucyBhY3Rpb25zIGFmdGVyIGNhbGxpbmcgcHJlRHJhZ0FjdGlvbnMubGlmdCgpXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2FuU3RhcnQoe1xuICBsb2NrQVBJLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGRyYWdnYWJsZUlkXG59KSB7XG4gIGlmIChsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSB3aXRoIGlkOiAke2RyYWdnYWJsZUlkfWApIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVudHJ5Lm9wdGlvbnMuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghY2FuU3RhcnREcmFnKHN0b3JlLmdldFN0YXRlKCksIGRyYWdnYWJsZUlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRyeVN0YXJ0KHtcbiAgbG9ja0FQSSxcbiAgY29udGV4dElkLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGRyYWdnYWJsZUlkLFxuICBmb3JjZVNlbnNvclN0b3AsXG4gIHNvdXJjZUV2ZW50XG59KSB7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gY2FuU3RhcnQoe1xuICAgIGxvY2tBUEksXG4gICAgc3RvcmUsXG4gICAgcmVnaXN0cnksXG4gICAgZHJhZ2dhYmxlSWRcbiAgfSk7XG4gIGlmICghc2hvdWxkU3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgY29uc3QgZWwgPSBmaW5kRHJhZ2dhYmxlKGNvbnRleHRJZCwgZW50cnkuZGVzY3JpcHRvci5pZCk7XG4gIGlmICghZWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgZWxlbWVudCB3aXRoIGlkOiAke2RyYWdnYWJsZUlkfWApIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzb3VyY2VFdmVudCAmJiAhZW50cnkub3B0aW9ucy5jYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyAmJiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZWwsIHNvdXJjZUV2ZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxvY2sgPSBsb2NrQVBJLmNsYWltKGZvcmNlU2Vuc29yU3RvcCB8fCBub29wJDIpO1xuICBsZXQgcGhhc2UgPSAnUFJFX0RSQUcnO1xuICBmdW5jdGlvbiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpIHtcbiAgICByZXR1cm4gZW50cnkub3B0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcztcbiAgfVxuICBmdW5jdGlvbiBpc0xvY2tBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGxvY2tBUEkuaXNBY3RpdmUobG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5RGlzcGF0Y2goZXhwZWN0ZWQsIGdldEFjdGlvbikge1xuICAgIGlmIChpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZCxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChnZXRBY3Rpb24oKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nID0gdHJ5RGlzcGF0Y2guYmluZChudWxsLCAnRFJBR0dJTkcnKTtcbiAgZnVuY3Rpb24gbGlmdChhcmdzKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgbG9ja0FQSS5yZWxlYXNlKCk7XG4gICAgICBwaGFzZSA9ICdDT01QTEVURUQnO1xuICAgIH1cbiAgICBpZiAocGhhc2UgIT09ICdQUkVfRFJBRycpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGxpZnQgaW4gcGhhc2UgJHtwaGFzZX1gKSA6IGludmFyaWFudCgpIDtcbiAgICB9XG4gICAgc3RvcmUuZGlzcGF0Y2gobGlmdCQxKGFyZ3MubGlmdEFjdGlvbkFyZ3MpKTtcbiAgICBwaGFzZSA9ICdEUkFHR0lORyc7XG4gICAgZnVuY3Rpb24gZmluaXNoKHJlYXNvbiwgb3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiBmYWxzZVxuICAgIH0pIHtcbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkQmxvY2tOZXh0Q2xpY2spIHtcbiAgICAgICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcCh7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6ICgpID0+IGlzQWN0aXZlKHtcbiAgICAgICAgZXhwZWN0ZWQ6ICdEUkFHR0lORycsXG4gICAgICAgIHBoYXNlLFxuICAgICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGRyb3A6IG9wdGlvbnMgPT4gZmluaXNoKCdEUk9QJywgb3B0aW9ucyksXG4gICAgICBjYW5jZWw6IG9wdGlvbnMgPT4gZmluaXNoKCdDQU5DRUwnLCBvcHRpb25zKSxcbiAgICAgIC4uLmFyZ3MuYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmx1aWRMaWZ0KGNsaWVudFNlbGVjdGlvbikge1xuICAgIGNvbnN0IG1vdmUkMSA9IHJhZlNjaGQoY2xpZW50ID0+IHtcbiAgICAgIHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKCgpID0+IG1vdmUoe1xuICAgICAgICBjbGllbnRcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcGkgPSBsaWZ0KHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdGTFVJRCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiAoKSA9PiBtb3ZlJDEuY2FuY2VsKCksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIG1vdmU6IG1vdmUkMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hcGksXG4gICAgICBtb3ZlOiBtb3ZlJDFcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNuYXBMaWZ0KCkge1xuICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICBtb3ZlVXA6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVVcCksXG4gICAgICBtb3ZlUmlnaHQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVSaWdodCksXG4gICAgICBtb3ZlRG93bjogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZURvd24pLFxuICAgICAgbW92ZUxlZnQ6ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVMZWZ0KVxuICAgIH07XG4gICAgcmV0dXJuIGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb246IGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uKGVsKSxcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnU05BUCdcbiAgICAgIH0sXG4gICAgICBjbGVhbnVwOiBub29wJDIsXG4gICAgICBhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRQcmVEcmFnKCkge1xuICAgIGNvbnN0IHNob3VsZFJlbGVhc2UgPSBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChzaG91bGRSZWxlYXNlKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJlRHJhZyA9IHtcbiAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgfSksXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGZsdWlkTGlmdCxcbiAgICBzbmFwTGlmdCxcbiAgICBhYm9ydDogYWJvcnRQcmVEcmFnXG4gIH07XG4gIHJldHVybiBwcmVEcmFnO1xufVxuY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbdXNlTW91c2VTZW5zb3IsIHVzZUtleWJvYXJkU2Vuc29yLCB1c2VUb3VjaFNlbnNvcl07XG5mdW5jdGlvbiB1c2VTZW5zb3JNYXJzaGFsKHtcbiAgY29udGV4dElkLFxuICBzdG9yZSxcbiAgcmVnaXN0cnksXG4gIGN1c3RvbVNlbnNvcnMsXG4gIGVuYWJsZURlZmF1bHRTZW5zb3JzXG59KSB7XG4gIGNvbnN0IHVzZVNlbnNvcnMgPSBbLi4uKGVuYWJsZURlZmF1bHRTZW5zb3JzID8gZGVmYXVsdFNlbnNvcnMgOiBbXSksIC4uLihjdXN0b21TZW5zb3JzIHx8IFtdKV07XG4gIGNvbnN0IGxvY2tBUEkgPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGUoKSlbMF07XG4gIGNvbnN0IHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAoaXNEcmFnZ2luZyhwcmV2aW91cykgJiYgIWlzRHJhZ2dpbmcoY3VycmVudCkpIHtcbiAgICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEldKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBsaXN0ZW5Ub1N0b3JlKCkge1xuICAgIGxldCBwcmV2aW91cyA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCk7XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbG9ja0FQSSwgc3RvcmUsIHRyeUFiYW5kb25Mb2NrXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBsb2NrQVBJLnRyeUFiYW5kb247XG4gIH0sIFtsb2NrQVBJLnRyeUFiYW5kb25dKTtcbiAgY29uc3QgY2FuR2V0TG9jayA9IHVzZUNhbGxiYWNrKGRyYWdnYWJsZUlkID0+IHtcbiAgICByZXR1cm4gY2FuU3RhcnQoe1xuICAgICAgbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgc3RvcmUsXG4gICAgICBkcmFnZ2FibGVJZFxuICAgIH0pO1xuICB9LCBbbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IHRyeUdldExvY2sgPSB1c2VDYWxsYmFjaygoZHJhZ2dhYmxlSWQsIGZvcmNlU3RvcCwgb3B0aW9ucykgPT4gdHJ5U3RhcnQoe1xuICAgIGxvY2tBUEksXG4gICAgcmVnaXN0cnksXG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGZvcmNlU2Vuc29yU3RvcDogZm9yY2VTdG9wIHx8IG51bGwsXG4gICAgc291cmNlRXZlbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VFdmVudCA/IG9wdGlvbnMuc291cmNlRXZlbnQgOiBudWxsXG4gIH0pLCBbY29udGV4dElkLCBsb2NrQVBJLCByZWdpc3RyeSwgc3RvcmVdKTtcbiAgY29uc3QgZmluZENsb3Nlc3REcmFnZ2FibGVJZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChpZCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnkub3B0aW9ucyA6IG51bGw7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgY29uc3QgdHJ5UmVsZWFzZUxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWxlYXNlTG9jaygpIHtcbiAgICBpZiAoIWxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgaWYgKHN0b3JlLmdldFN0YXRlKCkucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbbG9ja0FQSSwgc3RvcmVdKTtcbiAgY29uc3QgaXNMb2NrQ2xhaW1lZCA9IHVzZUNhbGxiYWNrKCgpID0+IGxvY2tBUEkuaXNDbGFpbWVkKCksIFtsb2NrQVBJXSk7XG4gIGNvbnN0IGFwaSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5HZXRMb2NrLFxuICAgIHRyeUdldExvY2ssXG4gICAgZmluZENsb3Nlc3REcmFnZ2FibGVJZCxcbiAgICBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSxcbiAgICB0cnlSZWxlYXNlTG9jayxcbiAgICBpc0xvY2tDbGFpbWVkXG4gIH0pLCBbY2FuR2V0TG9jaywgdHJ5R2V0TG9jaywgZmluZENsb3Nlc3REcmFnZ2FibGVJZCwgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsIHRyeVJlbGVhc2VMb2NrLCBpc0xvY2tDbGFpbWVkXSk7XG4gIHVzZVZhbGlkYXRlU2Vuc29ySG9va3ModXNlU2Vuc29ycyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlU2Vuc29ycy5sZW5ndGg7IGkrKykge1xuICAgIHVzZVNlbnNvcnNbaV0oYXBpKTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSZXNwb25kZXJzID0gcHJvcHMgPT4gKHtcbiAgb25CZWZvcmVDYXB0dXJlOiB0ID0+IHtcbiAgICBjb25zdCBvbkJlZm9yZUNhcHVyZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHByb3BzLm9uQmVmb3JlQ2FwdHVyZSkge1xuICAgICAgICBwcm9wcy5vbkJlZm9yZUNhcHR1cmUodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmbHVzaFN5bmMob25CZWZvcmVDYXB1cmVDYWxsYmFjayk7XG4gIH0sXG4gIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgb25EcmFnVXBkYXRlOiBwcm9wcy5vbkRyYWdVcGRhdGVcbn0pO1xuY29uc3QgY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyA9IHByb3BzID0+ICh7XG4gIC4uLmRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zLFxuICAuLi5wcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zLFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIC4uLmRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLFxuICAgIC4uLnByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfVxufSk7XG5mdW5jdGlvbiBnZXRTdG9yZShsYXp5UmVmKSB7XG4gICFsYXp5UmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzdG9yZSBmcm9tIGxhenkgcmVmJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxhenlSZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIEFwcChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIHNldENhbGxiYWNrcyxcbiAgICBzZW5zb3JzLFxuICAgIG5vbmNlLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxhenlTdG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlU3RhcnR1cFZhbGlkYXRpb24oKTtcbiAgY29uc3QgbGFzdFByb3BzUmVmID0gdXNlUHJldmlvdXMocHJvcHMpO1xuICBjb25zdCBnZXRSZXNwb25kZXJzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVSZXNwb25kZXJzKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUFubm91bmNlcihjb250ZXh0SWQpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCA9IHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgICBjb250ZXh0SWQsXG4gICAgdGV4dDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0pO1xuICBjb25zdCBzdHlsZU1hcnNoYWwgPSB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSk7XG4gIGNvbnN0IGxhenlEaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGFjdGlvbiA9PiB7XG4gICAgZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5kaXNwYXRjaChhY3Rpb24pO1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWxDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+IGJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgcHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIGNvbGxlY3Rpb25TdGFydGluZ1xuICB9LCBsYXp5RGlzcGF0Y2gpLCBbbGF6eURpc3BhdGNoXSk7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlUmVnaXN0cnkoKTtcbiAgY29uc3QgZGltZW5zaW9uTWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVEaW1lbnNpb25NYXJzaGFsKHJlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzKTtcbiAgfSwgW3JlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzXSk7XG4gIGNvbnN0IGF1dG9TY3JvbGxlciA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlQXV0b1Njcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlOiBkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zLFxuICAgIC4uLmJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgICBtb3ZlXG4gICAgfSwgbGF6eURpc3BhdGNoKVxuICB9KSwgW2RpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLCBsYXp5RGlzcGF0Y2gsIGdldEF1dG9TY3JvbGxlck9wdGlvbnNdKTtcbiAgY29uc3QgZm9jdXNNYXJzaGFsID0gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCk7XG4gIGNvbnN0IHN0b3JlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgYW5ub3VuY2UsXG4gICAgYXV0b1Njcm9sbGVyLFxuICAgIGRpbWVuc2lvbk1hcnNoYWwsXG4gICAgZm9jdXNNYXJzaGFsLFxuICAgIGdldFJlc3BvbmRlcnMsXG4gICAgc3R5bGVNYXJzaGFsXG4gIH0pLCBbYW5ub3VuY2UsIGF1dG9TY3JvbGxlciwgZGltZW5zaW9uTWFyc2hhbCwgZm9jdXNNYXJzaGFsLCBnZXRSZXNwb25kZXJzLCBzdHlsZU1hcnNoYWxdKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobGF6eVN0b3JlUmVmLmN1cnJlbnQgJiYgbGF6eVN0b3JlUmVmLmN1cnJlbnQgIT09IHN0b3JlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCd1bmV4cGVjdGVkIHN0b3JlIGNoYW5nZScpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBsYXp5U3RvcmVSZWYuY3VycmVudCA9IHN0b3JlO1xuICBjb25zdCB0cnlSZXNldFN0b3JlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRTdG9yZShsYXp5U3RvcmVSZWYpO1xuICAgIGNvbnN0IHN0YXRlID0gY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0lETEUnKSB7XG4gICAgICBjdXJyZW50LmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBpc0RyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nO1xuICB9LCBbXSk7XG4gIGNvbnN0IGFwcENhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nLFxuICAgIHRyeUFib3J0OiB0cnlSZXNldFN0b3JlXG4gIH0pLCBbaXNEcmFnZ2luZywgdHJ5UmVzZXRTdG9yZV0pO1xuICBzZXRDYWxsYmFja3MoYXBwQ2FsbGJhY2tzKTtcbiAgY29uc3QgZ2V0Q2FuTGlmdCA9IHVzZUNhbGxiYWNrKGlkID0+IGNhblN0YXJ0RHJhZyhnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCksIGlkKSwgW10pO1xuICBjb25zdCBnZXRJc01vdmVtZW50QWxsb3dlZCA9IHVzZUNhbGxiYWNrKCgpID0+IGlzTW92ZW1lbnRBbGxvd2VkKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSksIFtdKTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBtYXJzaGFsOiBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzOiBmb2N1c01hcnNoYWwsXG4gICAgY29udGV4dElkLFxuICAgIGNhbkxpZnQ6IGdldENhbkxpZnQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWQ6IGdldElzTW92ZW1lbnRBbGxvd2VkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0pLCBbY29udGV4dElkLCBkaW1lbnNpb25NYXJzaGFsLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZm9jdXNNYXJzaGFsLCBnZXRDYW5MaWZ0LCBnZXRJc01vdmVtZW50QWxsb3dlZCwgcmVnaXN0cnldKTtcbiAgdXNlU2Vuc29yTWFyc2hhbCh7XG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGN1c3RvbVNlbnNvcnM6IHNlbnNvcnMgfHwgbnVsbCxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMgIT09IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiB0cnlSZXNldFN0b3JlO1xuICB9LCBbdHJ5UmVzZXRTdG9yZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwcENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwge1xuICAgIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgICBzdG9yZTogc3RvcmVcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxuZnVuY3Rpb24gdXNlVW5pcXVlQ29udGV4dElkKCkge1xuICByZXR1cm4gUmVhY3QudXNlSWQoKTtcbn1cblxuZnVuY3Rpb24gRHJhZ0Ryb3BDb250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRJZCA9IHVzZVVuaXF1ZUNvbnRleHRJZCgpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBwcm9wcy5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgfHwgcHJlc2V0LmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCwgc2V0Q2FsbGJhY2tzID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwLCB7XG4gICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIHNldENhbGxiYWNrczogc2V0Q2FsbGJhY2tzLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uczogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyxcbiAgICBzZW5zb3JzOiBwcm9wcy5zZW5zb3JzLFxuICAgIG9uQmVmb3JlQ2FwdHVyZTogcHJvcHMub25CZWZvcmVDYXB0dXJlLFxuICAgIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gICAgb25EcmFnVXBkYXRlOiBwcm9wcy5vbkRyYWdVcGRhdGUsXG4gICAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmQsXG4gICAgYXV0b1Njcm9sbGVyT3B0aW9uczogcHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuXG5jb25zdCB6SW5kZXhPcHRpb25zID0ge1xuICBkcmFnZ2luZzogNTAwMCxcbiAgZHJvcEFuaW1hdGluZzogNDUwMFxufTtcbmNvbnN0IGdldERyYWdnaW5nVHJhbnNpdGlvbiA9IChzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50LCBkcm9wcGluZykgPT4ge1xuICBpZiAoZHJvcHBpbmcpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuZHJvcChkcm9wcGluZy5kdXJhdGlvbik7XG4gIH1cbiAgaWYgKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuc25hcDtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbnMuZmx1aWQ7XG59O1xuY29uc3QgZ2V0RHJhZ2dpbmdPcGFjaXR5ID0gKGlzQ29tYmluaW5nLCBpc0Ryb3BBbmltYXRpbmcpID0+IHtcbiAgaWYgKCFpc0NvbWJpbmluZykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGlzRHJvcEFuaW1hdGluZyA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogY29tYmluZS5vcGFjaXR5LmNvbWJpbmluZztcbn07XG5jb25zdCBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUgPSBkcmFnZ2luZyA9PiB7XG4gIGlmIChkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cbiAgcmV0dXJuIGRyYWdnaW5nLm1vZGUgPT09ICdTTkFQJztcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2luZ1N0eWxlKGRyYWdnaW5nKSB7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGRyYWdnaW5nLmRpbWVuc2lvbjtcbiAgY29uc3QgYm94ID0gZGltZW5zaW9uLmNsaWVudDtcbiAgY29uc3Qge1xuICAgIG9mZnNldCxcbiAgICBjb21iaW5lV2l0aCxcbiAgICBkcm9wcGluZ1xuICB9ID0gZHJhZ2dpbmc7XG4gIGNvbnN0IGlzQ29tYmluaW5nID0gQm9vbGVhbihjb21iaW5lV2l0aCk7XG4gIGNvbnN0IHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUoZHJhZ2dpbmcpO1xuICBjb25zdCBpc0Ryb3BBbmltYXRpbmcgPSBCb29sZWFuKGRyb3BwaW5nKTtcbiAgY29uc3QgdHJhbnNmb3JtID0gaXNEcm9wQW5pbWF0aW5nID8gdHJhbnNmb3Jtcy5kcm9wKG9mZnNldCwgaXNDb21iaW5pbmcpIDogdHJhbnNmb3Jtcy5tb3ZlVG8ob2Zmc2V0KTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgdG9wOiBib3gubWFyZ2luQm94LnRvcCxcbiAgICBsZWZ0OiBib3gubWFyZ2luQm94LmxlZnQsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGJveC5ib3JkZXJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiBib3guYm9yZGVyQm94LmhlaWdodCxcbiAgICB0cmFuc2l0aW9uOiBnZXREcmFnZ2luZ1RyYW5zaXRpb24oc2hvdWxkQW5pbWF0ZSwgZHJvcHBpbmcpLFxuICAgIHRyYW5zZm9ybSxcbiAgICBvcGFjaXR5OiBnZXREcmFnZ2luZ09wYWNpdHkoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZyksXG4gICAgekluZGV4OiBpc0Ryb3BBbmltYXRpbmcgPyB6SW5kZXhPcHRpb25zLmRyb3BBbmltYXRpbmcgOiB6SW5kZXhPcHRpb25zLmRyYWdnaW5nLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICB9O1xuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTdHlsZShzZWNvbmRhcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXMubW92ZVRvKHNlY29uZGFyeS5vZmZzZXQpLFxuICAgIHRyYW5zaXRpb246IHNlY29uZGFyeS5zaG91bGRBbmltYXRlRGlzcGxhY2VtZW50ID8gdW5kZWZpbmVkIDogJ25vbmUnXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdHlsZSQxKG1hcHBlZCkge1xuICByZXR1cm4gbWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycgPyBnZXREcmFnZ2luZ1N0eWxlKG1hcHBlZCkgOiBnZXRTZWNvbmRhcnlTdHlsZShtYXBwZWQpO1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsID0gb3JpZ2luKSB7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY2xpZW50ID0gY2FsY3VsYXRlQm94KGJvcmRlckJveCwgY29tcHV0ZWRTdHlsZXMpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgIGNsaWVudCxcbiAgICB0YWdOYW1lOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZGlzcGxheTogY29tcHV0ZWRTdHlsZXMuZGlzcGxheVxuICB9O1xuICBjb25zdCBkaXNwbGFjZUJ5ID0ge1xuICAgIHg6IGNsaWVudC5tYXJnaW5Cb3gud2lkdGgsXG4gICAgeTogY2xpZW50Lm1hcmdpbkJveC5oZWlnaHRcbiAgfTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgZGlzcGxhY2VCeSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoYXJncykge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcmFnZ2FibGUnKTtcbiAgY29uc3Qge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcmVnaXN0cnksXG4gICAgZ2V0RHJhZ2dhYmxlUmVmLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGlzRW5hYmxlZFxuICB9ID0gYXJncztcbiAgY29uc3Qgb3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSksIFtjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgaXNFbmFibGVkLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc10pO1xuICBjb25zdCBnZXREaW1lbnNpb24gPSB1c2VDYWxsYmFjayh3aW5kb3dTY3JvbGwgPT4ge1xuICAgIGNvbnN0IGVsID0gZ2V0RHJhZ2dhYmxlUmVmKCk7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBkaW1lbnNpb24gd2hlbiBubyByZWYgaXMgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCk7XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREcmFnZ2FibGVSZWZdKTtcbiAgY29uc3QgZW50cnkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgdW5pcXVlSWQsXG4gICAgZGVzY3JpcHRvcixcbiAgICBvcHRpb25zLFxuICAgIGdldERpbWVuc2lvblxuICB9KSwgW2Rlc2NyaXB0b3IsIGdldERpbWVuc2lvbiwgb3B0aW9ucywgdW5pcXVlSWRdKTtcbiAgY29uc3QgcHVibGlzaGVkUmVmID0gdXNlUmVmKGVudHJ5KTtcbiAgY29uc3QgaXNGaXJzdFB1Ymxpc2hSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS51bnJlZ2lzdGVyKHB1Ymxpc2hlZFJlZi5jdXJyZW50KTtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCkge1xuICAgICAgaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gcHVibGlzaGVkUmVmLmN1cnJlbnQ7XG4gICAgcHVibGlzaGVkUmVmLmN1cnJlbnQgPSBlbnRyeTtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUudXBkYXRlKGVudHJ5LCBsYXN0KTtcbiAgfSwgW2VudHJ5LCByZWdpc3RyeS5kcmFnZ2FibGVdKTtcbn1cblxudmFyIERyb3BwYWJsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBjaGVja0lzVmFsaWRJbm5lclJlZihlbCkge1xuICAhKGVsICYmIGlzSHRtbEVsZW1lbnQoZWwpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFxuICAgIHByb3ZpZGVkLmlubmVyUmVmIGhhcyBub3QgYmVlbiBwcm92aWRlZCB3aXRoIGEgSFRNTEVsZW1lbnQuXG5cbiAgICBZb3UgY2FuIGZpbmQgYSBndWlkZSBvbiB1c2luZyB0aGUgaW5uZXJSZWYgY2FsbGJhY2sgZnVuY3Rpb25zIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy91c2luZy1pbm5lci1yZWYubWRcbiAgYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZikge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHByZWZpeChpZCkge1xuICAgICAgcmV0dXJuIGBEcmFnZ2FibGVbaWQ6ICR7aWR9XTogYDtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBwcm9wcy5kcmFnZ2FibGVJZDtcbiAgICAhaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgcmVxdWlyZXMgYSBkcmFnZ2FibGVJZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgRHJhZ2dhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJhZ2dhYmxlSWQuXG4gICAgICBQcm92aWRlZDogW3R5cGU6ICR7dHlwZW9mIGlkfV0gKHZhbHVlOiAke2lkfSlgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIU51bWJlci5pc0ludGVnZXIocHJvcHMuaW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSByZXF1aXJlcyBhbiBpbnRlZ2VyIGluZGV4IHByb3BgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldFJlZigpKTtcbiAgICBpZiAocHJvcHMuaXNFbmFibGVkKSB7XG4gICAgICAhZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke3ByZWZpeChpZCl9IFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVmID0gdXNlUmVmKGlzQ2xvbmUpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKGlzQ2xvbmUgPT09IGluaXRpYWxSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgaXNDbG9uZSBwcm9wIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbXBvbmVudCBsaWZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0sIFtpc0Nsb25lXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXF1aXJlZENvbnRleHQoQ29udGV4dCkge1xuICBjb25zdCByZXN1bHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAhcmVzdWx0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgcmVxdWlyZWQgY29udGV4dCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRIdG1sNURuZChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuY29uc3QgRHJhZ2dhYmxlID0gcHJvcHMgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKChlbCA9IG51bGwpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgcmVnaXN0cnlcbiAgfSA9IHVzZVJlcXVpcmVkQ29udGV4dChBcHBDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZHJvcHBhYmxlSWRcbiAgfSA9IHVzZVJlcXVpcmVkQ29udGV4dChEcm9wcGFibGVDb250ZXh0KTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZDogcHJvcHMuZHJhZ2dhYmxlSWQsXG4gICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgIHR5cGUsXG4gICAgZHJvcHBhYmxlSWRcbiAgfSksIFtwcm9wcy5kcmFnZ2FibGVJZCwgcHJvcHMuaW5kZXgsIHR5cGUsIGRyb3BwYWJsZUlkXSk7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBpc0VuYWJsZWQsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgaXNDbG9uZSxcbiAgICBtYXBwZWQsXG4gICAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb25cbiAgfSA9IHByb3BzO1xuICB1c2VWYWxpZGF0aW9uJDEocHJvcHMsIGNvbnRleHRJZCwgZ2V0UmVmKTtcbiAgdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKTtcbiAgaWYgKCFpc0Nsb25lKSB7XG4gICAgY29uc3QgZm9yUHVibGlzaGVyID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgZ2V0RHJhZ2dhYmxlUmVmOiBnZXRSZWYsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSksIFtkZXNjcmlwdG9yLCByZWdpc3RyeSwgZ2V0UmVmLCBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsIGlzRW5hYmxlZF0pO1xuICAgIHVzZURyYWdnYWJsZVB1Ymxpc2hlcihmb3JQdWJsaXNoZXIpO1xuICB9XG4gIGNvbnN0IGRyYWdIYW5kbGVQcm9wcyA9IHVzZU1lbW8oKCkgPT4gaXNFbmFibGVkID8ge1xuICAgIHRhYkluZGV4OiAwLFxuICAgIHJvbGU6ICdidXR0b24nLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgJ2RhdGEtcmZkLWRyYWctaGFuZGxlLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICdkYXRhLXJmZC1kcmFnLWhhbmRsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgb25EcmFnU3RhcnQ6IHByZXZlbnRIdG1sNURuZFxuICB9IDogbnVsbCwgW2NvbnRleHRJZCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGRyYWdnYWJsZUlkLCBpc0VuYWJsZWRdKTtcbiAgY29uc3Qgb25Nb3ZlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChtYXBwZWQudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW1hcHBlZC5kcm9wcGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQucHJvcGVydHlOYW1lICE9PSAndHJhbnNmb3JtJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmbHVzaFN5bmMoZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uKTtcbiAgfSwgW2Ryb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbiwgbWFwcGVkXSk7XG4gIGNvbnN0IHByb3ZpZGVkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRTdHlsZSQxKG1hcHBlZCk7XG4gICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gbWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycgJiYgbWFwcGVkLmRyb3BwaW5nID8gb25Nb3ZlRW5kIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGlubmVyUmVmOiBzZXRSZWYsXG4gICAgICBkcmFnZ2FibGVQcm9wczoge1xuICAgICAgICAnZGF0YS1yZmQtZHJhZ2dhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgICAgICdkYXRhLXJmZC1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZFxuICAgICAgfSxcbiAgICAgIGRyYWdIYW5kbGVQcm9wc1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW2NvbnRleHRJZCwgZHJhZ0hhbmRsZVByb3BzLCBkcmFnZ2FibGVJZCwgbWFwcGVkLCBvbk1vdmVFbmQsIHNldFJlZl0pO1xuICBjb25zdCBydWJyaWMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZGVzY3JpcHRvci50eXBlLFxuICAgIHNvdXJjZToge1xuICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxuICAgIH1cbiAgfSksIFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkLCBkZXNjcmlwdG9yLmlkLCBkZXNjcmlwdG9yLmluZGV4LCBkZXNjcmlwdG9yLnR5cGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKHByb3ZpZGVkLCBtYXBwZWQuc25hcHNob3QsIHJ1YnJpYykpO1xufTtcblxudmFyIGlzU3RyaWN0RXF1YWwgPSAoYSwgYikgPT4gYSA9PT0gYjtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCA9IHJlc3VsdCA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21iaW5lLFxuICAgIGRlc3RpbmF0aW9uXG4gIH0gPSByZXN1bHQ7XG4gIGlmIChkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGltcGFjdCA9PiB7XG4gIHJldHVybiBpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyA/IGltcGFjdC5hdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGRyb3BwaW5nID0gbnVsbCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgIGlzQ2xvbmUsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBCb29sZWFuKGRyb3BwaW5nKSxcbiAgICBkcm9wQW5pbWF0aW9uOiBkcm9wcGluZyxcbiAgICBtb2RlLFxuICAgIGRyYWdnaW5nT3ZlcixcbiAgICBjb21iaW5lV2l0aCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsXG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgbW9kZSwgZGltZW5zaW9uLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIgPSBudWxsLCBjb21iaW5lV2l0aCA9IG51bGwsIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IG51bGwpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgZHJvcHBpbmc6IG51bGwsXG4gICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICBjb21iaW5lV2l0aCxcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXQsXG4gICAgICBkaW1lbnNpb24sXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBudWxsKVxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDbG9uZSA9IG93blByb3BzLmlzQ2xvbmU7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGNvbnN0IG1vZGUgPSByZXN1bHQubW9kZTtcbiAgICAgIGNvbnN0IGRyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gc3RhdGUuZHJvcER1cmF0aW9uO1xuICAgICAgY29uc3QgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBjdXJ2ZTogY3VydmVzLmRyb3AsXG4gICAgICAgIG1vdmVUbzogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgb3BhY2l0eTogY29tYmluZVdpdGggPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IG51bGwsXG4gICAgICAgIHNjYWxlOiBjb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmcsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGRyb3BwaW5nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U25hcHNob3QoY29tYmluZVRhcmdldEZvciA9IG51bGwpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IGZhbHNlLFxuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGRyb3BBbmltYXRpb246IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZ092ZXI6IG51bGwsXG4gICAgY29tYmluZVRhcmdldEZvcixcbiAgICBjb21iaW5lV2l0aDogbnVsbFxuICB9O1xufVxuY29uc3QgYXRSZXN0ID0ge1xuICBtYXBwZWQ6IHtcbiAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICBvZmZzZXQ6IG9yaWdpbixcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQ6IHRydWUsXG4gICAgc25hcHNob3Q6IGdldFNlY29uZGFyeVNuYXBzaG90KG51bGwpXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgY29uc3QgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKCh4LCB5KSA9PiAoe1xuICAgIHgsXG4gICAgeVxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGdldFNlY29uZGFyeVNuYXBzaG90KTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoKG9mZnNldCwgY29tYmluZVRhcmdldEZvciA9IG51bGwsIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQpID0+ICh7XG4gICAgbWFwcGVkOiB7XG4gICAgICB0eXBlOiAnU0VDT05EQVJZJyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50LFxuICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QoY29tYmluZVRhcmdldEZvcilcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0RmFsbGJhY2sgPSBjb21iaW5lVGFyZ2V0Rm9yID0+IHtcbiAgICByZXR1cm4gY29tYmluZVRhcmdldEZvciA/IGdldE1lbW9pemVkUHJvcHMob3JpZ2luLCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKSA6IG51bGw7XG4gIH07XG4gIGNvbnN0IGdldFByb3BzID0gKG93bklkLCBkcmFnZ2luZ0lkLCBpbXBhY3QsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgICBjb25zdCB2aXN1YWxEaXNwbGFjZW1lbnQgPSBpbXBhY3QuZGlzcGxhY2VkLnZpc2libGVbb3duSWRdO1xuICAgIGNvbnN0IGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QgPSBCb29sZWFuKGFmdGVyQ3JpdGljYWwuaW5WaXJ0dWFsTGlzdCAmJiBhZnRlckNyaXRpY2FsLmVmZmVjdGVkW293bklkXSk7XG4gICAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICBjb25zdCBjb21iaW5lVGFyZ2V0Rm9yID0gY29tYmluZSAmJiBjb21iaW5lLmRyYWdnYWJsZUlkID09PSBvd25JZCA/IGRyYWdnaW5nSWQgOiBudWxsO1xuICAgIGlmICghdmlzdWFsRGlzcGxhY2VtZW50KSB7XG4gICAgICBpZiAoIWlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGltcGFjdC5kaXNwbGFjZWQuaW52aXNpYmxlW293bklkXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZSA9IG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGNoYW5nZS54LCBjaGFuZ2UueSk7XG4gICAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGFjZUJ5ID0gaW1wYWN0LmRpc3BsYWNlZEJ5LnBvaW50O1xuICAgIGNvbnN0IG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGRpc3BsYWNlQnkueCwgZGlzcGxhY2VCeS55KTtcbiAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHZpc3VhbERpc3BsYWNlbWVudC5zaG91bGRBbmltYXRlKTtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkLCBzdGF0ZS5pbXBhY3QsIHN0YXRlLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmIChjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCwgY29tcGxldGVkLmltcGFjdCwgY29tcGxldGVkLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyQxID0gKCkgPT4ge1xuICBjb25zdCBkcmFnZ2luZ1NlbGVjdG9yID0gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKTtcbiAgY29uc3Qgc2Vjb25kYXJ5U2VsZWN0b3IgPSBnZXRTZWNvbmRhcnlTZWxlY3RvcigpO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IGRyYWdnaW5nU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBzZWNvbmRhcnlTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IGF0UmVzdDtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyQxID0ge1xuICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZFxufTtcbmNvbnN0IENvbm5lY3RlZERyYWdnYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcyQxLCBtYXBEaXNwYXRjaFRvUHJvcHMkMSwgbnVsbCwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJhZ2dhYmxlKTtcblxuZnVuY3Rpb24gUHJpdmF0ZURyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBkcm9wcGFibGVDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSBkcm9wcGFibGVDb250ZXh0LmlzVXNpbmdDbG9uZUZvcjtcbiAgaWYgKGlzVXNpbmdDbG9uZUZvciA9PT0gcHJvcHMuZHJhZ2dhYmxlSWQgJiYgIXByb3BzLmlzQ2xvbmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0ZWREcmFnZ2FibGUsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIFB1YmxpY0RyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBpc0VuYWJsZWQgPSB0eXBlb2YgcHJvcHMuaXNEcmFnRGlzYWJsZWQgPT09ICdib29sZWFuJyA/ICFwcm9wcy5pc0RyYWdEaXNhYmxlZCA6IHRydWU7XG4gIGNvbnN0IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmcpO1xuICBjb25zdCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyA9IEJvb2xlYW4ocHJvcHMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXG4gIH0pKTtcbn1cblxuY29uc3QgaXNFcXVhbCA9IGJhc2UgPT4gdmFsdWUgPT4gYmFzZSA9PT0gdmFsdWU7XG5jb25zdCBpc1Njcm9sbCA9IGlzRXF1YWwoJ3Njcm9sbCcpO1xuY29uc3QgaXNBdXRvID0gaXNFcXVhbCgnYXV0bycpO1xuY29uc3QgaXNWaXNpYmxlID0gaXNFcXVhbCgndmlzaWJsZScpO1xuY29uc3QgaXNFaXRoZXIgPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpIHx8IGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0JvdGggPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpICYmIGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0VsZW1lbnRTY3JvbGxhYmxlID0gZWwgPT4ge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3Qgb3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBzdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBzdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgcmV0dXJuIGlzRWl0aGVyKG92ZXJmbG93LCBpc1Njcm9sbCkgfHwgaXNFaXRoZXIob3ZlcmZsb3csIGlzQXV0byk7XG59O1xuY29uc3QgaXNCb2R5U2Nyb2xsYWJsZSA9ICgpID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFodG1sID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGJvZHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuICBjb25zdCBodG1sT3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBodG1sU3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogaHRtbFN0eWxlLm92ZXJmbG93WVxuICB9O1xuICBpZiAoaXNCb3RoKGh0bWxPdmVyZmxvdywgaXNWaXNpYmxlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBXZSBoYXZlIGRldGVjdGVkIHRoYXQgeW91ciA8Ym9keT4gZWxlbWVudCBtaWdodCBiZSBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgV2UgaGF2ZSBmb3VuZCBubyByZWxpYWJsZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgdGhlIDxib2R5PiBlbGVtZW50IGlzIGEgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgYSA8Ym9keT4gc2Nyb2xsIGJhciB3aWxsIGJlIG9uIHRoZSA8aHRtbD4gZWxlbWVudCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuXG4gICAgQmVjYXVzZSB3ZSBjYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSA8Ym9keT4gaXMgYSBzY3JvbGwgY29udGFpbmVyLCBhbmQgZ2VuZXJhbGx5IGl0IGlzIG5vdCBvbmUsXG4gICAgd2Ugd2lsbCBiZSB0cmVhdGluZyB0aGUgPGJvZHk+IGFzICpub3QqIGEgc2Nyb2xsIGNvbnRhaW5lclxuXG4gICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2hvdy13ZS1kZXRlY3Qtc2Nyb2xsLWNvbnRhaW5lcnMubWRcbiAgYCkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBnZXRDbG9zZXN0U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gaXNCb2R5U2Nyb2xsYWJsZSgpID8gZWwgOiBudWxsO1xuICB9XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGVsKSkge1xuICAgIHJldHVybiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG52YXIgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzID0gc2Nyb2xsYWJsZSA9PiB7XG4gIGlmICghc2Nyb2xsYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbm90aGVyU2Nyb2xsUGFyZW50ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoc2Nyb2xsYWJsZS5wYXJlbnRFbGVtZW50KTtcbiAgaWYgKCFhbm90aGVyU2Nyb2xsUGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERyb3BwYWJsZTogdW5zdXBwb3J0ZWQgbmVzdGVkIHNjcm9sbCBjb250YWluZXIgZGV0ZWN0ZWQuXG4gICAgQSBEcm9wcGFibGUgY2FuIG9ubHkgaGF2ZSBvbmUgc2Nyb2xsIHBhcmVudCAod2hpY2ggY2FuIGJlIGl0c2VsZilcbiAgICBOZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuXG4gICAgV2UgaG9wZSB0byBzdXBwb3J0IG5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBzb29uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvaXNzdWVzLzEzMVxuICBgKSA6IHZvaWQgMDtcbn07XG5cbnZhciBnZXRTY3JvbGwgPSBlbCA9PiAoe1xuICB4OiBlbC5zY3JvbGxMZWZ0LFxuICB5OiBlbC5zY3JvbGxUb3Bcbn0pO1xuXG5jb25zdCBnZXRJc0ZpeGVkID0gZWwgPT4ge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZ2V0SXNGaXhlZChlbC5wYXJlbnRFbGVtZW50KTtcbn07XG52YXIgZ2V0RW52ID0gc3RhcnQgPT4ge1xuICBjb25zdCBjbG9zZXN0U2Nyb2xsYWJsZSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHN0YXJ0KTtcbiAgY29uc3QgaXNGaXhlZE9uUGFnZSA9IGdldElzRml4ZWQoc3RhcnQpO1xuICByZXR1cm4ge1xuICAgIGNsb3Nlc3RTY3JvbGxhYmxlLFxuICAgIGlzRml4ZWRPblBhZ2VcbiAgfTtcbn07XG5cbnZhciBnZXREcm9wcGFibGVEaW1lbnNpb24gPSAoe1xuICBkZXNjcmlwdG9yLFxuICBpc0VuYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIGlzRml4ZWRPblBhZ2UsXG4gIGRpcmVjdGlvbixcbiAgY2xpZW50LFxuICBwYWdlLFxuICBjbG9zZXN0XG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gKCgpID0+IHtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgY2xpZW50OiBmcmFtZUNsaWVudFxuICAgIH0gPSBjbG9zZXN0O1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgICBzY3JvbGxIZWlnaHQ6IHNjcm9sbFNpemUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IHNjcm9sbFNpemUuc2Nyb2xsV2lkdGgsXG4gICAgICBoZWlnaHQ6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3guaGVpZ2h0LFxuICAgICAgd2lkdGg6IGZyYW1lQ2xpZW50LnBhZGRpbmdCb3gud2lkdGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZU1hcmdpbkJveDogY2xvc2VzdC5wYWdlLm1hcmdpbkJveCxcbiAgICAgIGZyYW1lQ2xpZW50LFxuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiBjbG9zZXN0LnNob3VsZENsaXBTdWJqZWN0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIGluaXRpYWw6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBjdXJyZW50OiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICAgIGRpZmY6IHtcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBheGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gdmVydGljYWwgOiBob3Jpem9udGFsO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYXhpcyxcbiAgICBmcmFtZVxuICB9KTtcbiAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlLFxuICAgIGF4aXMsXG4gICAgaXNFbmFibGVkLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmNvbnN0IGdldENsaWVudCA9ICh0YXJnZXRSZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcbiAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmICh0YXJnZXRSZWYgIT09IGNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgdG9wID0gYmFzZS5wYWRkaW5nQm94LnRvcCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgY29uc3QgbGVmdCA9IGJhc2UucGFkZGluZ0JveC5sZWZ0IC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aDtcbiAgY29uc3QgcGFkZGluZ0JveCA9IHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnRcbiAgfTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZXhwYW5kKHBhZGRpbmdCb3gsIGJhc2UuYm9yZGVyKTtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBiYXNlLm1hcmdpbixcbiAgICBib3JkZXI6IGJhc2UuYm9yZGVyLFxuICAgIHBhZGRpbmc6IGJhc2UucGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIGNsaWVudDtcbn07XG52YXIgZ2V0RGltZW5zaW9uID0gKHtcbiAgcmVmLFxuICBkZXNjcmlwdG9yLFxuICBlbnYsXG4gIHdpbmRvd1Njcm9sbCxcbiAgZGlyZWN0aW9uLFxuICBpc0Ryb3BEaXNhYmxlZCxcbiAgaXNDb21iaW5lRW5hYmxlZCxcbiAgc2hvdWxkQ2xpcFN1YmplY3Rcbn0pID0+IHtcbiAgY29uc3QgY2xvc2VzdFNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudChyZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuICBjb25zdCBjbG9zZXN0ID0gKCgpID0+IHtcbiAgICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVDbGllbnQgPSBnZXRCb3goY2xvc2VzdFNjcm9sbGFibGUpO1xuICAgIGNvbnN0IHNjcm9sbFNpemUgPSB7XG4gICAgICBzY3JvbGxIZWlnaHQ6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBwYWdlOiB3aXRoU2Nyb2xsKGZyYW1lQ2xpZW50LCB3aW5kb3dTY3JvbGwpLFxuICAgICAgc2Nyb2xsOiBnZXRTY3JvbGwoY2xvc2VzdFNjcm9sbGFibGUpLFxuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZGltZW5zaW9uID0gZ2V0RHJvcHBhYmxlRGltZW5zaW9uKHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIGlzRW5hYmxlZDogIWlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZTogZW52LmlzRml4ZWRPblBhZ2UsXG4gICAgZGlyZWN0aW9uLFxuICAgIGNsaWVudCxcbiAgICBwYWdlLFxuICAgIGNsb3Nlc3RcbiAgfSk7XG4gIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5jb25zdCBpbW1lZGlhdGUgPSB7XG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuY29uc3QgZGVsYXllZCA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBnZXRMaXN0ZW5lck9wdGlvbnMgPSBvcHRpb25zID0+IG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZDtcblxuY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyA9IGRyYWdnaW5nID0+IGRyYWdnaW5nICYmIGRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSB8fCBudWxsO1xuZnVuY3Rpb24gdXNlRHJvcHBhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgY29uc3Qgd2hpbGVEcmFnZ2luZ1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZVJlcXVpcmVkQ29udGV4dChBcHBDb250ZXh0KTtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnZHJvcHBhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RyeSxcbiAgICBtYXJzaGFsXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBhcmdzLmRyb3BwYWJsZUlkLFxuICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICBtb2RlOiBhcmdzLm1vZGVcbiAgfSksIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICBjb25zdCBwdWJsaXNoZWREZXNjcmlwdG9yUmVmID0gdXNlUmVmKGRlc2NyaXB0b3IpO1xuICBjb25zdCBtZW1vaXplZFVwZGF0ZVNjcm9sbCA9IHVzZU1lbW8oKCkgPT4gbWVtb2l6ZU9uZSgoeCwgeSkgPT4ge1xuICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHNjcm9sbCA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZVNjcm9sbChkZXNjcmlwdG9yLmlkLCBzY3JvbGwpO1xuICB9KSwgW2Rlc2NyaXB0b3IuaWQsIG1hcnNoYWxdKTtcbiAgY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBpZiAoIWRyYWdnaW5nIHx8ICFkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGwoZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgfSwgW10pO1xuICBjb25zdCB1cGRhdGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsID0gZ2V0Q2xvc2VzdFNjcm9sbCgpO1xuICAgIG1lbW9pemVkVXBkYXRlU2Nyb2xsKHNjcm9sbC54LCBzY3JvbGwueSk7XG4gIH0sIFtnZXRDbG9zZXN0U2Nyb2xsLCBtZW1vaXplZFVwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBzY2hlZHVsZVNjcm9sbFVwZGF0ZSA9IHVzZU1lbW8oKCkgPT4gcmFmU2NoZCh1cGRhdGVTY3JvbGwpLCBbdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IG9uQ2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHNjcm9sbCBvcHRpb25zIHdoaWxlIHNjcm9sbGluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRyYWdnaW5nLnNjcm9sbE9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5KSB7XG4gICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVTY3JvbGxVcGRhdGUoKTtcbiAgfSwgW3NjaGVkdWxlU2Nyb2xsVXBkYXRlLCB1cGRhdGVTY3JvbGxdKTtcbiAgY29uc3QgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwgPSB1c2VDYWxsYmFjaygod2luZG93U2Nyb2xsLCBvcHRpb25zKSA9PiB7XG4gICAgISF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCBhIGRyb3BwYWJsZSB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcmVmID0gcHJldmlvdXMuZ2V0RHJvcHBhYmxlUmVmKCk7XG4gICAgIXJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IHdpdGhvdXQgYSBkcm9wcGFibGUgcmVmJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnYgPSBnZXRFbnYocmVmKTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHtcbiAgICAgIHJlZixcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICBlbnYsXG4gICAgICBzY3JvbGxPcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBkcmFnZ2luZztcbiAgICBjb25zdCBkaW1lbnNpb24gPSBnZXREaW1lbnNpb24oe1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHdpbmRvd1Njcm9sbCxcbiAgICAgIGRpcmVjdGlvbjogcHJldmlvdXMuZGlyZWN0aW9uLFxuICAgICAgaXNEcm9wRGlzYWJsZWQ6IHByZXZpb3VzLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZDogcHJldmlvdXMuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiAhcHJldmlvdXMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmdcbiAgICB9KTtcbiAgICBjb25zdCBzY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICAgIGlmIChzY3JvbGxhYmxlKSB7XG4gICAgICBzY3JvbGxhYmxlLnNldEF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkLCBhcHBDb250ZXh0LmNvbnRleHRJZCk7XG4gICAgICBzY3JvbGxhYmxlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyhzY3JvbGxhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfSwgW2FwcENvbnRleHQuY29udGV4dElkLCBkZXNjcmlwdG9yLCBvbkNsb3Nlc3RTY3JvbGwsIHByZXZpb3VzUmVmXSk7XG4gIGNvbnN0IGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSByZWNvbGxlY3QgRHJvcHBhYmxlIGNsaWVudCBmb3IgRHJvcHBhYmxlcyB0aGF0IGhhdmUgYSBzY3JvbGwgY29udGFpbmVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsKGNsb3Nlc3QpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRyYWdTdG9wcGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGRyYWcgd2hlbiBubyBhY3RpdmUgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICBjb25zdCBzY3JvbGwgPSB1c2VDYWxsYmFjayhjaGFuZ2UgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIWNsb3Nlc3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIGEgZHJvcHBhYmxlIHdpdGggbm8gY2xvc2VzdCBzY3JvbGxhYmxlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjbG9zZXN0LnNjcm9sbFRvcCArPSBjaGFuZ2UueTtcbiAgICBjbG9zZXN0LnNjcm9sbExlZnQgKz0gY2hhbmdlLng7XG4gIH0sIFtdKTtcbiAgY29uc3QgY2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLFxuICAgICAgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyxcbiAgICAgIGRyYWdTdG9wcGVkLFxuICAgICAgc2Nyb2xsXG4gICAgfTtcbiAgfSwgW2RyYWdTdG9wcGVkLCBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCwgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZywgc2Nyb2xsXSk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVuaXF1ZUlkLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY2FsbGJhY2tzXG4gIH0pLCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCB1bmlxdWVJZF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5yZWdpc3RlcihlbnRyeSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnVW5zdXBwb3J0ZWQ6IGNoYW5naW5nIHRoZSBkcm9wcGFibGVJZCBvciB0eXBlIG9mIGEgRHJvcHBhYmxlIGR1cmluZyBhIGRyYWcnKSA6IHZvaWQgMDtcbiAgICAgICAgZHJhZ1N0b3BwZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS51bnJlZ2lzdGVyKGVudHJ5KTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCBkcmFnU3RvcHBlZCwgZW50cnksIG1hcnNoYWwsIHJlZ2lzdHJ5LmRyb3BwYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsICFhcmdzLmlzRHJvcERpc2FibGVkKTtcbiAgfSwgW2FyZ3MuaXNEcm9wRGlzYWJsZWQsIG1hcnNoYWxdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgYXJncy5pc0NvbWJpbmVFbmFibGVkKTtcbiAgfSwgW2FyZ3MuaXNDb21iaW5lRW5hYmxlZCwgbWFyc2hhbF0pO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbmNvbnN0IGVtcHR5ID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBtYXJnaW46IG5vU3BhY2luZ1xufTtcbmNvbnN0IGdldFNpemUgPSAoe1xuICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICBwbGFjZWhvbGRlcixcbiAgYW5pbWF0ZVxufSkgPT4ge1xuICBpZiAoaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlaWdodDogcGxhY2Vob2xkZXIuY2xpZW50LmJvcmRlckJveC5oZWlnaHQsXG4gICAgd2lkdGg6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3gud2lkdGgsXG4gICAgbWFyZ2luOiBwbGFjZWhvbGRlci5jbGllbnQubWFyZ2luXG4gIH07XG59O1xuY29uc3QgZ2V0U3R5bGUgPSAoe1xuICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICBwbGFjZWhvbGRlcixcbiAgYW5pbWF0ZVxufSkgPT4ge1xuICBjb25zdCBzaXplID0gZ2V0U2l6ZSh7XG4gICAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICBwbGFjZWhvbGRlcixcbiAgICBhbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IHBsYWNlaG9sZGVyLmRpc3BsYXksXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICBtYXJnaW5Ub3A6IHNpemUubWFyZ2luLnRvcCxcbiAgICBtYXJnaW5SaWdodDogc2l6ZS5tYXJnaW4ucmlnaHQsXG4gICAgbWFyZ2luQm90dG9tOiBzaXplLm1hcmdpbi5ib3R0b20sXG4gICAgbWFyZ2luTGVmdDogc2l6ZS5tYXJnaW4ubGVmdCxcbiAgICBmbGV4U2hyaW5rOiAnMCcsXG4gICAgZmxleEdyb3c6ICcwJyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdHJhbnNpdGlvbjogYW5pbWF0ZSAhPT0gJ25vbmUnID8gdHJhbnNpdGlvbnMucGxhY2Vob2xkZXIgOiBudWxsXG4gIH07XG59O1xuY29uc3QgUGxhY2Vob2xkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFuaW1hdGVPcGVuVGltZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KTtcbiAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICB9LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBhbmltYXRlLFxuICAgIG9uVHJhbnNpdGlvbkVuZCxcbiAgICBvbkNsb3NlLFxuICAgIGNvbnRleHRJZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50XSA9IHVzZVN0YXRlKHByb3BzLmFuaW1hdGUgPT09ICdvcGVuJyk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0FuaW1hdGluZ09wZW5Pbk1vdW50KSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGUgIT09ICdvcGVuJykge1xuICAgICAgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyKCk7XG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50KGZhbHNlKTtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcjtcbiAgfSwgW2FuaW1hdGUsIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcl0pO1xuICBjb25zdCBvblNpemVDaGFuZ2VFbmQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25UcmFuc2l0aW9uRW5kKCk7XG4gICAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9XG4gIH0sIFthbmltYXRlLCBvbkNsb3NlLCBvblRyYW5zaXRpb25FbmRdKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRTdHlsZSh7XG4gICAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICBhbmltYXRlOiBwcm9wcy5hbmltYXRlLFxuICAgIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlclxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHMucGxhY2Vob2xkZXIudGFnTmFtZSwge1xuICAgIHN0eWxlLFxuICAgICdkYXRhLXJmZC1wbGFjZWhvbGRlci1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25TaXplQ2hhbmdlRW5kLFxuICAgIHJlZjogcHJvcHMuaW5uZXJSZWZcbiAgfSk7XG59O1xudmFyIFBsYWNlaG9sZGVyJDEgPSBSZWFjdC5tZW1vKFBsYWNlaG9sZGVyKTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIHJ1bkNoZWNrcyhhcmdzLCBjaGVja3MpIHtcbiAgY2hlY2tzLmZvckVhY2goY2hlY2sgPT4gY2hlY2soYXJncykpO1xufVxuY29uc3Qgc2hhcmVkID0gW2Z1bmN0aW9uIHJlcXVpcmVkKHtcbiAgcHJvcHNcbn0pIHtcbiAgIXByb3BzLmRyb3BwYWJsZUlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQSBEcm9wcGFibGUgcmVxdWlyZXMgYSBkcm9wcGFibGVJZCBwcm9wJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEEgRHJvcHBhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJvcHBhYmxlSWQuIFByb3ZpZGVkOiBbJHt0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBib29sZWFuKHtcbiAgcHJvcHNcbn0pIHtcbiAgIWlzQm9vbGVhbihwcm9wcy5pc0Ryb3BEaXNhYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0Ryb3BEaXNhYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0NvbWJpbmVFbmFibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiByZWYoe1xuICBnZXREcm9wcGFibGVSZWZcbn0pIHtcbiAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0RHJvcHBhYmxlUmVmKCkpO1xufV07XG5jb25zdCBzdGFuZGFyZCA9IFtmdW5jdGlvbiBwbGFjZWhvbGRlcih7XG4gIHByb3BzLFxuICBnZXRQbGFjZWhvbGRlclJlZlxufSkge1xuICBpZiAoIXByb3BzLnBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZiA9IGdldFBsYWNlaG9sZGVyUmVmKCk7XG4gIGlmIChyZWYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBEcm9wcGFibGUgc2V0dXAgaXNzdWUgW2Ryb3BwYWJsZUlkOiBcIiR7cHJvcHMuZHJvcHBhYmxlSWR9XCJdOlxuICAgICAgRHJvcHBhYmxlUHJvdmlkZWQgPiBwbGFjZWhvbGRlciBjb3VsZCBub3QgYmUgZm91bmQuXG5cbiAgICAgIFBsZWFzZSBiZSBzdXJlIHRvIGFkZCB0aGUge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfSBSZWFjdCBOb2RlIGFzIGEgY2hpbGQgb2YgeW91ciBEcm9wcGFibGUuXG4gICAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9hcGkvZHJvcHBhYmxlLm1kXG4gICAgYCkgOiB2b2lkIDA7XG59XTtcbmNvbnN0IHZpcnR1YWwgPSBbZnVuY3Rpb24gaGFzQ2xvbmUoe1xuICBwcm9wc1xufSkge1xuICAhcHJvcHMucmVuZGVyQ2xvbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IHByb3ZpZGUgYSBjbG9uZSByZW5kZXIgZnVuY3Rpb24gKHJlbmRlckNsb25lKSBmb3IgdmlydHVhbCBsaXN0cycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBoYXNOb1BsYWNlaG9sZGVyKHtcbiAgZ2V0UGxhY2Vob2xkZXJSZWZcbn0pIHtcbiAgISFnZXRQbGFjZWhvbGRlclJlZigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdmlydHVhbCBsaXN0IHRvIG5vdCBoYXZlIGEgcGxhY2Vob2xkZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgc3RhbmRhcmQpO1xuICAgIH1cbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCB2aXJ0dWFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jbGFzcyBBbmltYXRlSW5PdXQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiB0aGlzLnByb3BzLm9uLFxuICAgICAgYW5pbWF0ZTogdGhpcy5wcm9wcy5zaG91bGRBbmltYXRlICYmIHRoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuICAgIHRoaXMub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGUgIT09ICdjbG9zZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcm9wcy5vbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ29wZW4nXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEsXG4gICAgICAgIGFuaW1hdGU6ICdjbG9zZSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgICBvbkNsb3NlOiB0aGlzLm9uQ2xvc2UsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmRhdGEsXG4gICAgICBhbmltYXRlOiB0aGlzLnN0YXRlLmFuaW1hdGVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHByb3ZpZGVkKTtcbiAgfVxufVxuXG5jb25zdCBEcm9wcGFibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAhYXBwQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGFwcCBjb250ZXh0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBpc01vdmVtZW50QWxsb3dlZFxuICB9ID0gYXBwQ29udGV4dDtcbiAgY29uc3QgZHJvcHBhYmxlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcsXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBzbmFwc2hvdCxcbiAgICB1c2VDbG9uZSxcbiAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCxcbiAgICBnZXRDb250YWluZXJGb3JDbG9uZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGdldERyb3BwYWJsZVJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IGRyb3BwYWJsZVJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHNldERyb3BwYWJsZVJlZiA9IHVzZUNhbGxiYWNrKCh2YWx1ZSA9IG51bGwpID0+IHtcbiAgICBkcm9wcGFibGVSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIGNvbnN0IGdldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcGxhY2Vob2xkZXJSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKCh2YWx1ZSA9IG51bGwpID0+IHtcbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgdXNlVmFsaWRhdGlvbih7XG4gICAgcHJvcHMsXG4gICAgZ2V0RHJvcHBhYmxlUmVmLFxuICAgIGdldFBsYWNlaG9sZGVyUmVmXG4gIH0pO1xuICBjb25zdCBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaXNNb3ZlbWVudEFsbG93ZWQoKSkge1xuICAgICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwoe1xuICAgICAgICBtYXhTY3JvbGw6IGdldE1heFdpbmRvd1Njcm9sbCgpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtpc01vdmVtZW50QWxsb3dlZCwgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxdKTtcbiAgdXNlRHJvcHBhYmxlUHVibGlzaGVyKHtcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIG1vZGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcsXG4gICAgZ2V0RHJvcHBhYmxlUmVmXG4gIH0pO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IHVzZU1lbW8oKCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChBbmltYXRlSW5PdXQsIHtcbiAgICBvbjogcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgc2hvdWxkQW5pbWF0ZTogcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyXG4gIH0sICh7XG4gICAgb25DbG9zZSxcbiAgICBkYXRhLFxuICAgIGFuaW1hdGVcbiAgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChQbGFjZWhvbGRlciQxLCB7XG4gICAgcGxhY2Vob2xkZXI6IGRhdGEsXG4gICAgb25DbG9zZTogb25DbG9zZSxcbiAgICBpbm5lclJlZjogc2V0UGxhY2Vob2xkZXJSZWYsXG4gICAgYW5pbWF0ZTogYW5pbWF0ZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kXG4gIH0pKSwgW2NvbnRleHRJZCwgb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQsIHByb3BzLnBsYWNlaG9sZGVyLCBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXIsIHNldFBsYWNlaG9sZGVyUmVmXSk7XG4gIGNvbnN0IHByb3ZpZGVkID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlubmVyUmVmOiBzZXREcm9wcGFibGVSZWYsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgZHJvcHBhYmxlUHJvcHM6IHtcbiAgICAgICdkYXRhLXJmZC1kcm9wcGFibGUtaWQnOiBkcm9wcGFibGVJZCxcbiAgICAgICdkYXRhLXJmZC1kcm9wcGFibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZFxuICAgIH1cbiAgfSksIFtjb250ZXh0SWQsIGRyb3BwYWJsZUlkLCBwbGFjZWhvbGRlciwgc2V0RHJvcHBhYmxlUmVmXSk7XG4gIGNvbnN0IGlzVXNpbmdDbG9uZUZvciA9IHVzZUNsb25lID8gdXNlQ2xvbmUuZHJhZ2dpbmcuZHJhZ2dhYmxlSWQgOiBudWxsO1xuICBjb25zdCBkcm9wcGFibGVDb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgaXNVc2luZ0Nsb25lRm9yXG4gIH0pLCBbZHJvcHBhYmxlSWQsIGlzVXNpbmdDbG9uZUZvciwgdHlwZV0pO1xuICBmdW5jdGlvbiBnZXRDbG9uZSgpIHtcbiAgICBpZiAoIXVzZUNsb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ2dpbmcsXG4gICAgICByZW5kZXJcbiAgICB9ID0gdXNlQ2xvbmU7XG4gICAgY29uc3Qgbm9kZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnaW5nLmRyYWdnYWJsZUlkLFxuICAgICAgaW5kZXg6IGRyYWdnaW5nLnNvdXJjZS5pbmRleCxcbiAgICAgIGlzQ2xvbmU6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZmFsc2UsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogdHJ1ZVxuICAgIH0sIChkcmFnZ2FibGVQcm92aWRlZCwgZHJhZ2dhYmxlU25hcHNob3QpID0+IHJlbmRlcihkcmFnZ2FibGVQcm92aWRlZCwgZHJhZ2dhYmxlU25hcHNob3QsIGRyYWdnaW5nKSk7XG4gICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChub2RlLCBnZXRDb250YWluZXJGb3JDbG9uZSgpKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wcGFibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRyb3BwYWJsZUNvbnRleHRcbiAgfSwgY2hpbGRyZW4ocHJvdmlkZWQsIHNuYXBzaG90KSwgZ2V0Q2xvbmUoKSk7XG59O1xuXG5mdW5jdGlvbiBnZXRCb2R5KCkge1xuICAhZG9jdW1lbnQuYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2RvY3VtZW50LmJvZHkgaXMgbm90IHJlYWR5JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG1vZGU6ICdzdGFuZGFyZCcsXG4gIHR5cGU6ICdERUZBVUxUJyxcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBpc0Ryb3BEaXNhYmxlZDogZmFsc2UsXG4gIGlzQ29tYmluZUVuYWJsZWQ6IGZhbHNlLFxuICBpZ25vcmVDb250YWluZXJDbGlwcGluZzogZmFsc2UsXG4gIHJlbmRlckNsb25lOiBudWxsLFxuICBnZXRDb250YWluZXJGb3JDbG9uZTogZ2V0Qm9keVxufTtcbmNvbnN0IGF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMgPSBvd25Qcm9wcyA9PiB7XG4gIGxldCBtZXJnZWRQcm9wcyA9IHtcbiAgICAuLi5vd25Qcm9wc1xuICB9O1xuICBsZXQgZGVmYXVsdFByb3BLZXk7XG4gIGZvciAoZGVmYXVsdFByb3BLZXkgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKG93blByb3BzW2RlZmF1bHRQcm9wS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXJnZWRQcm9wcyA9IHtcbiAgICAgICAgLi4ubWVyZ2VkUHJvcHMsXG4gICAgICAgIFtkZWZhdWx0UHJvcEtleV06IGRlZmF1bHRQcm9wc1tkZWZhdWx0UHJvcEtleV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRQcm9wcztcbn07XG5jb25zdCBpc01hdGNoaW5nVHlwZSA9ICh0eXBlLCBjcml0aWNhbCkgPT4gdHlwZSA9PT0gY3JpdGljYWwuZHJvcHBhYmxlLnR5cGU7XG5jb25zdCBnZXREcmFnZ2FibGUgPSAoY3JpdGljYWwsIGRpbWVuc2lvbnMpID0+IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuY29uc3QgbWFrZU1hcFN0YXRlVG9Qcm9wcyA9ICgpID0+IHtcbiAgY29uc3QgaWRsZVdpdGhBbmltYXRpb24gPSB7XG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgIHNuYXBzaG90OiB7XG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2UsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBudWxsLFxuICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IG51bGwsXG4gICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IGZhbHNlXG4gICAgfSxcbiAgICB1c2VDbG9uZTogbnVsbFxuICB9O1xuICBjb25zdCBpZGxlV2l0aG91dEFuaW1hdGlvbiA9IHtcbiAgICAuLi5pZGxlV2l0aEFuaW1hdGlvbixcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGdldERyYWdnYWJsZVJ1YnJpYyA9IG1lbW9pemVPbmUoZGVzY3JpcHRvciA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWFwUHJvcHMgPSBtZW1vaXplT25lKChpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLCBpc0RyYWdnaW5nT3ZlckZvckltcGFjdCwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGlzSG9tZSA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGlkO1xuICAgIGlmIChpc0hvbWUpIHtcbiAgICAgIGNvbnN0IHVzZUNsb25lID0gcmVuZGVyQ2xvbmUgPyB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyQ2xvbmUsXG4gICAgICAgIGRyYWdnaW5nOiBnZXREcmFnZ2FibGVSdWJyaWMoZHJhZ2dpbmcuZGVzY3JpcHRvcilcbiAgICAgIH0gOiBudWxsO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB7XG4gICAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgICBkcmFnZ2luZ092ZXJXaXRoOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyID8gZHJhZ2dhYmxlSWQgOiBudWxsLFxuICAgICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZSxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHVzZUNsb25lXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0KSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgc25hcHNob3QsXG4gICAgICB1c2VDbG9uZTogbnVsbFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBjb25zdCBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMgPSBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzKG93blByb3BzKTtcbiAgICBjb25zdCBpZCA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5kcm9wcGFibGVJZDtcbiAgICBjb25zdCB0eXBlID0gb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLnR5cGU7XG4gICAgY29uc3QgaXNFbmFibGVkID0gIW93blByb3BzV2l0aERlZmF1bHRQcm9wcy5pc0Ryb3BEaXNhYmxlZDtcbiAgICBjb25zdCByZW5kZXJDbG9uZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy5yZW5kZXJDbG9uZTtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2luZyA9IGdldERyYWdnYWJsZShjcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICBjb25zdCBpc0RyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCkgPT09IGlkO1xuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyLCBpc0RyYWdnaW5nT3ZlciwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY29tcGxldGVkLmNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQoY29tcGxldGVkLnJlc3VsdCkgPT09IGlkLCB3aGF0SXNEcmFnZ2VkT3Zlcihjb21wbGV0ZWQuaW1wYWN0KSA9PT0gaWQsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnICYmIHN0YXRlLmNvbXBsZXRlZCAmJiAhc3RhdGUuc2hvdWxkRmx1c2gpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkO1xuICAgICAgY29uc3Qgd2FzQ29tYmluaW5nID0gQm9vbGVhbihjb21wbGV0ZWQuaW1wYWN0LmF0ICYmIGNvbXBsZXRlZC5pbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKTtcbiAgICAgIGNvbnN0IGlzSG9tZSA9IGNvbXBsZXRlZC5jcml0aWNhbC5kcm9wcGFibGUuaWQgPT09IGlkO1xuICAgICAgaWYgKHdhc092ZXIpIHtcbiAgICAgICAgcmV0dXJuIHdhc0NvbWJpbmluZyA/IGlkbGVXaXRoQW5pbWF0aW9uIDogaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNIb21lKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0ge1xuICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbDogdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxcbn07XG5jb25zdCBDb25uZWN0ZWREcm9wcGFibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyksXG4gICAgLi4uc3RhdGVQcm9wcyxcbiAgICAuLi5kaXNwYXRjaFByb3BzXG4gIH07XG59LCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcm9wcGFibGUpO1xudmFyIENvbm5lY3RlZERyb3BwYWJsZSQxID0gQ29ubmVjdGVkRHJvcHBhYmxlO1xuXG5leHBvcnQgeyBEcmFnRHJvcENvbnRleHQsIFB1YmxpY0RyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIENvbm5lY3RlZERyb3BwYWJsZSQxIGFzIERyb3BwYWJsZSwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZU1vdXNlU2Vuc29yLCB1c2VUb3VjaFNlbnNvciB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDb250ZXh0IiwiUmVhY3RET00iLCJmbHVzaFN5bmMiLCJjcmVhdGVTdG9yZSIsImNyZWF0ZVN0b3JlJDEiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21wb3NlIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiUHJvdmlkZXIiLCJjb25uZWN0IiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiZ2V0UmVjdCIsImV4cGFuZCIsIm9mZnNldCIsIndpdGhTY3JvbGwiLCJjYWxjdWxhdGVCb3giLCJnZXRCb3giLCJjcmVhdGVCb3giLCJtZW1vaXplT25lIiwicmFmU2NoZCIsIl9leHRlbmRzIiwiaXNQcm9kdWN0aW9uJDEiLCJwcm9jZXNzIiwic3BhY2VzQW5kVGFicyIsImxpbmVTdGFydFdpdGhTcGFjZXMiLCJjbGVhbiQyIiwidmFsdWUiLCJyZXBsYWNlIiwidHJpbSIsImdldERldk1lc3NhZ2UiLCJtZXNzYWdlIiwiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsImlzRGlzYWJsZWRGbGFnIiwibG9nIiwidHlwZSIsIndpbmRvdyIsImNvbnNvbGUiLCJ3YXJuaW5nIiwiYmluZCIsImVycm9yIiwibm9vcCQyIiwiZ2V0T3B0aW9ucyIsInNoYXJlZCIsImZyb21CaW5kaW5nIiwiYmluZEV2ZW50cyIsImVsIiwiYmluZGluZ3MiLCJzaGFyZWRPcHRpb25zIiwidW5iaW5kaW5ncyIsIm1hcCIsImJpbmRpbmciLCJvcHRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImZuIiwidW5iaW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuYmluZEFsbCIsImZvckVhY2giLCJpc1Byb2R1Y3Rpb24iLCJwcmVmaXgkMSIsIlJiZEludmFyaWFudCIsIkVycm9yIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmdzIiwiY2FsbGJhY2tzIiwib25XaW5kb3dFcnJvciIsImV2ZW50IiwiZ2V0Q2FsbGJhY2tzIiwiaXNEcmFnZ2luZyIsInRyeUFib3J0IiwiZXJyIiwicHJldmVudERlZmF1bHQiLCJzZXRDYWxsYmFja3MiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZENhdGNoIiwic2V0U3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMiLCJwb3NpdGlvbiIsImluZGV4Iiwib25EcmFnU3RhcnQiLCJzdGFydCIsInNvdXJjZSIsIndpdGhMb2NhdGlvbiIsImRlc3RpbmF0aW9uIiwiaXNJbkhvbWVMaXN0IiwiZHJvcHBhYmxlSWQiLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJ3aXRoQ29tYmluZSIsImlkIiwiY29tYmluZSIsImluSG9tZUxpc3QiLCJkcmFnZ2FibGVJZCIsIm9uRHJhZ1VwZGF0ZSIsInVwZGF0ZSIsImxvY2F0aW9uIiwicmV0dXJuZWRUb1N0YXJ0Iiwib25EcmFnRW5kIiwicmVzdWx0IiwicmVhc29uIiwicHJlc2V0Iiwib3JpZ2luIiwieCIsInkiLCJhZGQiLCJwb2ludDEiLCJwb2ludDIiLCJzdWJ0cmFjdCIsImlzRXF1YWwkMSIsIm5lZ2F0ZSIsInBvaW50IiwicGF0Y2giLCJsaW5lIiwib3RoZXJWYWx1ZSIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJjbG9zZXN0JDEiLCJ0YXJnZXQiLCJwb2ludHMiLCJtaW4iLCJhcHBseSIsImV4ZWN1dGVDbGlwIiwiZnJhbWUiLCJzdWJqZWN0IiwidG9wIiwibWF4IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRCeVBvc2l0aW9uIiwic3BhY2luZyIsImdldENvcm5lcnMiLCJub1NwYWNpbmciLCJzY3JvbGwkMSIsInNjcm9sbCIsImRpZmYiLCJkaXNwbGFjZW1lbnQiLCJpbmNyZWFzZSIsImF4aXMiLCJ3aXRoUGxhY2Vob2xkZXIiLCJpbmNyZWFzZWRCeSIsImVuZCIsImNsaXAiLCJzaG91bGRDbGlwU3ViamVjdCIsInBhZ2VNYXJnaW5Cb3giLCJnZXRTdWJqZWN0IiwicGFnZSIsInNjcm9sbGVkIiwibWFyZ2luQm94IiwiaW5jcmVhc2VkIiwiY2xpcHBlZCIsImFjdGl2ZSIsInNjcm9sbERyb3BwYWJsZSIsImRyb3BwYWJsZSIsIm5ld1Njcm9sbCIsInNjcm9sbGFibGUiLCJzY3JvbGxEaWZmIiwiaW5pdGlhbCIsInNjcm9sbERpc3BsYWNlbWVudCIsImN1cnJlbnQiLCJ0b0Ryb3BwYWJsZU1hcCIsImRyb3BwYWJsZXMiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImRlc2NyaXB0b3IiLCJ0b0RyYWdnYWJsZU1hcCIsImRyYWdnYWJsZXMiLCJ0b0Ryb3BwYWJsZUxpc3QiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ0b0RyYWdnYWJsZUxpc3QiLCJnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlIiwiZmlsdGVyIiwiZHJhZ2dhYmxlIiwic29ydCIsImEiLCJiIiwidHJ5R2V0RGVzdGluYXRpb24iLCJpbXBhY3QiLCJhdCIsInRyeUdldENvbWJpbmUiLCJyZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCIsInJlbW92ZSIsImxpc3QiLCJpdGVtIiwibW92ZVRvTmV4dENvbWJpbmUiLCJpc01vdmluZ0ZvcndhcmQiLCJpbnNpZGVEZXN0aW5hdGlvbiIsInByZXZpb3VzSW1wYWN0IiwiaXNDb21iaW5lRW5hYmxlZCIsImdldEltcGFjdCIsImFsbCIsImRpc3BsYWNlZCIsImNsb3Nlc3RJZCIsImxlbmd0aCIsIndpdGhvdXREcmFnZ2FibGUiLCJsYXN0IiwiaW5kZXhPZkNsb3Nlc3QiLCJmaW5kSW5kZXgiLCJkIiwicHJvcG9zZWRJbmRleCIsImJlZm9yZSIsImlzSG9tZU9mIiwibm9EaXNwbGFjZWRCeSIsImVtcHR5R3JvdXBzIiwiaW52aXNpYmxlIiwidmlzaWJsZSIsIm5vSW1wYWN0IiwiZGlzcGxhY2VkQnkiLCJpc1dpdGhpbiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lIiwiaXNXaXRoaW5WZXJ0aWNhbCIsImlzV2l0aGluSG9yaXpvbnRhbCIsImlzQ29udGFpbmVkIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSIsImlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSIsImlzUGFydGlhbGx5Q29udGFpbmVkIiwiaXNCaWdnZXJWZXJ0aWNhbGx5IiwiaXNCaWdnZXJIb3Jpem9udGFsbHkiLCJpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSIsImlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsInZlcnRpY2FsIiwiZGlyZWN0aW9uIiwiY3Jvc3NBeGlzTGluZSIsInNpemUiLCJjcm9zc0F4aXNTdGFydCIsImNyb3NzQXhpc0VuZCIsImNyb3NzQXhpc1NpemUiLCJob3Jpem9udGFsIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyIsImdldERyb3BwYWJsZURpc3BsYWNlZCIsImlzVmlzaWJsZUluRHJvcHBhYmxlIiwiaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4iLCJpc1Zpc2libGVJblZpZXdwb3J0Iiwidmlld3BvcnQiLCJpc1Zpc2libGUkMSIsInRvQmVEaXNwbGFjZWQiLCJ3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50IiwiZGlzcGxhY2VkVGFyZ2V0IiwiaXNQYXJ0aWFsbHlWaXNpYmxlIiwiaXNUb3RhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGVPbkF4aXMiLCJnZXRTaG91bGRBbmltYXRlIiwiZm9yY2VTaG91bGRBbmltYXRlIiwic2hvdWxkQW5pbWF0ZSIsImdldFRhcmdldCIsImV4cGFuZEJ5IiwiZ2V0RGlzcGxhY2VtZW50R3JvdXBzIiwiYWZ0ZXJEcmFnZ2luZyIsImdyb3VwcyIsInB1c2giLCJpc1Zpc2libGUiLCJnZXRJbmRleE9mTGFzdEl0ZW0iLCJpbmRleE9mTGFzdEl0ZW0iLCJnb0F0RW5kIiwibmV3SW5kZXgiLCJjYWxjdWxhdGVSZW9yZGVySW1wYWN0IiwibWF0Y2giLCJmaW5kIiwid2l0aG91dERyYWdnaW5nIiwic2xpY2VGcm9tIiwiaW5kZXhPZiIsImltcGFjdGVkIiwic2xpY2UiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwiLCJhZnRlckNyaXRpY2FsIiwiQm9vbGVhbiIsImVmZmVjdGVkIiwiZnJvbUNvbWJpbmUiLCJjb21iaW5lSWQiLCJjb21iaW5lV2l0aCIsImNvbWJpbmVXaXRoSW5kZXgiLCJkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCIsImZyb21SZW9yZGVyIiwiY3VycmVudEluZGV4IiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsIm1vdmVUb05leHRJbmRleCIsIndhc0F0IiwiZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50IiwiaXNEaXNwbGFjZWQiLCJ3aGVuQ29tYmluaW5nIiwiY2VudGVyIiwiYm9yZGVyQm94IiwiZGlzcGxhY2VCeSIsImRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIiLCJib3giLCJtYXJnaW4iLCJkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciIsImdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciIsImlzTW92aW5nIiwiZ29BZnRlciIsIm1vdmVSZWxhdGl2ZVRvIiwiZ29CZWZvcmUiLCJnb0ludG9TdGFydCIsIm1vdmVJbnRvIiwiY29udGVudEJveCIsIndoZW5SZW9yZGVyaW5nIiwiZHJhZ2dhYmxlUGFnZSIsImNsb3Nlc3RBZnRlciIsImNsb3Nlc3QiLCJ3aXRoRGlzcGxhY2VtZW50IiwiZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCIsIm9yaWdpbmFsIiwiZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QiLCJ3aXRob3V0RGlzcGxhY2VtZW50Iiwic2Nyb2xsVmlld3BvcnQiLCJ1cGRhdGVkIiwiZ2V0RHJhZ2dhYmxlcyQxIiwiaWRzIiwidHJ5R2V0VmlzaWJsZSIsImkiLCJzcGVjdWxhdGl2ZWx5SW5jcmVhc2UiLCJtYXhTY3JvbGxDaGFuZ2UiLCJzY3JvbGxlZFZpZXdwb3J0Iiwic2Nyb2xsZWREcm9wcGFibGUiLCJ3aXRoVmlld3BvcnRTY3JvbGwiLCJ3aXRoRHJvcHBhYmxlU2Nyb2xsIiwibmV3SW1wYWN0Iiwid2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50IiwiZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJwYWdlQm9yZGVyQm94Q2VudGVyIiwid2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UiLCJjbGllbnQiLCJpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbiIsIm5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIiLCJvbmx5T25NYWluQXhpcyIsImNoYW5nZU5lZWRlZCIsInNoaWZ0ZWQiLCJtb3ZlVG9OZXh0UGxhY2UiLCJwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIiLCJwcmV2aW91c0NsaWVudFNlbGVjdGlvbiIsImlzRW5hYmxlZCIsImlzVmlzaWJsZUluTmV3TG9jYXRpb24iLCJjbGllbnRTZWxlY3Rpb24iLCJzY3JvbGxKdW1wUmVxdWVzdCIsImNhdXRpb3VzIiwiZ2V0S25vd25BY3RpdmUiLCJyZWN0IiwiZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSIsImlzQmV0d2VlblNvdXJjZUNsaXBwZWQiLCJjYW5kaWRhdGVzIiwiYWN0aXZlT2ZUYXJnZXQiLCJpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQiLCJmaXJzdCIsInNlY29uZCIsImFycmF5IiwiY29udGFpbnMiLCJpc1dpdGhpbkRyb3BwYWJsZSIsImdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyIiwiZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3giLCJnZXRDbG9zZXN0RHJhZ2dhYmxlIiwic29ydGVkIiwiZGlzdGFuY2VUb0EiLCJkaXN0YW5jZVRvQiIsImdldERpc3BsYWNlZEJ5IiwiZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyU2l6ZSIsIm1vZGUiLCJhdmFpbGFibGVTcGFjZSIsImluc2lkZURyb3BwYWJsZSIsInNwYWNlVXNlZCIsInN1bSIsImRpbWVuc2lvbiIsInJlcXVpcmVkU3BhY2UiLCJuZWVkc1RvR3Jvd0J5Iiwid2l0aE1heFNjcm9sbCIsImFkZFBsYWNlaG9sZGVyIiwicmVxdWlyZWRHcm93dGgiLCJhZGRlZCIsIm9sZEZyYW1lTWF4U2Nyb2xsIiwibWF4U2Nyb2xsIiwibmV3RnJhbWUiLCJyZW1vdmVQbGFjZWhvbGRlciIsIm9sZE1heFNjcm9sbCIsIm1vdmVUb05ld0Ryb3BwYWJsZSIsInByb3Bvc2VkIiwicHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyIiwiaXNHb2luZ0JlZm9yZVRhcmdldCIsInJlbGF0aXZlVG8iLCJtb3ZlQ3Jvc3NBeGlzIiwiaXNPdmVyIiwid2hhdElzRHJhZ2dlZE92ZXIiLCJnZXREcm9wcGFibGVPdmVyJDEiLCJtb3ZlSW5EaXJlY3Rpb24iLCJzdGF0ZSIsImlzQWN0dWFsbHlPdmVyIiwiZGltZW5zaW9ucyIsImlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQiLCJob21lIiwiY3JpdGljYWwiLCJpc01vdmluZ09uTWFpbkF4aXMiLCJib3JkZXJCb3hDZW50ZXIiLCJzZWxlY3Rpb24iLCJpc01vdmVtZW50QWxsb3dlZCIsInBoYXNlIiwiaXNQb3NpdGlvbkluRnJhbWUiLCJydW4iLCJnZXRIYXNPdmVybGFwIiwiZ2V0RnVydGhlc3RBd2F5IiwicGFnZUJvcmRlckJveCIsInN0YXJ0Q2VudGVyIiwiY2FuZGlkYXRlIiwiZ2V0RHJvcHBhYmxlT3ZlciIsImNoaWxkQ2VudGVyIiwiaXNTdGFydENvbnRhaW5lZCIsImlzRW5kQ29udGFpbmVkIiwib2Zmc2V0UmVjdEJ5UG9zaXRpb24iLCJhcmVhIiwiZ2V0SXNEaXNwbGFjZWQiLCJhdEluZGV4IiwiZ2V0UmVvcmRlckltcGFjdCIsInBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsIiwidGFyZ2V0UmVjdCIsInRhcmdldFN0YXJ0IiwidGFyZ2V0RW5kIiwiY2hpbGQiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSIsImNvbWJpbmVUaHJlc2hvbGREaXZpc29yIiwiZ2V0Q29tYmluZUltcGFjdCIsImNoaWxkUmVjdCIsImNoaWxkU2l6ZSIsInRocmVzaG9sZCIsImdldERyYWdJbXBhY3QiLCJwYWdlT2Zmc2V0IiwiZGVzdGluYXRpb25JZCIsInBhdGNoRHJvcHBhYmxlTWFwIiwiY2xlYXJVbnVzZWRQbGFjZWhvbGRlciIsIm5vdyIsImxhc3REcm9wcGFibGUiLCJyZWNvbXB1dGVQbGFjZWhvbGRlcnMiLCJjbGVhbmVkIiwicGF0Y2hlZCIsImZvcmNlZENsaWVudFNlbGVjdGlvbiIsImZvcmNlZERpbWVuc2lvbnMiLCJmb3JjZWRWaWV3cG9ydCIsImZvcmNlZEltcGFjdCIsIndpdGhVcGRhdGVkUGxhY2Vob2xkZXJzIiwiZ2V0RHJhZ2dhYmxlcyIsInJlY29tcHV0ZSIsImdldENsaWVudEJvcmRlckJveENlbnRlciIsInJlZnJlc2hTbmFwIiwibW92ZW1lbnRNb2RlIiwibmVlZHNWaXNpYmlsaXR5Q2hlY2siLCJnZXRIb21lTG9jYXRpb24iLCJnZXRMaWZ0RWZmZWN0IiwiaW5zaWRlSG9tZSIsInJhd0luZGV4IiwiaW5WaXJ0dWFsTGlzdCIsInBhdGNoRGltZW5zaW9uTWFwIiwia2V5IiwiZmluaXNoIiwib2Zmc2V0RHJhZ2dhYmxlIiwib2Zmc2V0JDEiLCJpbml0aWFsV2luZG93U2Nyb2xsIiwibW92ZWQiLCJwbGFjZWhvbGRlciIsImdldEZyYW1lIiwiYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyIsImFkZGl0aW9ucyIsInVwZGF0ZWREcm9wcGFibGVzIiwid2luZG93U2Nyb2xsQ2hhbmdlIiwibW9kaWZpZWQiLCJkcm9wcGFibGVTY3JvbGxDaGFuZ2UiLCJ0b3RhbENoYW5nZSIsInRpbWluZ3NLZXkiLCJwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCIsInB1Ymxpc2hlZCIsIndpdGhTY3JvbGxDaGFuZ2UiLCJleGlzdGluZyIsInVwZGF0ZWRBZGRpdGlvbnMiLCJyZW1vdmFscyIsIndhc092ZXJJZCIsIndhc092ZXIiLCJvbkxpZnRJbXBhY3QiLCJkcmFnZ2luZ1N0YXRlIiwiZHJvcFBlbmRpbmciLCJpc1dhaXRpbmciLCJpc1NuYXBwaW5nIiwicG9zdERyb3BwYWJsZUNoYW5nZSIsImlzRW5hYmxlZENoYW5naW5nIiwicmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3QiLCJpZGxlJDIiLCJjb21wbGV0ZWQiLCJzaG91bGRGbHVzaCIsInJlZHVjZXIiLCJhY3Rpb24iLCJwYXlsb2FkIiwiaXNXaW5kb3dTY3JvbGxBbGxvd2VkIiwiZXZlcnkiLCJpc0ZpeGVkT25QYWdlIiwiU3RyaW5nIiwibmV3U3RhdGUiLCJkcm9wRHVyYXRpb24iLCJuZXdIb21lQ2xpZW50T2Zmc2V0IiwiZ3VhcmQiLCJwcmVkaWNhdGUiLCJiZWZvcmVJbml0aWFsQ2FwdHVyZSIsImxpZnQkMSIsImluaXRpYWxQdWJsaXNoIiwicHVibGlzaFdoaWxlRHJhZ2dpbmciLCJjb2xsZWN0aW9uU3RhcnRpbmciLCJ1cGRhdGVEcm9wcGFibGVTY3JvbGwiLCJ1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQiLCJ1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkIiwibW92ZSIsIm1vdmVCeVdpbmRvd1Njcm9sbCIsInVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsIiwibW92ZVVwIiwibW92ZURvd24iLCJtb3ZlUmlnaHQiLCJtb3ZlTGVmdCIsImZsdXNoIiwiYW5pbWF0ZURyb3AiLCJjb21wbGV0ZURyb3AiLCJkcm9wIiwiZHJvcEFuaW1hdGlvbkZpbmlzaGVkIiwiY2hlY2tJbmRleGVzIiwiaW5kZXhlcyIsImVycm9ycyIsImtleXMiLCJmb3JtYXR0ZWQiLCJoYXNFcnJvciIsImpvaW4iLCJ2YWxpZGF0ZURpbWVuc2lvbnMiLCJsaWZ0IiwibWFyc2hhbCIsImdldFN0YXRlIiwiZGlzcGF0Y2giLCJuZXh0Iiwic2Nyb2xsT3B0aW9ucyIsInNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSIsInJlcXVlc3QiLCJzdGFydFB1Ymxpc2hpbmciLCJzdHlsZSIsImRyYWdnaW5nIiwiZHJvcHBpbmciLCJyZXN0aW5nIiwiY3VydmVzIiwib3V0T2ZUaGVXYXkiLCJvcGFjaXR5IiwiY29tYmluaW5nIiwic2NhbGUiLCJ0aW1pbmdzIiwibWluRHJvcFRpbWUiLCJtYXhEcm9wVGltZSIsIm91dE9mVGhlV2F5VGltaW5nIiwidHJhbnNpdGlvbnMiLCJmbHVpZCIsInNuYXAiLCJkdXJhdGlvbiIsInRpbWluZyIsIm1vdmVUbyIsInVuZGVmaW5lZCIsInRyYW5zZm9ybXMiLCJpc0NvbWJpbmluZyIsInRyYW5zbGF0ZSIsImRyb3BUaW1lUmFuZ2UiLCJtYXhEcm9wVGltZUF0RGlzdGFuY2UiLCJjYW5jZWxEcm9wTW9kaWZpZXIiLCJnZXREcm9wRHVyYXRpb24iLCJkaXN0YW5jZSQxIiwicGVyY2VudGFnZSIsIndpdGhEdXJhdGlvbiIsIk51bWJlciIsInRvRml4ZWQiLCJnZXROZXdIb21lQ2xpZW50T2Zmc2V0IiwibmV3Q2xpZW50Q2VudGVyIiwiZ2V0RHJvcEltcGFjdCIsImxhc3RJbXBhY3QiLCJyZWNvbXB1dGVkSG9tZUltcGFjdCIsImRpZERyb3BJbnNpZGVEcm9wcGFibGUiLCJ3aXRob3V0TW92ZW1lbnQiLCJkcm9wTWlkZGxld2FyZSIsImlzV2FpdGluZ0ZvckRyb3AiLCJpc0FuaW1hdGlvblJlcXVpcmVkIiwiZ2V0V2luZG93U2Nyb2xsIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJpbmRpbmciLCJwYXNzaXZlIiwiY2FwdHVyZSIsImRvY3VtZW50IiwiZ2V0U2Nyb2xsTGlzdGVuZXIiLCJvbldpbmRvd1Njcm9sbCIsInVwZGF0ZVNjcm9sbCIsInNjaGVkdWxlZCIsImlzQWN0aXZlIiwic3RvcCIsImNhbmNlbCIsInNob3VsZFN0b3AkMSIsInNjcm9sbExpc3RlbmVyIiwic3RvcmUiLCJsaXN0ZW5lciIsImdldEV4cGlyaW5nQW5ub3VuY2UiLCJhbm5vdW5jZSIsIndhc0NhbGxlZCIsImlzRXhwaXJlZCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRBc3luY01hcnNoYWwiLCJlbnRyaWVzIiwiZXhlY3V0ZSIsInRpbWVySWQiLCJlbnRyeSIsInNwbGljZSIsImNhbGxiYWNrIiwic2hhbGxvdyIsImFyZUxvY2F0aW9uc0VxdWFsIiwiaXNDb21iaW5lRXF1YWwiLCJpc0NyaXRpY2FsRXF1YWwiLCJpc0RyYWdnYWJsZUVxdWFsIiwiaXNEcm9wcGFibGVFcXVhbCIsIndpdGhUaW1pbmdzIiwiZ2V0RHJhZ1N0YXJ0IiwicmVzcG9uZGVyIiwiZGF0YSIsImdldERlZmF1bHRNZXNzYWdlIiwid2lsbEV4cGlyZSIsInByb3ZpZGVkIiwiZ2V0UHVibGlzaGVyIiwiZ2V0UmVzcG9uZGVycyIsImFzeW5jTWFyc2hhbCIsImJlZm9yZUNhcHR1cmUiLCJvbkJlZm9yZUNhcHR1cmUiLCJiZWZvcmVTdGFydCIsIm9uQmVmb3JlRHJhZ1N0YXJ0IiwibGFzdENyaXRpY2FsIiwibGFzdExvY2F0aW9uIiwibGFzdENvbWJpbmUiLCJoYXNDcml0aWNhbENoYW5nZWQiLCJoYXNMb2NhdGlvbkNoYW5nZWQiLCJoYXNHcm91cGluZ0NoYW5nZWQiLCJhYm9ydCIsInJlc3BvbmRlcnMiLCJwdWJsaXNoZXIiLCJkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSIsImRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZSIsImZyYW1lSWQiLCJjbGVhciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwib25jZSIsImZsdXNoRHJvcEFuaW1hdGlvbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyIiwic3RvcFB1Ymxpc2hpbmciLCJmb2N1cyIsImlzV2F0Y2hpbmciLCJ0cnlSZWNvcmRGb2N1cyIsInRyeVJlc3RvcmVGb2N1c1JlY29yZGVkIiwidHJ5U2hpZnRSZWNvcmQiLCJzaG91bGRTdG9wIiwiYXV0b1Njcm9sbCIsImF1dG9TY3JvbGxlciIsInBlbmRpbmdEcm9wIiwicG9zdEFjdGlvblN0YXRlIiwiY29tcG9zZUVuaGFuY2VycyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsIm5hbWUiLCJkaW1lbnNpb25NYXJzaGFsIiwiZm9jdXNNYXJzaGFsIiwic3R5bGVNYXJzaGFsIiwiY2xlYW4kMSIsImNyZWF0ZVB1Ymxpc2hlciIsInJlZ2lzdHJ5Iiwic3RhZ2luZyIsImNvbGxlY3QiLCJnZXRCeUlkIiwiZ2V0RGltZW5zaW9uIiwiZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyIsInB1Ymxpc2giLCJnZXRNYXhTY3JvbGwiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImFkanVzdGVkTWF4U2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0TWF4V2luZG93U2Nyb2xsIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRWaWV3cG9ydCIsImdldEluaXRpYWxQdWJsaXNoIiwid2luZG93U2Nyb2xsIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwiLCJzaG91bGRQdWJsaXNoVXBkYXRlIiwiY3JlYXRlRGltZW5zaW9uTWFyc2hhbCIsImNvbGxlY3Rpb24iLCJleGlzdHMiLCJjaGFuZ2UiLCJkcmFnU3RvcHBlZCIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImNhblN0YXJ0RHJhZyIsInNjcm9sbFdpbmRvdyIsInNjcm9sbEJ5IiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMiLCJnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciIsIm1heWJlIiwiZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUiLCJkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyIsInN0YXJ0RnJvbVBlcmNlbnRhZ2UiLCJtYXhTY3JvbGxBdFBlcmNlbnRhZ2UiLCJtYXhQaXhlbFNjcm9sbCIsImVhc2UiLCJkdXJhdGlvbkRhbXBlbmluZyIsInN0b3BEYW1wZW5pbmdBdCIsImFjY2VsZXJhdGVBdCIsImRpc2FibGVkIiwiZ2V0RGlzdGFuY2VUaHJlc2hvbGRzIiwiY29udGFpbmVyIiwiZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyIsImF1dG9TY3JvbGxlck9wdGlvbnMiLCJzdGFydFNjcm9sbGluZ0Zyb20iLCJtYXhTY3JvbGxWYWx1ZUF0IiwidGhyZXNob2xkcyIsImdldFBlcmNlbnRhZ2UiLCJzdGFydE9mUmFuZ2UiLCJlbmRPZlJhbmdlIiwicmFuZ2UiLCJjdXJyZW50SW5SYW5nZSIsIm1pblNjcm9sbCIsImdldFZhbHVlRnJvbURpc3RhbmNlIiwiZGlzdGFuY2VUb0VkZ2UiLCJwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQiLCJwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSIsImNlaWwiLCJkYW1wZW5WYWx1ZUJ5VGltZSIsInByb3Bvc2VkU2Nyb2xsIiwiZHJhZ1N0YXJ0VGltZSIsInN0b3BBdCIsIkRhdGUiLCJydW5UaW1lIiwiYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UiLCJnZXRWYWx1ZSIsInNob3VsZFVzZVRpbWVEYW1wZW5pbmciLCJnZXRTY3JvbGxPbkF4aXMiLCJkaXN0YW5jZVRvRWRnZXMiLCJpc0Nsb3NlclRvRW5kIiwiYWRqdXN0Rm9yU2l6ZUxpbWl0cyIsImlzVG9vQmlnVmVydGljYWxseSIsImlzVG9vQmlnSG9yaXpvbnRhbGx5IiwiY2xlYW4iLCJnZXRTY3JvbGwkMSIsInJlcXVpcmVkIiwibGltaXRlZCIsInNtYWxsZXN0U2lnbmVkIiwiZ2V0T3ZlcmxhcCIsImdldFJlbWFpbmRlciIsInRhcmdldFNjcm9sbCIsIm92ZXJsYXAiLCJjYW5QYXJ0aWFsbHlTY3JvbGwiLCJyYXdNYXgiLCJzbWFsbGVzdENoYW5nZSIsImNhblNjcm9sbFdpbmRvdyIsImdldFdpbmRvd092ZXJsYXAiLCJjYW5TY3JvbGxEcm9wcGFibGUiLCJnZXREcm9wcGFibGVPdmVybGFwIiwiZ2V0V2luZG93U2Nyb2xsQ2hhbmdlIiwiZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlIiwiY3JlYXRlRmx1aWRTY3JvbGxlciIsInNjaGVkdWxlV2luZG93U2Nyb2xsIiwic2NoZWR1bGVEcm9wcGFibGVTY3JvbGwiLCJ0cnlTY3JvbGwiLCJzdGFydCQxIiwid2FzU2Nyb2xsTmVlZGVkIiwiZmFrZVNjcm9sbENhbGxiYWNrIiwiY3JlYXRlSnVtcFNjcm9sbGVyIiwibW92ZUJ5T2Zmc2V0Iiwic2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbiIsIndoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwiLCJyZW1haW5kZXIiLCJzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuIiwid2hhdFRoZVdpbmRvd0NhblNjcm9sbCIsImp1bXBTY3JvbGxlciIsImRyb3BwYWJsZVJlbWFpbmRlciIsIndpbmRvd1JlbWFpbmRlciIsImNyZWF0ZUF1dG9TY3JvbGxlciIsImZsdWlkU2Nyb2xsZXIiLCJqdW1wU2Nyb2xsIiwic2Nyb2xsZXIiLCJwcmVmaXgiLCJkcmFnSGFuZGxlIiwiYmFzZSIsImNvbnRleHRJZCIsInNjcm9sbENvbnRhaW5lciIsIm1ha2VHZXRTZWxlY3RvciIsImNvbnRleHQiLCJhdHRyaWJ1dGUiLCJnZXRTdHlsZXMiLCJydWxlcyIsInByb3BlcnR5IiwicnVsZSIsInN0eWxlcyIsInNlbGVjdG9yIiwibm9Qb2ludGVyRXZlbnRzIiwiZ2V0U3R5bGVzJDEiLCJnZXRTZWxlY3RvciIsImRyYWdIYW5kbGUkMSIsImdyYWJDdXJzb3IiLCJhbHdheXMiLCJkcm9wQW5pbWF0aW5nIiwiZHJhZ2dhYmxlJDEiLCJ0cmFuc2l0aW9uIiwidXNlckNhbmNlbCIsImRyb3BwYWJsZSQxIiwiYm9keSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiZ2V0SGVhZCIsImhlYWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlU3R5bGVFbCIsIm5vbmNlIiwic2V0QXR0cmlidXRlIiwidXNlU3R5bGVNYXJzaGFsIiwiYWx3YXlzUmVmIiwiZHluYW1pY1JlZiIsInNldER5bmFtaWNTdHlsZSIsInRleHRDb250ZW50Iiwic2V0QWx3YXlzU3R5bGUiLCJkeW5hbWljIiwiYXBwZW5kQ2hpbGQiLCJyZWYiLCJyZW1vdmVDaGlsZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwYXJlbnROb2RlIiwiQXJyYXkiLCJmcm9tIiwiZ2V0V2luZG93RnJvbUVsIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNIdG1sRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiZmluZERyYWdIYW5kbGUiLCJwb3NzaWJsZSIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsInVzZUZvY3VzTWFyc2hhbCIsImVudHJpZXNSZWYiLCJyZWNvcmRSZWYiLCJyZXN0b3JlRm9jdXNGcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsInRyeUdpdmVGb2N1cyIsInRyeUdpdmVGb2N1c1RvIiwiYWN0aXZlRWxlbWVudCIsInJlZGlyZWN0VG8iLCJyZWNvcmQiLCJmb2N1c2VkIiwiY2xlYXJGcmFtZU9uVW5tb3VudCIsImNyZWF0ZVJlZ2lzdHJ5Iiwic3Vic2NyaWJlcnMiLCJjYiIsIm5vdGlmeSIsImZpbmREcmFnZ2FibGVCeUlkIiwiZ2V0RHJhZ2dhYmxlQnlJZCIsImRyYWdnYWJsZUFQSSIsInVuaXF1ZUlkIiwiZmluZEJ5SWQiLCJmaW5kRHJvcHBhYmxlQnlJZCIsImdldERyb3BwYWJsZUJ5SWQiLCJkcm9wcGFibGVBUEkiLCJ1c2VSZWdpc3RyeSIsInVubW91bnQiLCJTdG9yZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZ2V0Qm9keUVsZW1lbnQiLCJ2aXN1YWxseUhpZGRlbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImdldElkIiwidXNlQW5ub3VuY2VyIiwic2V0dXAiLCJjbGVhbnVwIiwiZGVmYXVsdHMiLCJzZXBhcmF0b3IiLCJ1c2VVbmlxdWVJZCIsInVzZUlkIiwiZ2V0RWxlbWVudElkIiwidXNlSGlkZGVuVGV4dEVsZW1lbnQiLCJ0ZXh0IiwibW91bnQiLCJkaXNwbGF5IiwiQXBwQ29udGV4dCIsInBlZXJEZXBlbmRlbmNpZXMiLCJyZWFjdCIsInNlbXZlciIsImdldFZlcnNpb24iLCJleGVjIiwibWFqb3IiLCJtaW5vciIsInJhdyIsImlzU2F0aXNmaWVkIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGVja1JlYWN0VmVyc2lvbiIsInBlZXJEZXBWYWx1ZSIsImFjdHVhbFZhbHVlIiwicGVlckRlcCIsInN1ZmZpeCIsImNoZWNrRG9jdHlwZSIsImRvY3R5cGUiLCJ0b0xvd2VyQ2FzZSIsInB1YmxpY0lkIiwidXNlRGV2IiwidXNlSG9vayIsInVzZURldlNldHVwV2FybmluZyIsImlucHV0cyIsImUiLCJ1c2VTdGFydHVwVmFsaWRhdGlvbiIsInZlcnNpb24iLCJ1c2VQcmV2aW91cyIsImNyZWF0ZSIsImxvY2siLCJpc0NsYWltZWQiLCJjbGFpbSIsImFiYW5kb24iLCJuZXdMb2NrIiwicmVsZWFzZSIsInRyeUFiYW5kb24iLCJ0YWIiLCJlbnRlciIsImVzY2FwZSIsInNwYWNlIiwicGFnZVVwIiwicGFnZURvd24iLCJhcnJvd0xlZnQiLCJhcnJvd1VwIiwiYXJyb3dSaWdodCIsImFycm93RG93biIsInByZXZlbnRlZEtleXMiLCJwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMiLCJrZXlDb2RlIiwic3VwcG9ydGVkRXZlbnROYW1lIiwic3VwcG9ydGVkIiwicHJpbWFyeUJ1dHRvbiIsInNsb3BweUNsaWNrVGhyZXNob2xkIiwiaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkIiwiYWJzIiwiaWRsZSQxIiwiZ2V0Q2FwdHVyZUJpbmRpbmdzIiwiZ2V0UGhhc2UiLCJzZXRQaGFzZSIsImJ1dHRvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiYWN0aW9ucyIsInBlbmRpbmciLCJmbHVpZExpZnQiLCJzaG91bGRCbG9ja05leHRDbGljayIsInNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidXNlTW91c2VTZW5zb3IiLCJhcGkiLCJwaGFzZVJlZiIsInVuYmluZEV2ZW50c1JlZiIsInN0YXJ0Q2FwdHVyZUJpbmRpbmciLCJvbk1vdXNlRG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiZmluZENsb3Nlc3REcmFnZ2FibGVJZCIsInRyeUdldExvY2siLCJzb3VyY2VFdmVudCIsInN0YXJ0UGVuZGluZ0RyYWciLCJwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmciLCJmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSIsImNhbkdldExvY2siLCJsaXN0ZW5Gb3JDYXB0dXJlIiwiYmluZENhcHR1cmluZ0V2ZW50cyIsIm5vb3AkMSIsInNjcm9sbEp1bXBLZXlzIiwiZ2V0RHJhZ2dpbmdCaW5kaW5ncyIsInVzZUtleWJvYXJkU2Vuc29yIiwib25LZXlEb3duIiwicHJlRHJhZyIsImlzQ2FwdHVyaW5nIiwic25hcExpZnQiLCJ0cnlTdGFydENhcHR1cmUiLCJpZGxlIiwidGltZUZvckxvbmdQcmVzcyIsImZvcmNlUHJlc3NUaHJlc2hvbGQiLCJnZXRXaW5kb3dCaW5kaW5ncyIsImdldEhhbmRsZUJpbmRpbmdzIiwiaGFzTW92ZWQiLCJ0b3VjaGVzIiwidG91Y2giLCJpc0ZvcmNlUHJlc3MiLCJmb3JjZSIsInNob3VsZFJlc3BlY3QiLCJ1c2VUb3VjaFNlbnNvciIsIm9uVG91Y2hTdGFydCIsImxvbmdQcmVzc1RpbWVySWQiLCJ1bmJpbmRUYXJnZXQiLCJ1bmJpbmRXaW5kb3ciLCJzdGFydERyYWdnaW5nIiwid2Via2l0SGFjayIsInVzZVZhbGlkYXRlU2Vuc29ySG9va3MiLCJzZW5zb3JIb29rcyIsInByZXZpb3VzUmVmIiwiaW50ZXJhY3RpdmVUYWdOYW1lcyIsImlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJwYXJlbnQiLCJoYXNBbkludGVyYWN0aXZlVGFnIiwiaW5jbHVkZXMiLCJ0YWdOYW1lIiwicGFyZW50RWxlbWVudCIsImlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudCIsImdldEJvcmRlckJveENlbnRlclBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsInN1cHBvcnRlZE1hdGNoZXNOYW1lIiwiY2xvc2VzdFBvbnlmaWxsIiwiZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50IiwidHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50IiwiZmluZERyYWdnYWJsZSIsImlzTG9ja0FjdGl2ZSIsInNob3VsZFdhcm4iLCJjYW5TdGFydCIsImxvY2tBUEkiLCJ0cnlTdGFydCIsImZvcmNlU2Vuc29yU3RvcCIsInNob3VsZFN0YXJ0IiwiY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMiLCJnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInRyeURpc3BhdGNoIiwiZ2V0QWN0aW9uIiwidHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmciLCJsaWZ0QWN0aW9uQXJncyIsIm1vdmUkMSIsImFib3J0UHJlRHJhZyIsInNob3VsZFJlbGVhc2UiLCJkZWZhdWx0U2Vuc29ycyIsInVzZVNlbnNvck1hcnNoYWwiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsInQiLCJvbkJlZm9yZUNhcHVyZUNhbGxiYWNrIiwiY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJ1c2VVbmlxdWVDb250ZXh0SWQiLCJEcmFnRHJvcENvbnRleHQiLCJ6SW5kZXhPcHRpb25zIiwiZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uIiwic2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCIsImdldERyYWdnaW5nT3BhY2l0eSIsImlzRHJvcEFuaW1hdGluZyIsImdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSIsImdldERyYWdnaW5nU3R5bGUiLCJ0cmFuc2Zvcm0iLCJib3hTaXppbmciLCJ6SW5kZXgiLCJwb2ludGVyRXZlbnRzIiwiZ2V0U2Vjb25kYXJ5U3R5bGUiLCJzZWNvbmRhcnkiLCJzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50IiwiZ2V0U3R5bGUkMSIsIm1hcHBlZCIsImdldERpbWVuc2lvbiQxIiwiY29tcHV0ZWRTdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidXNlRHJhZ2dhYmxlUHVibGlzaGVyIiwiZ2V0RHJhZ2dhYmxlUmVmIiwicHVibGlzaGVkUmVmIiwiaXNGaXJzdFB1Ymxpc2hSZWYiLCJEcm9wcGFibGVDb250ZXh0IiwiY2hlY2tJc1ZhbGlkSW5uZXJSZWYiLCJ1c2VWYWxpZGF0aW9uJDEiLCJnZXRSZWYiLCJpc0ludGVnZXIiLCJ1c2VDbG9uZVByb3BWYWxpZGF0aW9uIiwiaXNDbG9uZSIsImluaXRpYWxSZWYiLCJ1c2VSZXF1aXJlZENvbnRleHQiLCJDb250ZXh0IiwicHJldmVudEh0bWw1RG5kIiwiRHJhZ2dhYmxlIiwic2V0UmVmIiwiZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uIiwiZm9yUHVibGlzaGVyIiwiZHJhZ0hhbmRsZVByb3BzIiwidGFiSW5kZXgiLCJyb2xlIiwib25Nb3ZlRW5kIiwicHJvcGVydHlOYW1lIiwib25UcmFuc2l0aW9uRW5kIiwiaW5uZXJSZWYiLCJkcmFnZ2FibGVQcm9wcyIsInJ1YnJpYyIsIkZyYWdtZW50Iiwic25hcHNob3QiLCJpc1N0cmljdEVxdWFsIiwid2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0IiwiZ2V0RHJhZ2dhYmxlU2VsZWN0b3IiLCJtZW1vaXplZE9mZnNldCIsImdldE1lbW9pemVkU25hcHNob3QiLCJkcmFnZ2luZ092ZXIiLCJkcm9wQW5pbWF0aW9uIiwiY29tYmluZVRhcmdldEZvciIsImdldE1lbW9pemVkUHJvcHMiLCJvd25Qcm9wcyIsImN1cnZlIiwiZ2V0U2Vjb25kYXJ5U25hcHNob3QiLCJhdFJlc3QiLCJnZXRTZWNvbmRhcnlTZWxlY3RvciIsImdldEZhbGxiYWNrIiwiZ2V0UHJvcHMiLCJvd25JZCIsImRyYWdnaW5nSWQiLCJ2aXN1YWxEaXNwbGFjZW1lbnQiLCJpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0IiwibWFrZU1hcFN0YXRlVG9Qcm9wcyQxIiwiZHJhZ2dpbmdTZWxlY3RvciIsInNlY29uZGFyeVNlbGVjdG9yIiwibWFwRGlzcGF0Y2hUb1Byb3BzJDEiLCJDb25uZWN0ZWREcmFnZ2FibGUiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJQcml2YXRlRHJhZ2dhYmxlIiwiZHJvcHBhYmxlQ29udGV4dCIsImlzVXNpbmdDbG9uZUZvciIsIlB1YmxpY0RyYWdnYWJsZSIsImlzRHJhZ0Rpc2FibGVkIiwiZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nIiwiaXNFcXVhbCIsImlzU2Nyb2xsIiwiaXNBdXRvIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiaXNCb2R5U2Nyb2xsYWJsZSIsImh0bWwiLCJodG1sU3R5bGUiLCJodG1sT3ZlcmZsb3ciLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZSIsImNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyIsImFub3RoZXJTY3JvbGxQYXJlbnQiLCJnZXRTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiZ2V0SXNGaXhlZCIsImdldEVudiIsImNsb3Nlc3RTY3JvbGxhYmxlIiwiZ2V0RHJvcHBhYmxlRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImZyYW1lQ2xpZW50IiwicGFkZGluZ0JveCIsImdldENsaWVudCIsInRhcmdldFJlZiIsImVudiIsImlzRHJvcERpc2FibGVkIiwiaW1tZWRpYXRlIiwiZGVsYXllZCIsImdldExpc3RlbmVyT3B0aW9ucyIsImdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWciLCJ1c2VEcm9wcGFibGVQdWJsaXNoZXIiLCJ3aGlsZURyYWdnaW5nUmVmIiwicHVibGlzaGVkRGVzY3JpcHRvclJlZiIsIm1lbW9pemVkVXBkYXRlU2Nyb2xsIiwiZ2V0Q2xvc2VzdFNjcm9sbCIsInNjaGVkdWxlU2Nyb2xsVXBkYXRlIiwib25DbG9zZXN0U2Nyb2xsIiwiZ2V0RHJvcHBhYmxlUmVmIiwiaWdub3JlQ29udGFpbmVyQ2xpcHBpbmciLCJyZW1vdmVBdHRyaWJ1dGUiLCJub29wIiwiZW1wdHkiLCJnZXRTaXplIiwiaXNBbmltYXRpbmdPcGVuT25Nb3VudCIsImFuaW1hdGUiLCJnZXRTdHlsZSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZsZXhTaHJpbmsiLCJmbGV4R3JvdyIsIlBsYWNlaG9sZGVyIiwiYW5pbWF0ZU9wZW5UaW1lclJlZiIsInRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciIsIm9uQ2xvc2UiLCJzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50Iiwib25TaXplQ2hhbmdlRW5kIiwiUGxhY2Vob2xkZXIkMSIsIm1lbW8iLCJpc0Jvb2xlYW4iLCJydW5DaGVja3MiLCJjaGVja3MiLCJjaGVjayIsImJvb2xlYW4iLCJzdGFuZGFyZCIsImdldFBsYWNlaG9sZGVyUmVmIiwidmlydHVhbCIsImhhc0Nsb25lIiwicmVuZGVyQ2xvbmUiLCJoYXNOb1BsYWNlaG9sZGVyIiwidXNlVmFsaWRhdGlvbiIsIkFuaW1hdGVJbk91dCIsIlB1cmVDb21wb25lbnQiLCJvbiIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIkRyb3BwYWJsZSIsImRyb3BwYWJsZVJlZiIsInBsYWNlaG9sZGVyUmVmIiwidXNlQ2xvbmUiLCJnZXRDb250YWluZXJGb3JDbG9uZSIsInNldERyb3BwYWJsZVJlZiIsInNldFBsYWNlaG9sZGVyUmVmIiwib25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQiLCJzaG91bGRBbmltYXRlUGxhY2Vob2xkZXIiLCJkcm9wcGFibGVQcm9wcyIsImdldENsb25lIiwibm9kZSIsImRyYWdnYWJsZVByb3ZpZGVkIiwiZHJhZ2dhYmxlU25hcHNob3QiLCJjcmVhdGVQb3J0YWwiLCJnZXRCb2R5IiwiZGVmYXVsdFByb3BzIiwiYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyIsIm1lcmdlZFByb3BzIiwiZGVmYXVsdFByb3BLZXkiLCJpc01hdGNoaW5nVHlwZSIsImdldERyYWdnYWJsZSIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMiLCJpZGxlV2l0aEFuaW1hdGlvbiIsImlzRHJhZ2dpbmdPdmVyIiwiZHJhZ2dpbmdPdmVyV2l0aCIsImRyYWdnaW5nRnJvbVRoaXNXaXRoIiwiaXNVc2luZ1BsYWNlaG9sZGVyIiwiaWRsZVdpdGhvdXRBbmltYXRpb24iLCJnZXREcmFnZ2FibGVSdWJyaWMiLCJnZXRNYXBQcm9wcyIsImlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIiLCJpc0RyYWdnaW5nT3ZlckZvckltcGFjdCIsImlzSG9tZSIsIm93blByb3BzV2l0aERlZmF1bHRQcm9wcyIsIndhc0NvbWJpbmluZyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIkNvbm5lY3RlZERyb3BwYWJsZSIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwiQ29ubmVjdGVkRHJvcHBhYmxlJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;